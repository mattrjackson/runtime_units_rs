#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use quantity::Quantity;
pub mod array_quantity {
    use crate::{errors::RuntimeUnitError, units_base::UnitDefinition};
    use core::ops::{AddAssign, Div, DivAssign, Mul, MulAssign, SubAssign};
    use std::ops::{Deref, DerefMut};
    #[cfg(feature="serde")]
    use serde_with::serde_as;
    #[doc = "Data structure to hold a unit and array of data"]
    pub struct ArrayQuantity<const N : usize> {
        pub unit: UnitDefinition,
        #[serde_as(r#as = "[_; N]")]
        #[serde(with =
        ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
        pub values: [f64; N],
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<const N : usize> _serde::Serialize for ArrayQuantity<N> {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    let mut __serde_state =
                        _serde::Serializer::serialize_struct(__serializer,
                                "ArrayQuantity", false as usize + 1 + 1)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "unit", &self.unit)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "values",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a, const N : usize> {
                                    values: (&'__a [f64; N],),
                                    phantom: _serde::__private::PhantomData<ArrayQuantity<N>>,
                                }
                                #[automatically_derived]
                                impl<'__a, const N : usize> _serde::Serialize for
                                    __SerializeWith<'__a, N> {
                                    fn serialize<__S>(&self, __s: __S)
                                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                                        __S: _serde::Serializer {
                                        ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                            __s)
                                    }
                                }
                                &__SerializeWith {
                                        values: (&self.values,),
                                        phantom: _serde::__private::PhantomData::<ArrayQuantity<N>>,
                                    }
                            })?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, const N : usize> _serde::Deserialize<'de> for
                ArrayQuantity<N> {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field { __field0, __field1, __ignore, }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "unit" => _serde::__private::Ok(__Field::__field0),
                                "values" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"unit" => _serde::__private::Ok(__Field::__field0),
                                b"values" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, const N : usize> {
                        marker: _serde::__private::PhantomData<ArrayQuantity<N>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de, const N : usize> _serde::de::Visitor<'de> for
                        __Visitor<'de, N> {
                        type Value = ArrayQuantity<N>;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "struct ArrayQuantity")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<UnitDefinition>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                    &"struct ArrayQuantity with 2 elements")),
                                };
                            let __field1 =
                                match {
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de, const N : usize> {
                                            value: [f64; N],
                                            phantom: _serde::__private::PhantomData<ArrayQuantity<N>>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                            __DeserializeWith<'de, N> {
                                            fn deserialize<__D>(__deserializer: __D)
                                                -> _serde::__private::Result<Self, __D::Error> where
                                                __D: _serde::Deserializer<'de> {
                                                _serde::__private::Ok(__DeserializeWith {
                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                            }
                                        }
                                        _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                        N>>(&mut __seq)?, |__wrap| __wrap.value)
                                    } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                    &"struct ArrayQuantity with 2 elements")),
                                };
                            _serde::__private::Ok(ArrayQuantity {
                                    unit: __field0,
                                    values: __field1,
                                })
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::MapAccess<'de> {
                            let mut __field0:
                                    _serde::__private::Option<UnitDefinition> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<[f64; N]> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                    _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("unit"));
                                            }
                                        __field0 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<UnitDefinition>(&mut __map)?);
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("values"));
                                            }
                                        __field1 =
                                            _serde::__private::Some({
                                                    #[doc(hidden)]
                                                    struct __DeserializeWith<'de, const N : usize> {
                                                        value: [f64; N],
                                                        phantom: _serde::__private::PhantomData<ArrayQuantity<N>>,
                                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                                    }
                                                    #[automatically_derived]
                                                    impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                        __DeserializeWith<'de, N> {
                                                        fn deserialize<__D>(__deserializer: __D)
                                                            -> _serde::__private::Result<Self, __D::Error> where
                                                            __D: _serde::Deserializer<'de> {
                                                            _serde::__private::Ok(__DeserializeWith {
                                                                    value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                    phantom: _serde::__private::PhantomData,
                                                                    lifetime: _serde::__private::PhantomData,
                                                                })
                                                        }
                                                    }
                                                    match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                N>>(&mut __map) {
                                                        _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    }
                                                });
                                    }
                                    _ => {
                                        let _ =
                                            _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("unit")?,
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(<__A::Error as
                                                        _serde::de::Error>::missing_field("values")),
                                };
                            _serde::__private::Ok(ArrayQuantity {
                                    unit: __field0,
                                    values: __field1,
                                })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["unit", "values"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                        "ArrayQuantity", FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ArrayQuantity<N>>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    #[automatically_derived]
    impl<const N : usize> ::core::marker::Copy for ArrayQuantity<N> { }
    #[automatically_derived]
    impl<const N : usize> ::core::clone::Clone for ArrayQuantity<N> {
        #[inline]
        fn clone(&self) -> ArrayQuantity<N> {
            let _: ::core::clone::AssertParamIsClone<UnitDefinition>;
            let _: ::core::clone::AssertParamIsClone<[f64; N]>;
            *self
        }
    }
    #[automatically_derived]
    impl<const N : usize> ::core::fmt::Debug for ArrayQuantity<N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "ArrayQuantity", "unit", &self.unit, "values", &&self.values)
        }
    }
    impl<const N : usize> Deref for ArrayQuantity<N> {
        type Target = [f64; N];
        fn deref(&self) -> &[f64; N] { &self.values }
    }
    impl<const N : usize> DerefMut for ArrayQuantity<N> {
        fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
    }
    impl<const N : usize> crate::traits::ArbitraryQuantity for
        ArrayQuantity<N> {
        fn unit(&self) -> UnitDefinition { self.unit }
        fn convert(&self, unit: UnitDefinition) -> Self {
            let mut result = self.clone();
            result.convert_mut(unit);
            return result;
        }
        fn convert_mut(&mut self, unit: UnitDefinition) {
            let factor = self.unit.convert_unchecked(unit);
            for val in self.values.as_mut_slice().iter_mut() {
                *val *= factor;
            }
        }
        fn try_convert(&self, unit: UnitDefinition)
            -> Result<Self, crate::errors::RuntimeUnitError> {
            if self.unit.base != unit.base {
                    Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                    let res =
                                        ::alloc::fmt::format(format_args!("Could not convert from base units of {0} to {1}",
                                                self.unit.unit_string(), unit.unit_string()));
                                    res
                                })))
                } else { Ok(self.convert(unit)) }
        }
        fn try_convert_mut(&mut self, unit: UnitDefinition)
            -> Result<(), crate::errors::RuntimeUnitError> {
            if self.unit.base != unit.base {
                    Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                    let res =
                                        ::alloc::fmt::format(format_args!("Could not convert from base units of {0} to {1}",
                                                self.unit.unit_string(), unit.unit_string()));
                                    res
                                })))
                } else { Ok(self.convert_mut(unit)) }
        }
        fn unit_mut(&mut self) -> &mut UnitDefinition { &mut self.unit }
    }
    impl<const N : usize> Div<f64> for ArrayQuantity<N> {
        type Output = ArrayQuantity<N>;
        fn div(self, rhs: f64) -> Self::Output {
            let mut result = self.clone();
            for val in result.values.as_mut_slice() { *val /= rhs; }
            result
        }
    }
    impl<const N : usize> Div<ArrayQuantity<N>> for ArrayQuantity<N> {
        type Output = ArrayQuantity<N>;
        fn div(self, rhs: ArrayQuantity<N>) -> Self::Output {
            let mut result = self.clone();
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            for (val, &rhs) in
                result.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val /= rhs;
            }
            result
        }
    }
    impl<const N : usize> Mul<ArrayQuantity<N>> for ArrayQuantity<N> {
        type Output = ArrayQuantity<N>;
        fn mul(self, rhs: ArrayQuantity<N>) -> Self::Output {
            let mut result = self.clone();
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            for (val, &rhs) in
                result.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val *= rhs;
            }
            result
        }
    }
    impl<const N : usize> Mul<f64> for ArrayQuantity<N> {
        type Output = ArrayQuantity<N>;
        fn mul(self, rhs: f64) -> Self::Output {
            let mut result = self.clone();
            for val in result.values.as_mut_slice() { *val *= rhs; }
            result
        }
    }
    impl<const N : usize> DivAssign<f64> for ArrayQuantity<N> {
        fn div_assign(&mut self, rhs: f64) {
            for val in self.values.as_mut_slice() { *val /= rhs; }
        }
    }
    impl<const N : usize> MulAssign<f64> for ArrayQuantity<N> {
        fn mul_assign(&mut self, rhs: f64) {
            for val in self.values.as_mut_slice() { *val *= rhs; }
        }
    }
    impl<const N : usize> DivAssign<ArrayQuantity<N>> for ArrayQuantity<N> {
        fn div_assign(&mut self, rhs: ArrayQuantity<N>) {
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            for (val, &rhs) in
                self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val /= rhs;
            }
        }
    }
    impl<const N : usize> AddAssign<ArrayQuantity<N>> for ArrayQuantity<N> {
        fn add_assign(&mut self, rhs: ArrayQuantity<N>) {
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            let factor = rhs.unit.convert_unchecked(self.unit);
            for (val, &rhs) in
                self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val += rhs * factor;
            }
        }
    }
    impl<const N : usize> SubAssign<ArrayQuantity<N>> for ArrayQuantity<N> {
        fn sub_assign(&mut self, rhs: ArrayQuantity<N>) {
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            let factor = rhs.unit.convert_unchecked(self.unit);
            for (val, &rhs) in
                self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val -= rhs * factor;
            }
        }
    }
}
pub mod errors {
    use core::fmt::Display;
    pub enum RuntimeUnitError { IncompatibleUnitConversion(String), }
    #[automatically_derived]
    impl ::core::clone::Clone for RuntimeUnitError {
        #[inline]
        fn clone(&self) -> RuntimeUnitError {
            match self {
                RuntimeUnitError::IncompatibleUnitConversion(__self_0) =>
                    RuntimeUnitError::IncompatibleUnitConversion(::core::clone::Clone::clone(__self_0)),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RuntimeUnitError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                RuntimeUnitError::IncompatibleUnitConversion(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "IncompatibleUnitConversion", &__self_0),
            }
        }
    }
    impl Display for RuntimeUnitError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_fmt(format_args!("{0:?}", self))
        }
    }
    #[cfg(feature="std")]
    impl std::error::Error for RuntimeUnitError { }
}
pub(crate) mod macros {
    #[macro_export]
    #[allow(clippy::eq_op)]
    macro_rules! prefix {
        (yotta) => { 1.0_E24 }; (zetta) => { 1.0_E21 }; (exa) => { 1.0_E18 };
        (peta) => { 1.0_E15 }; (tera) => { 1.0_E12 }; (giga) => { 1.0_E9 };
        (mega) => { 1.0_E6 }; (kilo) => { 1.0_E3 }; (hecto) => { 1.0_E2 };
        (deca) => { 1.0_E1 }; (none) => { 1.0_E0 }; (deci) => { 1.0_E-1 };
        (centi) => { 1.0_E-2 }; (milli) => { 1.0_E-3 }; (micro) =>
        { 1.0_E-6 }; (nano) => { 1.0_E-9 }; (pico) => { 1.0_E-12 }; (femto) =>
        { 1.0_E-15 }; (atto) => { 1.0_E-18 }; (zepto) => { 1.0_E-21 }; (yocto)
        => { 1.0_E-24 }; (yobi) =>
        {
            1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 *
            1024.0
        }; (zebi) =>
        { 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 };
        (exbi) => { 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 };
        (pebi) => { 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 }; (tebi) =>
        { 1024.0 * 1024.0 * 1024.0 * 1024.0 }; (gibi) =>
        { 1024.0 * 1024.0 * 1024.0 }; (mebi) => { 1024.0 * 1024.0 }; (kibi) =>
        { 1024.0 };
    }
    #[macro_export]
    macro_rules! impl_quantity_ops {
        ($quantity:ident) =>
        {
            use crate::traits::IsScalarQuantity; impl Mul<f64> for $quantity
            {
                type Output = $quantity; fn mul(self, rhs: f64) ->
                Self::Output
                { Self { value: self.value*rhs, unit: self.unit } }
            } impl Div<f64> for $quantity
            {
                type Output = $quantity; fn div(self, rhs: f64) ->
                Self::Output
                { Self { value: self.value/rhs, unit: self.unit } }
            } impl MulAssign<f64> for $quantity
            { fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; } } impl
            DivAssign<f64> for $quantity
            { fn div_assign(&mut self, rhs: f64) { self.value /= rhs; } } impl
            PartialEq<Quantity> for $quantity
            {
                fn eq(&self, other: &Quantity) -> bool
                { Quantity::from(*self).eq(other) }
            } impl PartialEq<$quantity> for Quantity
            { fn eq(&self, other: &$quantity) -> bool { *other == *self } }
            impl PartialEq<$quantity> for $quantity
            {
                fn eq(&self, other: &$quantity) -> bool
                {
                    self.value * self.definition().multiplier == other.value *
                    other.definition().multiplier
                }
            } impl<T:IsScalarQuantity> Mul<T> for $quantity
            {
                type Output = Quantity; fn mul(self, rhs: T) -> Quantity
                {
                    Quantity{
                        value: self.value*rhs.value(), unit:
                        self.definition()*rhs.unit()
                    }
                }
            } impl<T:IsScalarQuantity> Div<T> for $quantity
            {
                type Output = Quantity; fn div(self, rhs: T) -> Quantity
                {
                    Quantity{
                        value: self.value/rhs.value(), unit:
                        self.definition()/rhs.unit()
                    }
                }
            } impl Add<$quantity> for $quantity
            {
                type Output=Self; fn add(self, rhs: $quantity) -> Self
                {
                    let rhs_value = rhs.convert_unchecked(self.definition());
                    Self{ value: self.value + rhs_value, unit: self.unit }
                }
            } impl Sub<$quantity> for $quantity
            {
                type Output=Self; fn sub(self, rhs: $quantity) -> Self
                {
                    let rhs_value = rhs.convert_unchecked(self.definition());
                    Self{ value: self.value - rhs_value, unit: self.unit }
                }
            } impl AddAssign for $quantity
            {
                fn add_assign(&mut self, rhs: Self)
                {
                    let rhs_value = rhs.convert_unchecked(self.definition());
                    self.value += rhs_value;
                }
            } impl SubAssign for $quantity
            {
                fn sub_assign(&mut self, rhs: Self)
                {
                    let rhs_value = rhs.convert_unchecked(self.definition());
                    self.value -= rhs_value;
                }
            } impl Add<Quantity> for $quantity
            {
                type Output=Self; fn add(self, rhs: Quantity) -> Self
                {
                    if self.definition().base != rhs.unit.base
                    { panic!("Incompatible units added"); } let rhs_value =
                    rhs.convert_unchecked(self.definition());
                    Self{ value: self.value + rhs_value, unit: self.unit }
                }
            } impl Sub<Quantity> for $quantity
            {
                type Output=Self; fn sub(self, rhs: Quantity) -> Self
                {
                    if self.definition().base != rhs.unit.base
                    { panic!("Incompatible units subtracted"); } let rhs_value =
                    rhs.convert_unchecked(self.definition());
                    Self{ value: self.value - rhs_value, unit: self.unit }
                }
            } impl AddAssign<Quantity> for $quantity
            {
                fn add_assign(&mut self, rhs: Quantity)
                {
                    if self.definition().base != rhs.unit.base
                    { panic!("Incompatible units subtracted"); } let rhs_value =
                    rhs.convert_unchecked(self.definition()); self.value +=
                    rhs_value;
                }
            } impl SubAssign<Quantity> for $quantity
            {
                fn sub_assign(&mut self, rhs: Quantity)
                {
                    if self.definition().base != rhs.unit.base
                    { panic!("Incompatible units subtracted"); } let rhs_value =
                    rhs.convert_unchecked(self.definition()); self.value -=
                    rhs_value;
                }
            }
        }
    }
    #[macro_export]
    macro_rules! quantity {
        ($(#[$quantity_attr:meta])* quantity: $quantity:ident;
        $description:expr; $(#[$dim_attr:meta])* dimension:
        $system:ident<$($dimension:ident),+>; $(kind: $kind:ty;)? units
        {
            $($(#[$unit_attr:meta])* @$unit:ident: $conversion:expr;
            $abbreviation:literal, $singular:literal, $plural:literal;)+
        }) =>
        {
            #[cfg(feature="utoipa")] use utoipa::{ ToSchema, schema }; use
            $crate::errors::RuntimeUnitError; use $crate::Quantity; use
            $crate::units_base::{ UnitDefinition, UnitBase };
            paste::paste!{
                $(#[$quantity_attr])*
                #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
                #[cfg_attr(feature="serde",
                derive(serde::Serialize, serde::Deserialize))]
                #[allow(non_camel_case_types)] #[allow(clippy::eq_op)]
                #[cfg_attr(feature="utoipa", derive(ToSchema))]
                #[cfg_attr(feature="utoipa",
                schema(title = "" [<$quantity Unit>]))] pub enum
                [<$quantity Unit>] { $($unit,)+ }
            } paste::paste!
            {
                pub(crate) const [<$quantity:upper _UNIT_BASE>]: UnitBase =
                crate::units_base::UOMDimensions::to_unit_base(($($crate::units_base::UOMDimensions::$dimension,)+));
                $(pub(crate) const
                [<$quantity:upper _ $unit:upper _conversion:upper>]: f64 =
                $conversion;)+ impl [<$quantity Unit>]
                {
                    paste::paste!{
                        $(#[allow(clippy::eq_op)] pub fn [<get_$unit:snake>]() ->
                        UnitDefinition
                        {
                            UnitDefinition{
                                base: [<$quantity:upper _UNIT_BASE>], multiplier:
                                [<$quantity:upper _ $unit:upper _conversion:upper>]
                            }
                        })+
                    } #[doc = "Multiplier of unit to its base quantity."]
                    #[allow(clippy::eq_op)] pub fn multiplier(&self) -> f64
                    {
                        match self
                        {
                            $([<$quantity Unit>]::$unit =>
                            [<$quantity:upper _ $unit:upper _conversion:upper>],)+
                        }
                    } #[doc = "Abbreviation of unit."] pub fn
                    abbreviation(&self) -> &'static str
                    {
                        match self
                        { $([<$quantity Unit>]::$unit => $abbreviation,)+ }
                    } #[doc = "Singular name of unit."] pub fn singular(&self)
                    -> &'static str
                    {
                        match self { $([<$quantity Unit>]::$unit => $singular,)+ }
                    } #[doc = "Plural name of unit."] pub fn plural(&self) ->
                    &'static str
                    { match self { $([<$quantity Unit>]::$unit => $plural,)+ } }
                    #[doc = "Available units for this `[" [<$quantity Unit>]
                    "`]."] pub fn units() -> &'static [&'static str]
                    { const UNITS: &[&'static str] = &[$($singular,)+]; UNITS }
                } impl $crate::traits::Unit for [<$quantity Unit>]
                {
                    /// Return unit definition for this Unit Type                
                    fn definition(&self) -> UnitDefinition
                    {
                        match self
                        {
                            $([<$quantity
                            Unit>]::$unit=>[<$quantity Unit>]::[<get_$unit:snake>](),)+
                        }
                    } #[inline] fn base() -> UnitBase
                    { [<$quantity:upper _UNIT_BASE>] }
                }
            } paste::paste!
            {
                impl From<[<$quantity Unit>]> for $crate::Units
                {
                    fn from(value: [<$quantity Unit>]) -> Self
                    {
                        match value
                        {
                            $([<$quantity Unit>]::$unit =>
                            $crate::Units::$quantity([<$quantity Unit>]::$unit),)+
                        }
                    }
                } impl TryFrom<UnitDefinition> for [<$quantity Unit>]
                {
                    type Error = RuntimeUnitError;
                    #[allow(unreachable_patterns)] fn
                    try_from(value: UnitDefinition) -> Result<Self, Self::Error>
                    {
                        match value
                        {
                            $(UnitDefinition
                            {
                                base: [<$quantity:upper _UNIT_BASE>], multiplier:
                                [<$quantity:upper _ $unit:upper _conversion:upper>]
                            } => Ok([<$quantity Unit>]::$unit),)+ _ =>
                            Err(RuntimeUnitError::IncompatibleUnitConversion(format!("Could not convert from {:?} to {}",
                            value, stringify!($quantity))))
                        }
                    }
                } impl TryFrom<$crate::Units> for [<$quantity Unit>]
                {
                    type Error = RuntimeUnitError; fn
                    try_from(value: $crate::Units) -> Result<Self, Self::Error>
                    {
                        match value
                        {
                            $($crate::Units::$quantity([<$quantity Unit>]::$unit) =>
                            Ok([<$quantity Unit>]::$unit),)+ _ =>
                            Err(RuntimeUnitError::IncompatibleUnitConversion(format!("Could not convert from {} to {}",
                            value, stringify!($quantity))))
                        }
                    }
                } impl From<[<$quantity>]> for $crate::Units
                {
                    fn from(value: [<$quantity>]) -> Self
                    { $crate::Units::$quantity(value.unit) }
                } impl From<&[<$quantity>]> for $crate::Units
                {
                    fn from(value: &[<$quantity>]) -> Self
                    { $crate::Units::$quantity(value.unit) }
                } impl From<[<$quantity Vec>]> for $crate::Units
                {
                    fn from(value:[<$quantity Vec>]) -> Self
                    { $crate::Units::$quantity(value.unit) }
                } impl From<&[<$quantity Vec>]> for $crate::Units
                {
                    fn from(value: &[<$quantity Vec>]) -> Self
                    { $crate::Units::$quantity(value.unit) }
                }
            } paste::paste!
            {
                use $crate::traits::FixedQuantity; $(#[$quantity_attr])*
                #[derive(Copy, Clone, Debug)]
                #[cfg_attr(feature="serde",
                derive(serde::Serialize, serde::Deserialize))]
                #[cfg_attr(feature="utoipa", derive(ToSchema))]
                #[cfg_attr(feature="utoipa",
                schema(title = "" [<$quantity>]))]
                #[doc = "Scalar storage of a quantity (f64 and [`"
                [<$quantity Unit>]"`])."] pub struct $quantity
                { pub(crate) value: f64, pub(crate) unit: [<$quantity Unit>] }
                impl $quantity
                {
                    #[doc = "Create a new [`" [<$quantity Unit>]"`]."] pub fn
                    new(value: f64, unit: [<$quantity Unit>]) -> Self
                    { Self { value, unit } }
                    $(#[doc = "Create a new [`" [<$quantity>]
                    "`] with units of [`" [<$quantity Unit>] "::" [<$unit>]
                    "`]."] pub fn [<$unit:snake>](value: f64) -> Self
                    { Self { value, unit: [<$quantity Unit>]::$unit.into() } })+
                    #[doc = "Retrieve the value associated with this [`"
                    [<$quantity>]"`]."] #[inline] pub fn value(&self) -> f64
                    { self.value }
                    #[doc = "Retrieve the mutable value associated with this [`"
                    [<$quantity>]"`]."] #[inline] pub fn value_mut(&mut self) ->
                    &mut f64 { &mut self.value }
                    #[doc =
                    "Retrieve the `UnitDefinition` associated with this [`"
                    [<$quantity>]"`]."] #[inline] pub fn definition(&self) ->
                    UnitDefinition { self.unit.into() } #[inline]
                    /// Convert from one unit to another (no check is made to ensure destination unit is valid).
                    fn convert_unchecked(&self, unit: UnitDefinition) -> f64
                    {
                        let definition = self.definition(); if definition == unit
                        { self.value } else
                        { self.value * definition.multiplier / unit.multiplier() }
                    }
                    $(#[doc = "Convert to [`" [<$quantity Unit>] "::" [<$unit>]
                    "`]."] #[inline] pub fn [<to_ $unit:snake>](&self) -> Self
                    {
                        Self
                        {
                            value: self.value *
                            (self.definition().multiplier /
                            ([<$quantity:upper _ $unit:upper _conversion:upper>])) as
                            f64, unit: [<$quantity Unit>]::$unit
                        }
                    })+
                } impl FixedQuantity<[<$quantity Unit>]> for $quantity
                {
                    #[inline] fn unit(&self) -> [<$quantity Unit>] { self.unit }
                    #[inline] fn convert(&self, unit: [<$quantity Unit>]) ->
                    Self
                    {
                        Self
                        { value: self.convert_unchecked(unit.into()), unit: unit }
                    } #[inline] fn
                    convert_mut(&mut self, unit: [<$quantity Unit>])
                    {
                        self.value = self.convert_unchecked(unit.into()); self.unit
                        = unit;
                    } #[inline] fn unit_mut(&mut self) -> &mut
                    [<$quantity Unit>] { &mut self.unit } #[inline] fn
                    try_convert(&self, unit: $crate::Units) -> Result<Self,
                    RuntimeUnitError> where Self: Sized
                    {
                        let destination_unit: [<$quantity Unit>] = unit.try_into()?;
                        Ok(self.convert(destination_unit))
                    }
                } impl From<$quantity> for UnitDefinition
                {
                    #[inline] fn from(value: $quantity) -> Self
                    {
                        paste::paste!{
                            match value.unit
                            {
                                $([<$quantity Unit>]::$unit =>
                                [<$quantity Unit>]::[<get_$unit:snake>](),)+
                            }
                        }
                    }
                } impl From<$quantity> for Quantity
                {
                    fn from(quantity: $quantity) -> Self
                    {
                        Self { value: quantity.value, unit: quantity.unit.into() }
                    }
                } impl From<Quantity> for $quantity
                {
                    fn from(quantity: Quantity) -> $quantity
                    {
                        $quantity
                        {
                            value: quantity.value, unit:
                            [<$quantity Unit>]::try_from(quantity.unit).unwrap()
                        }
                    }
                } impl $crate::traits::IsScalarQuantity for $quantity
                {
                    fn value(&self) -> f64 { self.value } fn unit(&self) ->
                    UnitDefinition { self.unit.into() }
                } use crate::impl_quantity_ops; use
                crate::create_multivalue_quantities; use
                crate::{
                    impl_quantity_vec_ops, impl_quantity_array_ops,
                    create_multivalue_quantities_vec_enum,
                    create_multivalue_quantities_array_enum
                }; impl [<$quantity Vec>]
                {
                    #[doc = "Create a new vector of [`" [<$quantity Unit>]"`]."]
                    pub fn new(values: Vec<f64>, unit: [<$quantity Unit>]) ->
                    Self { Self{ values, unit } } #[inline]
                    #[doc = "Retrieve values associated with this [`"
                    [<$quantity Slice>]"`]."] pub fn values(&self) -> &Vec<f64>
                    { &self.values } #[inline]
                    #[doc =
                    "Retrieve the mutable values associated with this [`"
                    [<$quantity Slice>]"`]."] pub fn values_mut(&mut self) ->
                    &mut Vec<f64> { &mut self.values }
                    $(#[doc = "Create a new [`" [<$quantity>]
                    "`] with units of [`" [<$quantity Unit>] "::" [<$unit>]
                    "`]."] pub fn [<$unit:snake>](values: Vec<f64>) -> Self
                    { Self{ values, unit: [<$quantity Unit>]::$unit.into() } })+
                    $(#[doc = "Convert to [`" [<$quantity Unit>] "::" [<$unit>]
                    "`]."] #[inline] pub fn [<to_ $unit:snake>](&self) -> Self
                    {
                        use crate::traits::FixedSliceQuantity; let mut r =
                        self.clone(); r.convert_mut([<$quantity Unit>]::$unit); r
                    })+
                } impl_quantity_ops!($quantity);
                create_multivalue_quantities!($quantity);
                impl_quantity_vec_ops!($quantity);
                impl_quantity_array_ops!($quantity); use
                crate::vector_quantity::VecQuantity; impl
                From<[<$quantity Vec>]> for VecQuantity
                {
                    fn from(input: [<$quantity Vec>]) -> Self
                    {
                        VecQuantity{
                            unit: input.unit.definition(), values: input.values
                        }
                    }
                }
            } paste::paste!
            {
                impl From<[<$quantity Unit>]> for UnitDefinition
                {
                    #[inline] fn from(value: [<$quantity Unit>]) -> Self
                    {
                        paste::paste!{
                            match value
                            {
                                $([<$quantity Unit>]::$unit =>
                                [<$quantity Unit>]::[<get_$unit:snake>](),)+
                            }
                        }
                    }
                }
            } paste::paste!
            {
                impl TryFrom<&str> for [<$quantity Unit>]
                {
                    type Error = &'static str; fn try_from(value: &str) ->
                    Result<Self, Self::Error>
                    {
                        let abbreviation_check: Option<[<$quantity Unit>]> = match
                        value
                        {
                            $($abbreviation => Some([<$quantity Unit>]::$unit),)+ _ =>
                            None
                        }; if abbreviation_check.is_some()
                        { return Ok(abbreviation_check.unwrap()); } let
                        singular_check: Option<[<$quantity Unit>]> = match value
                        {
                            $($singular => Some([<$quantity Unit>]::$unit),)+ _ => None
                        }; if singular_check.is_some()
                        { return Ok(singular_check.unwrap()); } let plural_check:
                        Option<[<$quantity Unit>]> = match value
                        {
                            $($plural => Some([<$quantity Unit>]::$unit),)+ _ => None
                        }; if plural_check.is_some() { Ok(plural_check.unwrap()) }
                        else
                        {
                            Err(concat!("Unit \"{value}\" not supported for quantity \"",
                            stringify!{ $quantity }, "\""))
                        }
                    }
                }
            }
            paste::paste!{
                impl core::fmt::Display for [<$quantity Unit>]
                {
                    fn fmt(&self, f: &mut core::fmt::Formatter) ->
                    core::fmt::Result
                    {
                        match self
                        {
                            $([<$quantity Unit>]::$unit => write!(f, "{}", $singular),)+
                        }
                    }
                }
            }
        }
    }
    #[macro_export]
    macro_rules! system {
        ($(#[$units_attr:meta])* units: $units:ident { $($quantity:ident,)+ })
        =>
        {
            use $crate::units_base::UnitDefinition; use
            $crate::errors::RuntimeUnitError; use $crate::Quantity; use
            $crate::units::*; #[cfg(feature="utoipa")] use
            utoipa::{ ToSchema, schema }; use paste::paste;
            paste::paste!{
                $(paste::paste!{
                    #[cfg(any(feature = "" $quantity, feature="All"))] mod
                    [<$quantity:snake>];
                }
                paste::paste!{
                    #[cfg(any(feature = "" $quantity, feature="All"))] pub use
                    $crate::unit_definitions::[<$quantity:snake>]::[<$quantity
                    Array>];
                }
                paste::paste!{
                    #[cfg(any(feature = "" $quantity, feature="All"))] pub use
                    $crate::unit_definitions::[<$quantity:snake>]::$quantity;
                }
                paste::paste!{
                    #[cfg(any(feature = "" $quantity, feature="All"))] pub use
                    $crate::unit_definitions::[<$quantity:snake>]::[<$quantity
                    Vec>];
                })+ pub mod quantities
                {
                    $(paste::paste!{
                        #[allow(clippy::eq_op)]
                        #[cfg(any(feature = "" $quantity, feature="All"))] pub use
                        $crate::unit_definitions::[<$quantity:snake>]::$quantity;
                    })+ pub use $crate::quantity::Quantity;
                } pub mod quantities_array
                {
                    $(paste::paste!{
                        #[allow(clippy::eq_op)]
                        #[cfg(any(feature = "" $quantity, feature="All"))] pub use
                        $crate::unit_definitions::[<$quantity:snake>]::$quantity;
                    })+ pub use $crate::array_quantity::ArrayQuantity;
                } pub mod quantities_vector
                {
                    $(paste::paste!{
                        #[allow(clippy::eq_op)]
                        #[cfg(any(feature = "" $quantity, feature="All"))] pub use
                        $crate::unit_definitions::[<$quantity:snake>]::$quantity;
                    })+ pub use $crate::vector_quantity::VecQuantity;
                } pub mod units
                {
                    $(paste::paste!{
                        #[cfg(any(feature = "" $quantity, feature="All"))] pub use
                        $crate::unit_definitions::[<$quantity:snake>]::[<$quantity
                        Unit>];
                    })+
                }
            }
            paste!{
                ///
                /// A list of unit types supported for the library (given feature flags selected).
                /// 
                #[derive(Copy, Clone, Debug)] pub enum UnitTypes
                {
                    $(#[cfg(any(feature = "" $quantity, feature="All"))]
                    $quantity,)+
                }
            } impl UnitTypes
            {
                paste::paste!{
                    ///
                    /// Retrieve list of units available for this `UnitType`.
                    /// 
                    pub fn units(&self) -> &'static [&'static str]
                    {
                        match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            UnitTypes::$quantity=>[<$quantity:snake>]::[<$quantity
                            Unit>]::units(),)+
                        }
                    } ///
                    /// Convert a given unit string to the Corresponding `Units`
                    /// 
                    pub fn to_unit(&self, unit_str: &str) ->
                    Result<$crate::Units, &'static str>
                    {
                        match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            UnitTypes::$quantity =>
                            {
                                match crate::units::[<$quantity Unit>]::try_from(unit_str)
                                { Ok(r) => Ok(r.into()), Err(err) => Err(err) }
                            })+
                        }
                    }
                }
            }
            paste::paste!{
                #[derive(Copy, Clone, Debug, PartialEq)]
                #[cfg_attr(feature="serde",
                derive(serde::Serialize, serde::Deserialize))]
                #[cfg_attr(feature="utoipa", derive(ToSchema))] ///
                /// A wrapper to hold all quantities supported by this library. It is analogous to `Units``, 
                /// but when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit. 
                /// 
                pub enum Quantities
                {
                    $(#[cfg(any(feature = "" $quantity, feature="All"))]
                    #[cfg_attr(feature="utoipa", schema(title = "" $quantity))]
                    $quantity($quantity),)+
                } impl Quantities
                {
                    /// Get the `Units` enumeration associated with a given `Quantities` enumeration.
                    pub fn unit(&self) -> Units
                    {
                        match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Quantities::$quantity(x)=> $crate::Units::from(x.unit),)+
                        }
                    }
                    /// Try to convert to the unit specified by a given `Units` enumeration.
                    pub fn try_convert(&self, unit: Units) -> Result<Quantities,
                    RuntimeUnitError>
                    {
                        use crate::traits::FixedQuantity; match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Quantities::$quantity(x)=>
                            { Ok(Quantities::$quantity(x.try_convert(unit)?)) },)+
                        }
                    } /// Create a new quantity from a given value and unit
                    pub fn new(value: f64, unit: Units) -> Quantities
                    {
                        match unit
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Units::$quantity(x)=>
                            { Quantities::$quantity($quantity::new(value, x)) },)+
                        }
                    } /// Get the value associated with quantity.
                    pub fn value(&self) -> f64 { Quantity::from(*self).value() }
                }
                /// A means to create a default quantity with a given set of units.
                impl From<Units> for Quantities
                {
                    fn from(value: Units) -> Self
                    {
                        match value
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Units::$quantity(x)=>Quantities::$quantity(quantities::$quantity::new(0.0,
                            x)),)+
                        }
                    }
                } impl From<Quantities> for Quantity
                {
                    fn from(value: Quantities) -> Self
                    {
                        match value
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Quantities::$quantity(x)=>Quantity
                            {
                                value: x.value, unit:
                                UnitDefinition{
                                    multiplier: x.unit.multiplier(), base:
                                    [<$quantity:snake>]::[<$quantity:upper _UNIT_BASE>]
                                }
                            },)+
                        }
                    }
                } impl ToString for Quantities
                {
                    fn to_string(&self) -> String
                    {
                        match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Quantities::$quantity(x) =>
                            format!("{} {}", x.value(), x.unit.abbreviation()),)+
                        }
                    }
                }
                paste::paste!{
                    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
                    #[cfg_attr(feature="serde",
                    derive(serde::Serialize, serde::Deserialize))]
                    #[derive(Hash)]
                    #[cfg_attr(feature="utoipa", derive(ToSchema))] ///
                    /// A wrapper to hold all available units supported by the library. Contains utilities to convert from
                    /// a given arbitrary unit to the underlying `Quantity` that is used to perform unit conversion calculations.
                    /// 
                    pub enum Units
                    {
                        $(#[cfg(any(feature = "" $quantity, feature="All"))]
                        #[cfg_attr(feature="utoipa",
                        schema(title = "" [<$quantity Unit>]))]
                        $quantity([<$quantity Unit>]),)+
                    } impl From<Units> for $crate::units_base::UnitDefinition
                    {
                        fn from(value: Units) -> Self
                        {
                            match value
                            {
                                $(#[cfg(any(feature = "" $quantity, feature="All"))]
                                Units::$quantity(x)=>
                                UnitDefinition{
                                    multiplier: x.multiplier(), base:
                                    [<$quantity:snake>]::[<$quantity:upper _UNIT_BASE>]
                                },)+
                            }
                        }
                    }
                    paste::paste!{
                        impl core::fmt::Display for
                        Units{
                            fn fmt(&self, f: &mut core::fmt::Formatter) ->
                            core::fmt::Result
                            {
                                match self
                                {
                                    $(#[cfg(any(feature = "" $quantity, feature="All"))]
                                    Units::$quantity(x) => write!(f, "{}", x.singular()),)+
                                }
                            }
                        }
                    }
                } impl Units
                {
                    ///
                    /// Convert a given 'value' expressed in the given `Units` into a convertible `Quantity`
                    /// 
                    pub fn to_quantity(&self, value: f64) ->
                    $crate::quantity::Quantity
                    {
                        let unit: UnitDefinition = (*self).into();
                        $crate::quantity::Quantity { unit, value }
                    }
                    paste!{
                        ///
                        /// Get list of units available for this `Units` type
                        /// 
                        pub fn units(&self) -> &'static [&'static str]
                        {
                            match *self
                            {
                                $(#[cfg(any(feature = "" $quantity, feature="All"))]
                                Units::$quantity(_)=>[<$quantity:snake>]::[<$quantity
                                Unit>]::units(),)+
                            }
                        }
                    }
                } use
                crate::{
                    create_multivalue_quantities_vec_enum,
                    create_multivalue_quantities_array_enum
                }; create_multivalue_quantities_vec_enum!($($quantity),+);
                create_multivalue_quantities_array_enum!($($quantity),+);
            }
        };
    }
}
pub(crate) mod mutivalue_macros {
    #[macro_export]
    macro_rules! impl_quantity_vec_ops {
        ($quantity:ident) =>
        {
            paste::paste!
            {
                use
                core::ops::{
                    Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign,
                    DivAssign
                }; impl Div<f64> for [<$quantity Vec>]
                {
                    type Output = [<$quantity Vec>]; fn div(self, rhs: f64) ->
                    Self::Output
                    {
                        let mut result = self.clone(); for val in
                        result.values.as_mut_slice() { *val /= rhs; } result
                    }
                } impl Mul<f64> for [<$quantity Vec>]
                {
                    type Output = [<$quantity Vec>]; fn mul(self, rhs: f64) ->
                    Self::Output
                    {
                        let mut result = self.clone(); for val in
                        result.values.as_mut_slice() { *val *= rhs; } result
                    }
                } impl DivAssign<f64> for [<$quantity Vec>]
                {
                    fn div_assign(&mut self, rhs: f64)
                    { for val in self.values.as_mut_slice() { *val /= rhs; } }
                } impl MulAssign<f64> for [<$quantity Vec>]
                {
                    fn mul_assign(&mut self, rhs: f64)
                    { for val in self.values.as_mut_slice() { *val *= rhs; } }
                } use $crate::traits::Unit; impl AddAssign<[<$quantity Vec>]>
                for [<$quantity Vec>]
                {
                    fn add_assign(&mut self, rhs: [<$quantity Vec>])
                    {
                        if rhs.values.len() != self.values.len()
                        {
                            panic!("Slice dimensions do not match: {} != {}",
                            rhs.values.len(), self.values.len());
                        } let factor =
                        rhs.unit.definition().convert_unchecked(self.unit.definition());
                        for (val, &rhs) in
                        self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                        { *val += rhs*factor; }
                    }
                } impl SubAssign<[<$quantity Vec>]> for [<$quantity Vec>]
                {
                    fn sub_assign(&mut self, rhs: [<$quantity Vec>])
                    {
                        if rhs.values.len() != self.values.len()
                        {
                            panic!("Slice dimensions do not match: {} != {}",
                            rhs.values.len(), self.values.len());
                        } let factor = rhs.unit.convert_unchecked(self.unit); for
                        (val, &rhs) in
                        self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                        { *val -= rhs*factor; }
                    }
                }
            }
        }
    }
    #[macro_export]
    macro_rules! impl_quantity_array_ops {
        ($quantity:ident) =>
        {
            paste::paste!
            {
                impl<const N: usize> Div<f64> for [<$quantity Array>]<N>
                {
                    type Output = [<$quantity Array>]<N>; fn div(self, rhs: f64)
                    -> Self::Output
                    {
                        let mut result = self.clone(); for val in
                        result.values.as_mut_slice() { *val /= rhs; } result
                    }
                } impl<const N: usize> Mul<f64> for [<$quantity Array>]<N>
                {
                    type Output = [<$quantity Array>]<N>; fn mul(self, rhs: f64)
                    -> Self::Output
                    {
                        let mut result = self.clone(); for val in
                        result.values.as_mut_slice() { *val *= rhs; } result
                    }
                } impl<const N: usize> DivAssign<f64> for
                [<$quantity Array>]<N>
                {
                    fn div_assign(&mut self, rhs: f64)
                    { for val in self.values.as_mut_slice() { *val /= rhs; } }
                } impl<const N: usize> MulAssign<f64> for
                [<$quantity Array>]<N>
                {
                    fn mul_assign(&mut self, rhs: f64)
                    { for val in self.values.as_mut_slice() { *val *= rhs; } }
                } impl<const N: usize> AddAssign<[<$quantity Array>]<N>> for
                [<$quantity Array>]<N>
                {
                    fn add_assign(&mut self, rhs: [<$quantity Array>]<N>)
                    {
                        if rhs.values.len() != self.values.len()
                        {
                            panic!("Slice dimensions do not match: {} != {}",
                            rhs.values.len(), self.values.len());
                        } let factor =
                        rhs.unit.definition().convert_unchecked(self.unit.definition());
                        for (val, &rhs) in
                        self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                        { *val += rhs*factor; }
                    }
                } impl<const N: usize> SubAssign<[<$quantity Array>]<N>> for
                [<$quantity Array>]<N>
                {
                    fn sub_assign(&mut self, rhs: [<$quantity Array>]<N>)
                    {
                        if rhs.values.len() != self.values.len()
                        {
                            panic!("Slice dimensions do not match: {} != {}",
                            rhs.values.len(), self.values.len());
                        } let factor = rhs.unit.convert_unchecked(self.unit); for
                        (val, &rhs) in
                        self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                        { *val -= rhs*factor; }
                    }
                }
            }
        }
    }
    #[macro_export]
    macro_rules! create_multivalue_quantities {
        ($quantity:ident) =>
        {
            #[cfg(feature="serde")] use serde_with::serde_as; use
            std::ops::{ Deref, DerefMut }; paste::paste!
            {
                #[cfg_attr(feature="serde", cfg_eval::cfg_eval, serde_as)]
                #[derive(Copy, Clone, Debug, PartialEq)]
                #[cfg_attr(feature="serde",
                derive(serde::Serialize, serde::Deserialize))]
                #[cfg_attr(feature="utoipa", derive(ToSchema))]
                #[doc = "Array storage for a series of values and [`"
                [<$quantity Unit>]"`]."] pub struct [<$quantity Array>]<const
                N: usize>
                {
                    pub(crate) unit: [<$quantity Unit>],
                    #[cfg_attr(feature="serde", serde_as(as = "[_; N]"))]
                    pub(crate) values: [f64; N],
                } impl<const N: usize> Deref for [<$quantity Array>]<N>
                {
                    type Target = [f64; N]; fn deref(&self) -> &[f64; N]
                    { &self.values }
                } impl<const N: usize> DerefMut for [<$quantity Array>]<N>
                {
                    fn deref_mut(&mut self) -> &mut [f64; N]
                    { &mut self.values }
                } #[derive(Clone, Debug, PartialEq)]
                #[cfg_attr(feature="serde",
                derive(serde::Serialize, serde::Deserialize))]
                #[cfg_attr(feature="utoipa", derive(ToSchema))]
                #[doc = "Vector storage for a series of values and [`"
                [<$quantity Unit>]"`]."] pub struct [<$quantity Vec>]
                {
                    pub(crate) unit: [<$quantity Unit>], pub(crate) values:
                    Vec<f64>
                } impl Deref for [<$quantity Vec>]
                {
                    type Target = Vec<f64>; fn deref(&self) -> &Vec<f64>
                    { &self.values }
                } impl DerefMut for [<$quantity Vec>]
                {
                    fn deref_mut(&mut self) -> &mut Vec<f64>
                    { &mut self.values }
                } impl crate::traits::FixedSliceQuantity<[<$quantity Unit>],
                f64> for [<$quantity Vec>]
                {
                    fn unit(&self) -> [<$quantity Unit>] { self.unit } fn
                    values(&self) -> &[f64] { &self.values.as_slice() } fn
                    values_mut(&mut self) -> &mut [f64]
                    { self.values.as_mut_slice() } fn len(&self) -> usize
                    { self.values.len() } fn
                    convert(&self, unit: [<$quantity Unit>]) -> Self
                    {
                        let mut result = self.clone(); result.convert_mut(unit);
                        return result;
                    } #[inline] fn
                    convert_mut(&mut self, unit: [<$quantity Unit>])
                    {
                        let factor =
                        self.unit.definition().convert_unchecked(unit.definition());
                        for val in self.values.as_mut_slice().iter_mut()
                        { *val *= factor; } self.unit = unit;
                    } #[inline] fn try_convert(&self, unit: $crate::Units) ->
                    Result<Self, RuntimeUnitError> where Self: Sized
                    {
                        let destination_unit: [<$quantity Unit>] = unit.try_into()?;
                        Ok(self.convert(destination_unit))
                    }
                } impl<const N: usize>
                crate::traits::FixedSliceQuantity<[<$quantity Unit>], f64> for
                [<$quantity Array>]<N>
                {
                    fn unit(&self) -> [<$quantity Unit>] { self.unit } fn
                    values(&self) -> &[f64] { &self.values.as_slice() } fn
                    values_mut(&mut self) -> &mut [f64]
                    { self.values.as_mut_slice() } fn len(&self) -> usize
                    { self.values.len() } fn
                    convert(&self, unit: [<$quantity Unit>]) -> Self
                    {
                        let mut result = self.clone(); result.convert_mut(unit);
                        return result;
                    } #[inline] fn
                    convert_mut(&mut self, unit: [<$quantity Unit>])
                    {
                        let factor =
                        self.unit.definition().convert_unchecked(unit.definition());
                        for val in self.values.as_mut_slice().iter_mut()
                        { *val *= factor; } self.unit = unit;
                    } #[inline] fn try_convert(&self, unit: $crate::Units) ->
                    Result<Self, RuntimeUnitError> where Self: Sized
                    {
                        let destination_unit: [<$quantity Unit>] = unit.try_into()?;
                        Ok(self.convert(destination_unit))
                    }
                }
            }
        }
    }
    #[macro_export]
    macro_rules! create_multivalue_quantities_vec_enum {
        ($($quantity:ident),+) =>
        {
            paste::paste!{
                #[derive(Clone, Debug, PartialEq)]
                #[cfg_attr(feature="serde",
                derive(serde::Serialize, serde::Deserialize))]
                #[cfg_attr(feature="utoipa", derive(ToSchema))] ///
                /// A wrapper to hold all QuantitiesVec supported by this library. It is analogous to `Units``, 
                /// but when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit. 
                /// 
                pub enum QuantitiesVec
                {
                    $(#[cfg(any(feature = "" $quantity, feature="All"))]
                    #[cfg_attr(feature="utoipa", schema(title = "" $quantity))]
                    $quantity([<$quantity Vec>]),)+
                } impl QuantitiesVec
                {
                    /// Get the `Units` enumeration associated with a given `QuantitiesVec` enumeration.
                    pub fn unit(&self) -> Units
                    {
                        use crate::traits::FixedSliceQuantity; match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesVec::$quantity(x)=>
                            $crate::Units::from(x.unit()),)+
                        }
                    }
                    /// Try to convert to the unit specified by a given `Units` enumeration.
                    pub fn try_convert(&self, unit: Units) ->
                    Result<QuantitiesVec, RuntimeUnitError>
                    {
                        use crate::traits::FixedSliceQuantity; match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesVec::$quantity(x)=>
                            { Ok(QuantitiesVec::$quantity(x.try_convert(unit)?)) },)+
                        }
                    } /// Create a new quantity from a given value and unit
                    pub fn new(value: Vec<f64>, unit: Units) -> QuantitiesVec
                    {
                        match unit
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Units::$quantity(x)=>
                            {
                                QuantitiesVec::$quantity([<$quantity Vec>]::new(value, x))
                            },)+
                        }
                    } /// Get the value associated with quantity.
                    pub fn values(&self) -> Vec<f64>
                    {
                        use crate::vector_quantity::VecQuantity;
                        VecQuantity::from(self.clone()).values
                    }
                }
                /// A means to create a default quantity with a given set of units.
                impl From<Units> for QuantitiesVec
                {
                    fn from(value: Units) -> Self
                    {
                        match value
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Units::$quantity(x)=>
                            { QuantitiesVec::new(vec![0.0], x.into()) },)+
                        }
                    }
                } impl From<QuantitiesVec> for
                crate::vector_quantity::VecQuantity
                {
                    fn from(value: QuantitiesVec) -> Self
                    {
                        match value
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesVec::$quantity(x)=>crate::vector_quantity::VecQuantity
                            {
                                values: x.values, unit:
                                UnitDefinition{
                                    multiplier: x.unit.multiplier(), base:
                                    [<$quantity:snake>]::[<$quantity:upper _UNIT_BASE>]
                                }
                            },)+
                        }
                    }
                } impl ToString for QuantitiesVec
                {
                    fn to_string(&self) -> String
                    {
                        match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesVec::$quantity(x) =>
                            format!("{:?} {}", x.values, x.unit.abbreviation()),)+
                        }
                    }
                }
            }
        }
    }
    #[macro_export]
    macro_rules! create_multivalue_quantities_array_enum {
        ($($quantity:ident),+) =>
        {
            paste::paste!{
                #[derive(Copy, Clone, Debug, PartialEq)]
                #[cfg_attr(feature="serde",
                derive(serde::Serialize, serde::Deserialize))] ///
                /// A wrapper to hold all QuantitiesArray supported by this library. It is analogous to `Units``, 
                /// but when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit. 
                /// 
                pub enum QuantitiesArray<const N: usize>
                {
                    $(#[cfg(any(feature = "" $quantity, feature="All"))]
                    $quantity([<$quantity Array>]<N>),)+
                } impl<const N: usize> QuantitiesArray<N>
                {
                    /// Get the `Units` enumeration associated with a given `QuantitiesArray` enumeration.
                    pub fn unit(&self) -> Units
                    {
                        match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesArray::$quantity(x)=>
                            $crate::Units::from(x.unit),)+
                        }
                    }
                    /// Try to convert to the unit specified by a given `Units` enumeration.
                    pub fn try_convert(&self, unit: Units) ->
                    Result<QuantitiesArray<N>, RuntimeUnitError>
                    {
                        use crate::traits::FixedSliceQuantity; match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesArray::$quantity(x)=>
                            { Ok(QuantitiesArray::$quantity(x.try_convert(unit)?)) },)+
                        }
                    } /// Create a new quantity from a given value and unit
                    pub fn new(value: [f64; N], unit: Units) ->
                    QuantitiesArray<N>
                    {
                        match unit
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Units::$quantity(x)=>
                            {
                                QuantitiesArray::$quantity([<$quantity
                                Array>]{ values: value, unit:x })
                            },)+
                        }
                    } /// Get the value associated with quantity.
                    pub fn values(&self) -> [f64; N]
                    {
                        use crate::array_quantity::ArrayQuantity;
                        ArrayQuantity::from(*self).values
                    }
                }
                /// A means to create a default quantity with a given set of units.
                impl<const N: usize> From<Units> for QuantitiesArray<N>
                {
                    fn from(value: Units) -> Self
                    {
                        match value
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            Units::$quantity(x)=>
                            QuantitiesArray::new([0.0; N], x.into()),)+
                        }
                    }
                } impl<const N: usize> From<QuantitiesArray<N>> for
                crate::array_quantity::ArrayQuantity<N>
                {
                    fn from(value: QuantitiesArray<N>) -> Self
                    {
                        use crate::array_quantity::ArrayQuantity; match value
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesArray::$quantity(x)=>ArrayQuantity
                            {
                                values: x.values, unit:
                                UnitDefinition{
                                    multiplier: x.unit.multiplier(), base:
                                    [<$quantity:snake>]::[<$quantity:upper _UNIT_BASE>]
                                }
                            },)+
                        }
                    }
                } impl<const N: usize> ToString for QuantitiesArray<N>
                {
                    fn to_string(&self) -> String
                    {
                        match self
                        {
                            $(#[cfg(any(feature = "" $quantity, feature="All"))]
                            QuantitiesArray::$quantity(x) =>
                            format!("{:?} {}", x.values, x.unit.abbreviation()),)+
                        }
                    }
                }
            }
        }
    }
}
pub(crate) mod quantity {
    use core::fmt::Debug;
    use core::ops::{
        Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign,
    };
    use crate::errors::RuntimeUnitError;
    use crate::units_base::UnitDefinition;
    impl crate::traits::ArbitraryQuantity for Quantity {
        fn unit(&self) -> UnitDefinition { self.unit }
        fn convert(&self, unit: UnitDefinition) -> Quantity {
            Quantity {
                value: self.value() * self.unit.convert_unchecked(unit),
                unit,
            }
        }
        fn try_convert_mut(&mut self, unit: UnitDefinition)
            -> Result<(), RuntimeUnitError> {
            self.value *= self.unit.try_convert(unit)?;
            Ok(())
        }
        fn convert_mut(&mut self, unit: UnitDefinition) {
            self.value *= self.unit.convert_unchecked(unit);
        }
        fn try_convert(&self, unit: UnitDefinition)
            -> Result<Quantity, RuntimeUnitError> {
            Ok(Quantity {
                    value: self.value * self.unit.try_convert(unit)?,
                    unit,
                })
        }
        fn unit_mut(&mut self) -> &mut UnitDefinition { &mut self.unit }
    }
    #[doc =
    "A quantity of a unit, supports converting from one unit to another."]
    pub struct Quantity {
        pub(crate) value: f64,
        pub(crate) unit: UnitDefinition,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Quantity { }
    #[automatically_derived]
    impl ::core::clone::Clone for Quantity {
        #[inline]
        fn clone(&self) -> Quantity {
            let _: ::core::clone::AssertParamIsClone<f64>;
            let _: ::core::clone::AssertParamIsClone<UnitDefinition>;
            *self
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Quantity {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    let mut __serde_state =
                        _serde::Serializer::serialize_struct(__serializer,
                                "Quantity", false as usize + 1 + 1)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "value", &self.value)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "unit", &self.unit)?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Quantity {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field { __field0, __field1, __ignore, }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "value" => _serde::__private::Ok(__Field::__field0),
                                "unit" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"value" => _serde::__private::Ok(__Field::__field0),
                                b"unit" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Quantity>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Quantity;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "struct Quantity")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                    &"struct Quantity with 2 elements")),
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<UnitDefinition>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                    &"struct Quantity with 2 elements")),
                                };
                            _serde::__private::Ok(Quantity {
                                    value: __field0,
                                    unit: __field1,
                                })
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::MapAccess<'de> {
                            let mut __field0: _serde::__private::Option<f64> =
                                _serde::__private::None;
                            let mut __field1:
                                    _serde::__private::Option<UnitDefinition> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                    _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("value"));
                                            }
                                        __field0 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("unit"));
                                            }
                                        __field1 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<UnitDefinition>(&mut __map)?);
                                    }
                                    _ => {
                                        let _ =
                                            _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("value")?,
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("unit")?,
                                };
                            _serde::__private::Ok(Quantity {
                                    value: __field0,
                                    unit: __field1,
                                })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["value", "unit"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                        "Quantity", FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Quantity>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    impl Quantity {
        ///
        /// Create a new instance of `Quantity` with a given `value` and `unit` 
        ///
        pub fn new(value: f64, unit: UnitDefinition) -> Self {
            Self { value, unit }
        }
        ///
        /// Amount of unit stored in quantity
        /// 
        #[inline]
        pub fn value(&self) -> f64 { self.value }
        ///
        /// Get mutable reference to the value for this quantity.
        /// 
        #[inline]
        pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
        #[inline]
        /// Convert from one unit to another (no check is made to ensure destination unit is valid).
        pub(crate) fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
            if self.unit == unit {
                    self.value
                } else {
                   self.value * self.unit.multiplier / unit.multiplier()
               }
        }
    }
    impl Debug for Quantity {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_fmt(format_args!("{0} {1:?}", self.value(), self.unit))
        }
    }
    impl Mul<f64> for Quantity {
        type Output = Quantity;
        fn mul(self, rhs: f64) -> Self::Output {
            Self { value: self.value * rhs, unit: self.unit }
        }
    }
    impl Div<f64> for Quantity {
        type Output = Quantity;
        fn div(self, rhs: f64) -> Self::Output {
            Self { value: self.value / rhs, unit: self.unit }
        }
    }
    impl Mul<Quantity> for Quantity {
        type Output = Quantity;
        fn mul(self, rhs: Quantity) -> Self::Output {
            Self { value: self.value * rhs.value, unit: self.unit * rhs.unit }
        }
    }
    impl Div<Quantity> for Quantity {
        type Output = Quantity;
        fn div(self, rhs: Quantity) -> Self::Output {
            Self { value: self.value / rhs.value, unit: self.unit / rhs.unit }
        }
    }
    impl Add<Quantity> for Quantity {
        type Output = Quantity;
        fn add(self, rhs: Quantity) -> Self::Output {
            Self { value: self.value + rhs.value, unit: self.unit }
        }
    }
    impl Sub<Quantity> for Quantity {
        type Output = Quantity;
        fn sub(self, rhs: Quantity) -> Self::Output {
            Self { value: self.value - rhs.value, unit: self.unit }
        }
    }
    impl AddAssign for Quantity {
        fn add_assign(&mut self, rhs: Self) { self.value += rhs.value; }
    }
    impl SubAssign for Quantity {
        fn sub_assign(&mut self, rhs: Self) { self.value -= rhs.value; }
    }
    impl MulAssign for Quantity {
        fn mul_assign(&mut self, rhs: Self) {
            self.value *= rhs.value;
            self.unit *= rhs.unit;
        }
    }
    impl MulAssign<f64> for Quantity {
        fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
    }
    impl DivAssign for Quantity {
        fn div_assign(&mut self, rhs: Self) {
            self.value /= rhs.value;
            self.unit /= rhs.unit;
        }
    }
    impl DivAssign<f64> for Quantity {
        fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
    }
    ///
    /// This only compares magnitudes...
    /// 
    impl PartialOrd<Quantity> for Quantity {
        fn partial_cmp(&self, other: &Quantity)
            -> Option<core::cmp::Ordering> {
            self.convert_unchecked(other.unit).partial_cmp(&other.value)
        }
    }
    impl PartialEq for Quantity {
        fn eq(&self, other: &Self) -> bool {
            self.unit.base == other.unit.base &&
                self.convert_unchecked(other.unit) == other.value
        }
    }
}
mod tests {}
pub mod traits {
    use crate::{
        errors::RuntimeUnitError, units_base::{UnitBase, UnitDefinition},
        Units,
    };
    use core::ops::{Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};
    pub(crate) trait IsScalarQuantity {
        fn value(&self)
        -> f64;
        fn unit(&self)
        -> UnitDefinition;
    }
    ///
    /// Trait that implements conversion of an arbitrary quantity into another
    /// 
    pub trait ArbitraryQuantity where Self: Sized + Div<f64> + Mul<f64> +
        DivAssign<f64> + MulAssign<f64> + Div<Self> + Mul<Self> +
        AddAssign<Self> + SubAssign<Self> + DivAssign<Self> {
        /// Return unit associated with this quantity
        fn unit(&self)
        -> UnitDefinition;
        /// Return unit associated with this quantity (mutable)
        fn unit_mut(&mut self)
        -> &mut UnitDefinition;
        /// Try to convert from this unit to another (creates a copy)
        fn try_convert(&self, unit: UnitDefinition)
        -> Result<Self, RuntimeUnitError>;
        #[inline]
        /// Try to convert from this unit to the given `unit` (creates a copy)
        fn try_convert_unit(&self, unit: Units)
            -> Result<Self, RuntimeUnitError> {
            self.try_convert(unit.into())
        }
        /// Try to convert from this unit to another (modifies current quantity)
        fn try_convert_mut(&mut self, unit: UnitDefinition)
        -> Result<(), RuntimeUnitError>;
        /// Convert from this unit to another (creates a copy). No validation of base unit is made.
        fn convert(&self, unit: UnitDefinition)
        -> Self;
        /// Convert from this unit to another (modifies current quantity). No validation of base unit is made.
        fn convert_mut(&mut self, unit: UnitDefinition);
    }
    ///
    /// Trait that implements conversion of a quantity within a given unit type (e.g. m->cm, kg->g)
    /// 
    pub trait FixedQuantity<UnitType: Unit> where Self: Sized + Div<f64> +
        Mul<f64> + DivAssign<f64> + MulAssign<f64> + AddAssign<Self> +
        SubAssign<Self> {
        /// Return unit associated with this quantity
        fn unit(&self)
        -> UnitType;
        /// Return mutable unit associated with this quantity
        fn unit_mut(&mut self)
        -> &mut UnitType;
        /// Convert from this unit to another (creates a copy). No validation of base unit is made.
        fn convert(&self, unit: UnitType)
        -> Self;
        /// Convert from this unit to another (modifies current quantity). No validation of base unit is made.
        fn convert_mut(&mut self, unit: UnitType);
        /// Try to convert from this unit to another (creates a copy)
        fn try_convert(&self, unit: crate::Units)
        -> Result<Self, RuntimeUnitError>
        where
        Self: Sized;
    }
    ///
    /// Trait that implements conversion of a slice quantity within a given unit type (e.g. m->cm, kg->g)
    /// 
    pub trait FixedSliceQuantity<UnitType: Unit, Element> {
        /// Return unit associated with this quantity
        fn unit(&self)
        -> UnitType;
        /// Return values in quantity
        fn values(&self)
        -> &[Element];
        /// Return mutable values in quantity
        fn values_mut(&mut self)
        -> &mut [Element];
        /// Return number of values in quantity
        fn len(&self)
        -> usize;
        /// Convert a unit of one `UnitType` to another of the same type. No validation of base unit is made.
        fn convert(&self, unit: UnitType)
        -> Self;
        /// Mutate current quantity, convering  a unit of one `UnitType` to another of the same type. No validation of base unit is made.
        fn convert_mut(&mut self, unit: UnitType);
        /// Attempt to convert the unit given in `unit` to a `UnitType`. Base unit validation is made here.
        fn try_convert(&self, unit: Units)
        -> Result<Self, RuntimeUnitError>
        where
        Self: Sized;
    }
    ///
    /// Trait to define a type of unit (e.g. `LengthUnit`,`MassUnit`)
    /// 
    pub trait Unit where Self: Sized {
        /// Return unit definition for this Unit Type
        fn definition(&self)
        -> UnitDefinition;
        /// Base unit definition
        fn base()
        -> UnitBase;
        /// Try to compute conversion factor from this unit to another.
        #[inline]
        fn try_convert(&self, unit: UnitDefinition)
            -> Result<f64, RuntimeUnitError> {
            let definition = self.definition();
            if definition.is_convertible(unit) {
                    Ok(unit.multiplier() / definition.multiplier())
                } else {
                   Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                   let res =
                                       ::alloc::fmt::format(format_args!("Could not convert from base units of {0} to {1}",
                                               definition.unit_string(), unit.unit_string()));
                                   res
                               })))
               }
        }
        /// Compute conversion factor from this unit to another (no check of unit compatibility is made).
        #[inline]
        fn convert_unchecked(&self, unit: Self) -> f64 {
            let definition = self.definition();
            unit.definition().multiplier() / definition.multiplier()
        }
    }
}
pub mod units_base {
    use core::{fmt::Display, ops::{Div, DivAssign, Mul, MulAssign}};
    use bitfield_struct::bitfield;
    use crate::errors::RuntimeUnitError;
    #[doc = "Storage of primitives used to define a given unit."]
    #[repr(transparent)]
    pub struct UnitBase(u64);
    #[automatically_derived]
    impl ::core::marker::Copy for UnitBase { }
    #[automatically_derived]
    impl ::core::clone::Clone for UnitBase {
        #[inline]
        fn clone(&self) -> UnitBase {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UnitBase { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UnitBase {
        #[inline]
        fn eq(&self, other: &UnitBase) -> bool { self.0 == other.0 }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UnitBase {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UnitBase {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UnitBase {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    _serde::Serializer::serialize_newtype_struct(__serializer,
                        "UnitBase", &self.0)
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UnitBase {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UnitBase>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UnitBase;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "tuple struct UnitBase")
                        }
                        #[inline]
                        fn visit_newtype_struct<__E>(self, __e: __E)
                            -> _serde::__private::Result<Self::Value, __E::Error> where
                            __E: _serde::Deserializer<'de> {
                            let __field0: u64 =
                                <u64 as _serde::Deserialize>::deserialize(__e)?;
                            _serde::__private::Ok(UnitBase(__field0))
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                    &"tuple struct UnitBase with 1 element")),
                                };
                            _serde::__private::Ok(UnitBase(__field0))
                        }
                    }
                    _serde::Deserializer::deserialize_newtype_struct(__deserializer,
                        "UnitBase",
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UnitBase>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    impl UnitBase {
        #[doc = r" Creates a new default initialized bitfield."]
        pub const fn new() -> Self {
            let mut this = Self(0);
            this = this.with_meter(0);
            this = this.with_second(0);
            this = this.with_kilogram(0);
            this = this.with_ampere(0);
            this = this.with_candela(0);
            this = this.with_kelvin(0);
            this = this.with_mole(0);
            this.0 |= (0 as u64) << 56usize;
            this
        }
        #[doc = r" Convert from bits."]
        pub const fn from_bits(bits: u64) -> Self { Self(bits) }
        #[doc = r" Convert into bits."]
        pub const fn into_bits(self) -> u64 { self.0 }
        const METER_BITS: usize = 8usize;
        const METER_OFFSET: usize = 0usize;
        #[doc = "\n\nBits: 0..8"]
        const fn meter(&self) -> i8 {
            let mask = u64::MAX >> (u64::BITS - Self::METER_BITS as u32);
            let this = (self.0 >> Self::METER_OFFSET) & mask;
            { let shift = i8::BITS - 8u32; ((this as i8) << shift) >> shift }
        }
        #[doc = "\n\nBits: 0..8"]
        #[track_caller]
        const fn with_meter(self, value: i8) -> Self {
            let this = value;
            let value: u64 =
                {
                    if true {
                            if !{
                                            let m = i8::MIN >> (i8::BITS - 8u32);
                                            m <= this && this <= -(m + 1)
                                        } {
                                    ::core::panicking::panic("assertion failed: { let m = i8::MIN >> (i8::BITS - 8u32); m <= this && this <= -(m + 1) }")
                                };
                        };
                    let mask = u64::MAX >> (u64::BITS - 8u32);
                    (this as u64 & mask)
                };
            let mask = u64::MAX >> (u64::BITS - Self::METER_BITS as u32);
            if true {
                    if !(value <= mask) {
                            {
                                ::core::panicking::panic_fmt(format_args!("value out of bounds"));
                            }
                        };
                };
            Self(self.0 & !(mask << Self::METER_OFFSET) |
                    (value & mask) << Self::METER_OFFSET)
        }
        #[doc = "\n\nBits: 0..8"]
        #[track_caller]
        fn set_meter(&mut self, value: i8) { *self = self.with_meter(value); }
        const SECOND_BITS: usize = 8usize;
        const SECOND_OFFSET: usize = 8usize;
        #[doc = "\n\nBits: 8..16"]
        const fn second(&self) -> i8 {
            let mask = u64::MAX >> (u64::BITS - Self::SECOND_BITS as u32);
            let this = (self.0 >> Self::SECOND_OFFSET) & mask;
            { let shift = i8::BITS - 8u32; ((this as i8) << shift) >> shift }
        }
        #[doc = "\n\nBits: 8..16"]
        #[track_caller]
        const fn with_second(self, value: i8) -> Self {
            let this = value;
            let value: u64 =
                {
                    if true {
                            if !{
                                            let m = i8::MIN >> (i8::BITS - 8u32);
                                            m <= this && this <= -(m + 1)
                                        } {
                                    ::core::panicking::panic("assertion failed: { let m = i8::MIN >> (i8::BITS - 8u32); m <= this && this <= -(m + 1) }")
                                };
                        };
                    let mask = u64::MAX >> (u64::BITS - 8u32);
                    (this as u64 & mask)
                };
            let mask = u64::MAX >> (u64::BITS - Self::SECOND_BITS as u32);
            if true {
                    if !(value <= mask) {
                            {
                                ::core::panicking::panic_fmt(format_args!("value out of bounds"));
                            }
                        };
                };
            Self(self.0 & !(mask << Self::SECOND_OFFSET) |
                    (value & mask) << Self::SECOND_OFFSET)
        }
        #[doc = "\n\nBits: 8..16"]
        #[track_caller]
        fn set_second(&mut self, value: i8) {
            *self = self.with_second(value);
        }
        const KILOGRAM_BITS: usize = 8usize;
        const KILOGRAM_OFFSET: usize = 16usize;
        #[doc = "\n\nBits: 16..24"]
        const fn kilogram(&self) -> i8 {
            let mask = u64::MAX >> (u64::BITS - Self::KILOGRAM_BITS as u32);
            let this = (self.0 >> Self::KILOGRAM_OFFSET) & mask;
            { let shift = i8::BITS - 8u32; ((this as i8) << shift) >> shift }
        }
        #[doc = "\n\nBits: 16..24"]
        #[track_caller]
        const fn with_kilogram(self, value: i8) -> Self {
            let this = value;
            let value: u64 =
                {
                    if true {
                            if !{
                                            let m = i8::MIN >> (i8::BITS - 8u32);
                                            m <= this && this <= -(m + 1)
                                        } {
                                    ::core::panicking::panic("assertion failed: { let m = i8::MIN >> (i8::BITS - 8u32); m <= this && this <= -(m + 1) }")
                                };
                        };
                    let mask = u64::MAX >> (u64::BITS - 8u32);
                    (this as u64 & mask)
                };
            let mask = u64::MAX >> (u64::BITS - Self::KILOGRAM_BITS as u32);
            if true {
                    if !(value <= mask) {
                            {
                                ::core::panicking::panic_fmt(format_args!("value out of bounds"));
                            }
                        };
                };
            Self(self.0 & !(mask << Self::KILOGRAM_OFFSET) |
                    (value & mask) << Self::KILOGRAM_OFFSET)
        }
        #[doc = "\n\nBits: 16..24"]
        #[track_caller]
        fn set_kilogram(&mut self, value: i8) {
            *self = self.with_kilogram(value);
        }
        const AMPERE_BITS: usize = 8usize;
        const AMPERE_OFFSET: usize = 24usize;
        #[doc = "\n\nBits: 24..32"]
        const fn ampere(&self) -> i8 {
            let mask = u64::MAX >> (u64::BITS - Self::AMPERE_BITS as u32);
            let this = (self.0 >> Self::AMPERE_OFFSET) & mask;
            { let shift = i8::BITS - 8u32; ((this as i8) << shift) >> shift }
        }
        #[doc = "\n\nBits: 24..32"]
        #[track_caller]
        const fn with_ampere(self, value: i8) -> Self {
            let this = value;
            let value: u64 =
                {
                    if true {
                            if !{
                                            let m = i8::MIN >> (i8::BITS - 8u32);
                                            m <= this && this <= -(m + 1)
                                        } {
                                    ::core::panicking::panic("assertion failed: { let m = i8::MIN >> (i8::BITS - 8u32); m <= this && this <= -(m + 1) }")
                                };
                        };
                    let mask = u64::MAX >> (u64::BITS - 8u32);
                    (this as u64 & mask)
                };
            let mask = u64::MAX >> (u64::BITS - Self::AMPERE_BITS as u32);
            if true {
                    if !(value <= mask) {
                            {
                                ::core::panicking::panic_fmt(format_args!("value out of bounds"));
                            }
                        };
                };
            Self(self.0 & !(mask << Self::AMPERE_OFFSET) |
                    (value & mask) << Self::AMPERE_OFFSET)
        }
        #[doc = "\n\nBits: 24..32"]
        #[track_caller]
        fn set_ampere(&mut self, value: i8) {
            *self = self.with_ampere(value);
        }
        const CANDELA_BITS: usize = 8usize;
        const CANDELA_OFFSET: usize = 32usize;
        #[doc = "\n\nBits: 32..40"]
        const fn candela(&self) -> i8 {
            let mask = u64::MAX >> (u64::BITS - Self::CANDELA_BITS as u32);
            let this = (self.0 >> Self::CANDELA_OFFSET) & mask;
            { let shift = i8::BITS - 8u32; ((this as i8) << shift) >> shift }
        }
        #[doc = "\n\nBits: 32..40"]
        #[track_caller]
        const fn with_candela(self, value: i8) -> Self {
            let this = value;
            let value: u64 =
                {
                    if true {
                            if !{
                                            let m = i8::MIN >> (i8::BITS - 8u32);
                                            m <= this && this <= -(m + 1)
                                        } {
                                    ::core::panicking::panic("assertion failed: { let m = i8::MIN >> (i8::BITS - 8u32); m <= this && this <= -(m + 1) }")
                                };
                        };
                    let mask = u64::MAX >> (u64::BITS - 8u32);
                    (this as u64 & mask)
                };
            let mask = u64::MAX >> (u64::BITS - Self::CANDELA_BITS as u32);
            if true {
                    if !(value <= mask) {
                            {
                                ::core::panicking::panic_fmt(format_args!("value out of bounds"));
                            }
                        };
                };
            Self(self.0 & !(mask << Self::CANDELA_OFFSET) |
                    (value & mask) << Self::CANDELA_OFFSET)
        }
        #[doc = "\n\nBits: 32..40"]
        #[track_caller]
        fn set_candela(&mut self, value: i8) {
            *self = self.with_candela(value);
        }
        const KELVIN_BITS: usize = 8usize;
        const KELVIN_OFFSET: usize = 40usize;
        #[doc = "\n\nBits: 40..48"]
        const fn kelvin(&self) -> i8 {
            let mask = u64::MAX >> (u64::BITS - Self::KELVIN_BITS as u32);
            let this = (self.0 >> Self::KELVIN_OFFSET) & mask;
            { let shift = i8::BITS - 8u32; ((this as i8) << shift) >> shift }
        }
        #[doc = "\n\nBits: 40..48"]
        #[track_caller]
        const fn with_kelvin(self, value: i8) -> Self {
            let this = value;
            let value: u64 =
                {
                    if true {
                            if !{
                                            let m = i8::MIN >> (i8::BITS - 8u32);
                                            m <= this && this <= -(m + 1)
                                        } {
                                    ::core::panicking::panic("assertion failed: { let m = i8::MIN >> (i8::BITS - 8u32); m <= this && this <= -(m + 1) }")
                                };
                        };
                    let mask = u64::MAX >> (u64::BITS - 8u32);
                    (this as u64 & mask)
                };
            let mask = u64::MAX >> (u64::BITS - Self::KELVIN_BITS as u32);
            if true {
                    if !(value <= mask) {
                            {
                                ::core::panicking::panic_fmt(format_args!("value out of bounds"));
                            }
                        };
                };
            Self(self.0 & !(mask << Self::KELVIN_OFFSET) |
                    (value & mask) << Self::KELVIN_OFFSET)
        }
        #[doc = "\n\nBits: 40..48"]
        #[track_caller]
        fn set_kelvin(&mut self, value: i8) {
            *self = self.with_kelvin(value);
        }
        const MOLE_BITS: usize = 8usize;
        const MOLE_OFFSET: usize = 48usize;
        #[doc = "\n\nBits: 48..56"]
        const fn mole(&self) -> i8 {
            let mask = u64::MAX >> (u64::BITS - Self::MOLE_BITS as u32);
            let this = (self.0 >> Self::MOLE_OFFSET) & mask;
            { let shift = i8::BITS - 8u32; ((this as i8) << shift) >> shift }
        }
        #[doc = "\n\nBits: 48..56"]
        #[track_caller]
        const fn with_mole(self, value: i8) -> Self {
            let this = value;
            let value: u64 =
                {
                    if true {
                            if !{
                                            let m = i8::MIN >> (i8::BITS - 8u32);
                                            m <= this && this <= -(m + 1)
                                        } {
                                    ::core::panicking::panic("assertion failed: { let m = i8::MIN >> (i8::BITS - 8u32); m <= this && this <= -(m + 1) }")
                                };
                        };
                    let mask = u64::MAX >> (u64::BITS - 8u32);
                    (this as u64 & mask)
                };
            let mask = u64::MAX >> (u64::BITS - Self::MOLE_BITS as u32);
            if true {
                    if !(value <= mask) {
                            {
                                ::core::panicking::panic_fmt(format_args!("value out of bounds"));
                            }
                        };
                };
            Self(self.0 & !(mask << Self::MOLE_OFFSET) |
                    (value & mask) << Self::MOLE_OFFSET)
        }
        #[doc = "\n\nBits: 48..56"]
        #[track_caller]
        fn set_mole(&mut self, value: i8) { *self = self.with_mole(value); }
    }
    impl Default for UnitBase {
        fn default() -> Self { Self::new() }
    }
    impl From<u64> for UnitBase {
        fn from(v: u64) -> Self { Self(v) }
    }
    impl From<UnitBase> for u64 {
        fn from(v: UnitBase) -> u64 { v.0 }
    }
    impl core::fmt::Debug for UnitBase {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_struct("UnitBase").field("meter",
                                            &self.meter()).field("second",
                                        &self.second()).field("kilogram",
                                    &self.kilogram()).field("ampere",
                                &self.ampere()).field("candela",
                            &self.candela()).field("kelvin",
                        &self.kelvin()).field("mole", &self.mole()).finish()
        }
    }
    impl UnitBase {
        /// A method to get the power of a given unit component.    
        fn get_element(&self, index: u8) -> i8 {
            match index {
                0 => self.meter(),
                1 => self.second(),
                2 => self.kilogram(),
                3 => self.ampere(),
                4 => self.candela(),
                5 => self.kelvin(),
                6 => self.mole(),
                _ => {
                    ::core::panicking::panic_fmt(format_args!("Unsupported index {0} provided to get_element",
                            index));
                }
            }
        }
        /// Get unit name for a given index from the `get_element` method.
        fn unit_name(&self, index: u8) -> &'static str {
            match index {
                0 => "m",
                1 => "s",
                2 => "kg",
                3 => "A",
                4 => "cd",
                5 => "K",
                6 => "mol",
                _ => {
                    ::core::panicking::panic_fmt(format_args!("Unsupported index {0} provided to get_element",
                            index));
                }
            }
        }
    }
    impl Display for UnitBase {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let numerator =
                (0..7).map(|i|
                                    {
                                        let value = self.get_element(i as u8);
                                        if value.is_positive() {
                                                if value > 1 {
                                                        ::alloc::__export::must_use({
                                                                    let res =
                                                                        ::alloc::fmt::format(format_args!("{0}^{1}",
                                                                                self.unit_name(i as u8), value));
                                                                    res
                                                                }).to_owned()
                                                    } else {
                                                       ::alloc::__export::must_use({
                                                                   let res =
                                                                       ::alloc::fmt::format(format_args!("{0}",
                                                                               self.unit_name(i as u8)));
                                                                   res
                                                               }).to_owned()
                                                   }
                                            } else { "".to_owned() }
                                    }).filter(|x|
                                !x.is_empty()).collect::<Vec<String>>().join("*");
            let denominator =
                (0..7).map(|i|
                                    {
                                        let value = self.get_element(i as u8);
                                        if value.is_negative() {
                                                if value < -1 {
                                                        ::alloc::__export::must_use({
                                                                    let res =
                                                                        ::alloc::fmt::format(format_args!("{0}^{1}",
                                                                                self.unit_name(i as u8), -value));
                                                                    res
                                                                }).to_owned()
                                                    } else {
                                                       ::alloc::__export::must_use({
                                                                   let res =
                                                                       ::alloc::fmt::format(format_args!("{0}",
                                                                               self.unit_name(i as u8)));
                                                                   res
                                                               }).to_owned()
                                                   }
                                            } else { "".to_owned() }
                                    }).filter(|x|
                                !x.is_empty()).collect::<Vec<String>>().join("*");
            let result =
                if numerator.is_empty() {
                        if denominator.is_empty() {
                                "dimensionless".to_owned()
                            } else {
                               ::alloc::__export::must_use({
                                       let res =
                                           ::alloc::fmt::format(format_args!("1/{0}", denominator));
                                       res
                                   })
                           }
                    } else {
                       if denominator.is_empty() {
                               numerator
                           } else {
                              if denominator.contains("*") {
                                      ::alloc::__export::must_use({
                                              let res =
                                                  ::alloc::fmt::format(format_args!("{0}/({1})", numerator,
                                                          denominator));
                                              res
                                          })
                                  } else {
                                     ::alloc::__export::must_use({
                                             let res =
                                                 ::alloc::fmt::format(format_args!("{0}/{1}", numerator,
                                                         denominator));
                                             res
                                         })
                                 }
                          }
                   };
            f.write_fmt(format_args!("{0}", result))
        }
    }
    impl Mul for UnitBase {
        type Output = UnitBase;
        fn mul(self, rhs: Self) -> Self::Output {
            UnitBase::new().with_meter(self.meter() +
                                            rhs.meter()).with_second(self.second() +
                                        rhs.second()).with_kilogram(self.kilogram() +
                                    rhs.kilogram()).with_ampere(self.ampere() +
                                rhs.ampere()).with_candela(self.candela() +
                            rhs.candela()).with_kelvin(self.kelvin() +
                        rhs.kelvin()).with_mole(self.mole() + rhs.mole())
        }
    }
    impl MulAssign for UnitBase {
        fn mul_assign(&mut self, rhs: Self) {
            self.set_meter(self.meter() + rhs.meter());
            self.set_second(self.second() + rhs.second());
            self.set_kilogram(self.kilogram() + rhs.kilogram());
            self.set_ampere(self.ampere() + rhs.ampere());
            self.set_candela(self.candela() + rhs.candela());
            self.set_kelvin(self.kelvin() + rhs.kelvin());
            self.set_mole(self.mole() + rhs.mole());
        }
    }
    impl Div for UnitBase {
        type Output = UnitBase;
        fn div(self, rhs: Self) -> Self::Output {
            UnitBase::new().with_meter(self.meter() -
                                            rhs.meter()).with_second(self.second() -
                                        rhs.second()).with_kilogram(self.kilogram() -
                                    rhs.kilogram()).with_ampere(self.ampere() -
                                rhs.ampere()).with_candela(self.candela() -
                            rhs.candela()).with_kelvin(self.kelvin() -
                        rhs.kelvin()).with_mole(self.mole() - rhs.mole())
        }
    }
    impl DivAssign for UnitBase {
        fn div_assign(&mut self, rhs: Self) {
            self.set_meter(self.meter() - rhs.meter());
            self.set_second(self.second() - rhs.second());
            self.set_kilogram(self.kilogram() - rhs.kilogram());
            self.set_ampere(self.ampere() - rhs.ampere());
            self.set_candela(self.candela() - rhs.candela());
            self.set_kelvin(self.kelvin() - rhs.kelvin());
            self.set_mole(self.mole() - rhs.mole());
        }
    }
    impl UnitBase {
        #[allow(unused)]
        pub(crate) const fn new_length() -> Self {
            UnitBase::new().with_meter(1)
        }
        #[allow(unused)]
        pub(crate) const fn new_mass() -> Self {
            UnitBase::new().with_kilogram(1)
        }
        #[allow(unused)]
        pub(crate) const fn new_time() -> Self {
            UnitBase::new().with_second(1)
        }
        #[allow(unused)]
        pub(crate) const fn new_current() -> Self {
            UnitBase::new().with_ampere(1)
        }
        #[allow(unused)]
        pub(crate) const fn new_temperature() -> Self {
            UnitBase::new().with_kelvin(1)
        }
        #[allow(unused)]
        pub(crate) const fn new_luminance() -> Self {
            UnitBase::new().with_candela(1)
        }
        #[allow(unused)]
        pub(crate) const fn dimensionless() -> Self { UnitBase::new() }
        pub(crate) fn powi(&self, power: i8) -> Self {
            UnitBase::new().with_meter(self.meter() *
                                            power).with_second(self.second() *
                                        power).with_kilogram(self.kilogram() *
                                    power).with_ampere(self.ampere() *
                                power).with_candela(self.candela() *
                            power).with_kelvin(self.kelvin() *
                        power).with_mole(self.mole() * power)
        }
    }
    /// Storage for a single unit and its multiplier to convert it to the base unit.
    pub struct UnitDefinition {
        pub(crate) base: UnitBase,
        pub(crate) multiplier: f64,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UnitDefinition {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    let mut __serde_state =
                        _serde::Serializer::serialize_struct(__serializer,
                                "UnitDefinition", false as usize + 1 + 1)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "base", &self.base)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "multiplier", &self.multiplier)?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UnitDefinition {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field { __field0, __field1, __ignore, }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "base" => _serde::__private::Ok(__Field::__field0),
                                "multiplier" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"base" => _serde::__private::Ok(__Field::__field0),
                                b"multiplier" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UnitDefinition>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UnitDefinition;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "struct UnitDefinition")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<UnitBase>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                    &"struct UnitDefinition with 2 elements")),
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                    &"struct UnitDefinition with 2 elements")),
                                };
                            _serde::__private::Ok(UnitDefinition {
                                    base: __field0,
                                    multiplier: __field1,
                                })
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::MapAccess<'de> {
                            let mut __field0: _serde::__private::Option<UnitBase> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f64> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                    _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("base"));
                                            }
                                        __field0 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<UnitBase>(&mut __map)?);
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("multiplier"));
                                            }
                                        __field1 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                    }
                                    _ => {
                                        let _ =
                                            _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("base")?,
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("multiplier")?,
                                };
                            _serde::__private::Ok(UnitDefinition {
                                    base: __field0,
                                    multiplier: __field1,
                                })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["base", "multiplier"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                        "UnitDefinition", FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UnitDefinition>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UnitDefinition { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UnitDefinition {
        #[inline]
        fn eq(&self, other: &UnitDefinition) -> bool {
            self.base == other.base && self.multiplier == other.multiplier
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UnitDefinition {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "UnitDefinition", "base", &self.base, "multiplier",
                &&self.multiplier)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UnitDefinition {
        #[inline]
        fn clone(&self) -> UnitDefinition {
            let _: ::core::clone::AssertParamIsClone<UnitBase>;
            let _: ::core::clone::AssertParamIsClone<f64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for UnitDefinition { }
    impl Eq for UnitDefinition {}
    impl UnitDefinition {
        #[doc =
        "Create a new `UnitDefinition` manually by specifying powers of each base unit, as well as the multiplier."]
        pub fn new(multiplier: f64, meter: i8, kilogram: i8, second: i8,
            ampere: i8, kelvin: i8, mole: i8, candela: i8) -> Self {
            UnitDefinition {
                base: UnitBase::new().with_meter(meter).with_kilogram(kilogram).with_second(second).with_ampere(ampere).with_kelvin(kelvin).with_mole(mole).with_candela(candela),
                multiplier,
            }
        }
        #[doc = "Returns a dimensionless `UnitDefinition`."]
        pub fn dimensionless() -> Self {
            UnitDefinition { base: UnitBase::default(), multiplier: 1.0 }
        }
        #[doc =
        "Check whether this unit can be converted to a a given `unit`."]
        pub fn is_convertible(&self, unit: UnitDefinition) -> bool {
            self.base == unit.base
        }
        #[doc = "Raise a unit to an integer power."]
        pub fn powi(&self, power: i8) -> UnitDefinition {
            UnitDefinition {
                base: self.base.powi(power),
                multiplier: self.multiplier.powi(power as i32),
            }
        }
        #[doc =
        "Retrieve multiplier that converts this unit to its base quantity."]
        pub fn multiplier(&self) -> f64 { self.multiplier }
        #[doc = "Get the string representation of the base unit."]
        pub fn unit_string(&self) -> String { self.base.to_string() }
        #[doc =
        "Approximate equality for two units, given some relative error `rel_error`"]
        pub fn approx_eq(&self, other: UnitDefinition, rel_error: f64)
            -> bool {
            other.base == self.base &&
                if self.multiplier == 0.0 {
                            (self.multiplier - other.multiplier).abs()
                        } else { (1.0 - other.multiplier / self.multiplier).abs() }
                    <= rel_error
        }
        #[doc =
        "Compute the conversion factor required to convert current `UnitDefinition` to another"]
        pub fn try_convert(&self, unit: Self)
            -> Result<f64, RuntimeUnitError> {
            if unit.base == self.base {
                    Ok(self.convert_unchecked(unit))
                } else {
                   Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                   let res =
                                       ::alloc::fmt::format(format_args!("Could not convert from base units of {0} to {1}",
                                               self.unit_string(), unit.unit_string()));
                                   res
                               })))
               }
        }
        #[doc =
        "Compute the conversion factor required to convert current `UnitDefinition` to another"]
        pub fn convert_unchecked(&self, unit: Self) -> f64 {
            if *self == unit {
                    1.0
                } else { self.multiplier / unit.multiplier() }
        }
    }
    impl Mul<UnitDefinition> for UnitDefinition {
        type Output = UnitDefinition;
        fn mul(self, rhs: UnitDefinition) -> Self::Output {
            UnitDefinition {
                multiplier: self.multiplier * rhs.multiplier,
                base: self.base * rhs.base,
            }
        }
    }
    impl Div<UnitDefinition> for UnitDefinition {
        type Output = UnitDefinition;
        fn div(self, rhs: UnitDefinition) -> Self::Output {
            UnitDefinition {
                multiplier: self.multiplier / rhs.multiplier,
                base: self.base / rhs.base,
            }
        }
    }
    impl DivAssign for UnitDefinition {
        fn div_assign(&mut self, rhs: UnitDefinition) {
            self.multiplier /= rhs.multiplier;
            self.base /= rhs.base;
        }
    }
    impl MulAssign for UnitDefinition {
        fn mul_assign(&mut self, rhs: Self) {
            self.multiplier *= rhs.multiplier;
            self.base *= rhs.base
        }
    }
    ///
    /// Internal datatype to map UOM dimensions to runtime units. 
    ///
    #[repr(i8)]
    #[allow(unused)]
    pub(crate) enum UOMDimensions {
        N5 = -5,
        N4 = -4,
        N3 = -3,
        N2 = -2,
        N1 = -1,
        Z0 = 0,
        P1 = 1,
        P2 = 2,
        P3 = 3,
        P4 = 4,
        P5 = 5,
    }
    #[automatically_derived]
    #[allow(unused)]
    impl ::core::marker::Copy for UOMDimensions { }
    #[automatically_derived]
    #[allow(unused)]
    impl ::core::clone::Clone for UOMDimensions {
        #[inline]
        fn clone(&self) -> UOMDimensions { *self }
    }
    impl UOMDimensions {
        #[inline(always)]
        pub(crate) const fn to_unit_base(value:
                (UOMDimensions, UOMDimensions, UOMDimensions, UOMDimensions,
                UOMDimensions, UOMDimensions, UOMDimensions)) -> UnitBase {
            UnitBase::new().with_meter(value.0 as
                                            i8).with_kilogram(value.1 as
                                        i8).with_second(value.2 as
                                    i8).with_ampere(value.3 as
                                i8).with_kelvin(value.4 as
                            i8).with_mole(value.5 as i8).with_candela(value.6 as i8)
        }
    }
}
mod unit_definitions {
    use crate::system;
    use crate::units_base::UnitDefinition;
    use crate::errors::RuntimeUnitError;
    use crate::Quantity;
    use crate::units::*;
    #[cfg(feature = "utoipa")]
    use utoipa::{ToSchema, schema};
    use paste::paste;
    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
    mod amount_of_substance {
        //! Amount of substance (base UnitDefinition mole, mol).
        use crate::{prefix, quantity};
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Amount of substance (base UnitDefinition mole, mol)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "AmountOfSubstanceUnit")]
        pub enum AmountOfSubstanceUnit {
            yottamole,
            zettamole,
            examole,
            petamole,
            teramole,
            gigamole,
            megamole,
            kilomole,
            hectomole,
            decamole,
            mole,
            decimole,
            centimole,
            millimole,
            micromole,
            nanomole,
            picomole,
            femtomole,
            attomole,
            zeptomole,
            yoctomole,
            particle,
            standard_cubic_meter,
            standard_liter,
            standard_centimeter,
            standard_cubic_foot,
        }
        impl utoipa::__dev::ComposeSchema for AmountOfSubstanceUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 26usize],
                                &str>(Some(["yottamole", "zettamole", "examole", "petamole",
                                            "teramole", "gigamole", "megamole", "kilomole", "hectomole",
                                            "decamole", "mole", "decimole", "centimole", "millimole",
                                            "micromole", "nanomole", "picomole", "femtomole",
                                            "attomole", "zeptomole", "yoctomole", "particle",
                                            "standard_cubic_meter", "standard_liter",
                                            "standard_centimeter",
                                            "standard_cubic_foot"])).title(Some("AmountOfSubstanceUnit")).description(Some("Amount of substance (base UnitDefinition mole, mol).")).into()
            }
        }
        impl utoipa::ToSchema for AmountOfSubstanceUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("AmountOfSubstanceUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AmountOfSubstanceUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            AmountOfSubstanceUnit::yottamole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 0u32, "yottamole"),
                            AmountOfSubstanceUnit::zettamole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 1u32, "zettamole"),
                            AmountOfSubstanceUnit::examole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 2u32, "examole"),
                            AmountOfSubstanceUnit::petamole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 3u32, "petamole"),
                            AmountOfSubstanceUnit::teramole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 4u32, "teramole"),
                            AmountOfSubstanceUnit::gigamole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 5u32, "gigamole"),
                            AmountOfSubstanceUnit::megamole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 6u32, "megamole"),
                            AmountOfSubstanceUnit::kilomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 7u32, "kilomole"),
                            AmountOfSubstanceUnit::hectomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 8u32, "hectomole"),
                            AmountOfSubstanceUnit::decamole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 9u32, "decamole"),
                            AmountOfSubstanceUnit::mole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 10u32, "mole"),
                            AmountOfSubstanceUnit::decimole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 11u32, "decimole"),
                            AmountOfSubstanceUnit::centimole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 12u32, "centimole"),
                            AmountOfSubstanceUnit::millimole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 13u32, "millimole"),
                            AmountOfSubstanceUnit::micromole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 14u32, "micromole"),
                            AmountOfSubstanceUnit::nanomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 15u32, "nanomole"),
                            AmountOfSubstanceUnit::picomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 16u32, "picomole"),
                            AmountOfSubstanceUnit::femtomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 17u32, "femtomole"),
                            AmountOfSubstanceUnit::attomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 18u32, "attomole"),
                            AmountOfSubstanceUnit::zeptomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 19u32, "zeptomole"),
                            AmountOfSubstanceUnit::yoctomole =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 20u32, "yoctomole"),
                            AmountOfSubstanceUnit::particle =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 21u32, "particle"),
                            AmountOfSubstanceUnit::standard_cubic_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 22u32, "standard_cubic_meter"),
                            AmountOfSubstanceUnit::standard_liter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 23u32, "standard_liter"),
                            AmountOfSubstanceUnit::standard_centimeter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 24u32, "standard_centimeter"),
                            AmountOfSubstanceUnit::standard_cubic_foot =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AmountOfSubstanceUnit", 25u32, "standard_cubic_foot"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for AmountOfSubstanceUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                            __field24,
                            __field25,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    17u64 => _serde::__private::Ok(__Field::__field17),
                                    18u64 => _serde::__private::Ok(__Field::__field18),
                                    19u64 => _serde::__private::Ok(__Field::__field19),
                                    20u64 => _serde::__private::Ok(__Field::__field20),
                                    21u64 => _serde::__private::Ok(__Field::__field21),
                                    22u64 => _serde::__private::Ok(__Field::__field22),
                                    23u64 => _serde::__private::Ok(__Field::__field23),
                                    24u64 => _serde::__private::Ok(__Field::__field24),
                                    25u64 => _serde::__private::Ok(__Field::__field25),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 26")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "yottamole" => _serde::__private::Ok(__Field::__field0),
                                    "zettamole" => _serde::__private::Ok(__Field::__field1),
                                    "examole" => _serde::__private::Ok(__Field::__field2),
                                    "petamole" => _serde::__private::Ok(__Field::__field3),
                                    "teramole" => _serde::__private::Ok(__Field::__field4),
                                    "gigamole" => _serde::__private::Ok(__Field::__field5),
                                    "megamole" => _serde::__private::Ok(__Field::__field6),
                                    "kilomole" => _serde::__private::Ok(__Field::__field7),
                                    "hectomole" => _serde::__private::Ok(__Field::__field8),
                                    "decamole" => _serde::__private::Ok(__Field::__field9),
                                    "mole" => _serde::__private::Ok(__Field::__field10),
                                    "decimole" => _serde::__private::Ok(__Field::__field11),
                                    "centimole" => _serde::__private::Ok(__Field::__field12),
                                    "millimole" => _serde::__private::Ok(__Field::__field13),
                                    "micromole" => _serde::__private::Ok(__Field::__field14),
                                    "nanomole" => _serde::__private::Ok(__Field::__field15),
                                    "picomole" => _serde::__private::Ok(__Field::__field16),
                                    "femtomole" => _serde::__private::Ok(__Field::__field17),
                                    "attomole" => _serde::__private::Ok(__Field::__field18),
                                    "zeptomole" => _serde::__private::Ok(__Field::__field19),
                                    "yoctomole" => _serde::__private::Ok(__Field::__field20),
                                    "particle" => _serde::__private::Ok(__Field::__field21),
                                    "standard_cubic_meter" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    "standard_liter" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    "standard_centimeter" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    "standard_cubic_foot" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"yottamole" => _serde::__private::Ok(__Field::__field0),
                                    b"zettamole" => _serde::__private::Ok(__Field::__field1),
                                    b"examole" => _serde::__private::Ok(__Field::__field2),
                                    b"petamole" => _serde::__private::Ok(__Field::__field3),
                                    b"teramole" => _serde::__private::Ok(__Field::__field4),
                                    b"gigamole" => _serde::__private::Ok(__Field::__field5),
                                    b"megamole" => _serde::__private::Ok(__Field::__field6),
                                    b"kilomole" => _serde::__private::Ok(__Field::__field7),
                                    b"hectomole" => _serde::__private::Ok(__Field::__field8),
                                    b"decamole" => _serde::__private::Ok(__Field::__field9),
                                    b"mole" => _serde::__private::Ok(__Field::__field10),
                                    b"decimole" => _serde::__private::Ok(__Field::__field11),
                                    b"centimole" => _serde::__private::Ok(__Field::__field12),
                                    b"millimole" => _serde::__private::Ok(__Field::__field13),
                                    b"micromole" => _serde::__private::Ok(__Field::__field14),
                                    b"nanomole" => _serde::__private::Ok(__Field::__field15),
                                    b"picomole" => _serde::__private::Ok(__Field::__field16),
                                    b"femtomole" => _serde::__private::Ok(__Field::__field17),
                                    b"attomole" => _serde::__private::Ok(__Field::__field18),
                                    b"zeptomole" => _serde::__private::Ok(__Field::__field19),
                                    b"yoctomole" => _serde::__private::Ok(__Field::__field20),
                                    b"particle" => _serde::__private::Ok(__Field::__field21),
                                    b"standard_cubic_meter" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    b"standard_liter" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    b"standard_centimeter" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    b"standard_cubic_foot" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<AmountOfSubstanceUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = AmountOfSubstanceUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum AmountOfSubstanceUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::yottamole)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::zettamole)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::examole)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::petamole)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::teramole)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::gigamole)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::megamole)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::kilomole)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::hectomole)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::decamole)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::mole)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::decimole)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::centimole)
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::millimole)
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::micromole)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::nanomole)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::picomole)
                                    }
                                    (__Field::__field17, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::femtomole)
                                    }
                                    (__Field::__field18, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::attomole)
                                    }
                                    (__Field::__field19, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::zeptomole)
                                    }
                                    (__Field::__field20, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::yoctomole)
                                    }
                                    (__Field::__field21, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::particle)
                                    }
                                    (__Field::__field22, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::standard_cubic_meter)
                                    }
                                    (__Field::__field23, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::standard_liter)
                                    }
                                    (__Field::__field24, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::standard_centimeter)
                                    }
                                    (__Field::__field25, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AmountOfSubstanceUnit::standard_cubic_foot)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["yottamole", "zettamole", "examole", "petamole",
                                        "teramole", "gigamole", "megamole", "kilomole", "hectomole",
                                        "decamole", "mole", "decimole", "centimole", "millimole",
                                        "micromole", "nanomole", "picomole", "femtomole",
                                        "attomole", "zeptomole", "yoctomole", "particle",
                                        "standard_cubic_meter", "standard_liter",
                                        "standard_centimeter", "standard_cubic_foot"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "AmountOfSubstanceUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<AmountOfSubstanceUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for AmountOfSubstanceUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for AmountOfSubstanceUnit {
            #[inline]
            fn clone(&self) -> AmountOfSubstanceUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for AmountOfSubstanceUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        AmountOfSubstanceUnit::yottamole => "yottamole",
                        AmountOfSubstanceUnit::zettamole => "zettamole",
                        AmountOfSubstanceUnit::examole => "examole",
                        AmountOfSubstanceUnit::petamole => "petamole",
                        AmountOfSubstanceUnit::teramole => "teramole",
                        AmountOfSubstanceUnit::gigamole => "gigamole",
                        AmountOfSubstanceUnit::megamole => "megamole",
                        AmountOfSubstanceUnit::kilomole => "kilomole",
                        AmountOfSubstanceUnit::hectomole => "hectomole",
                        AmountOfSubstanceUnit::decamole => "decamole",
                        AmountOfSubstanceUnit::mole => "mole",
                        AmountOfSubstanceUnit::decimole => "decimole",
                        AmountOfSubstanceUnit::centimole => "centimole",
                        AmountOfSubstanceUnit::millimole => "millimole",
                        AmountOfSubstanceUnit::micromole => "micromole",
                        AmountOfSubstanceUnit::nanomole => "nanomole",
                        AmountOfSubstanceUnit::picomole => "picomole",
                        AmountOfSubstanceUnit::femtomole => "femtomole",
                        AmountOfSubstanceUnit::attomole => "attomole",
                        AmountOfSubstanceUnit::zeptomole => "zeptomole",
                        AmountOfSubstanceUnit::yoctomole => "yoctomole",
                        AmountOfSubstanceUnit::particle => "particle",
                        AmountOfSubstanceUnit::standard_cubic_meter =>
                            "standard_cubic_meter",
                        AmountOfSubstanceUnit::standard_liter => "standard_liter",
                        AmountOfSubstanceUnit::standard_centimeter =>
                            "standard_centimeter",
                        AmountOfSubstanceUnit::standard_cubic_foot =>
                            "standard_cubic_foot",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for AmountOfSubstanceUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for AmountOfSubstanceUnit {
            #[inline]
            fn eq(&self, other: &AmountOfSubstanceUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for AmountOfSubstanceUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for AmountOfSubstanceUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const AMOUNTOFSUBSTANCE_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::P1,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const AMOUNTOFSUBSTANCE_YOTTAMOLE_CONVERSION: f64 =
            1.0_E24;
        pub(crate) const AMOUNTOFSUBSTANCE_ZETTAMOLE_CONVERSION: f64 =
            1.0_E21;
        pub(crate) const AMOUNTOFSUBSTANCE_EXAMOLE_CONVERSION: f64 = 1.0_E18;
        pub(crate) const AMOUNTOFSUBSTANCE_PETAMOLE_CONVERSION: f64 = 1.0_E15;
        pub(crate) const AMOUNTOFSUBSTANCE_TERAMOLE_CONVERSION: f64 = 1.0_E12;
        pub(crate) const AMOUNTOFSUBSTANCE_GIGAMOLE_CONVERSION: f64 = 1.0_E9;
        pub(crate) const AMOUNTOFSUBSTANCE_MEGAMOLE_CONVERSION: f64 = 1.0_E6;
        pub(crate) const AMOUNTOFSUBSTANCE_KILOMOLE_CONVERSION: f64 = 1.0_E3;
        pub(crate) const AMOUNTOFSUBSTANCE_HECTOMOLE_CONVERSION: f64 = 1.0_E2;
        pub(crate) const AMOUNTOFSUBSTANCE_DECAMOLE_CONVERSION: f64 = 1.0_E1;
        pub(crate) const AMOUNTOFSUBSTANCE_MOLE_CONVERSION: f64 = 1.0_E0;
        pub(crate) const AMOUNTOFSUBSTANCE_DECIMOLE_CONVERSION: f64 = 1.0_E-1;
        pub(crate) const AMOUNTOFSUBSTANCE_CENTIMOLE_CONVERSION: f64 =
            1.0_E-2;
        pub(crate) const AMOUNTOFSUBSTANCE_MILLIMOLE_CONVERSION: f64 =
            1.0_E-3;
        pub(crate) const AMOUNTOFSUBSTANCE_MICROMOLE_CONVERSION: f64 =
            1.0_E-6;
        pub(crate) const AMOUNTOFSUBSTANCE_NANOMOLE_CONVERSION: f64 = 1.0_E-9;
        pub(crate) const AMOUNTOFSUBSTANCE_PICOMOLE_CONVERSION: f64 =
            1.0_E-12;
        pub(crate) const AMOUNTOFSUBSTANCE_FEMTOMOLE_CONVERSION: f64 =
            1.0_E-15;
        pub(crate) const AMOUNTOFSUBSTANCE_ATTOMOLE_CONVERSION: f64 =
            1.0_E-18;
        pub(crate) const AMOUNTOFSUBSTANCE_ZEPTOMOLE_CONVERSION: f64 =
            1.0_E-21;
        pub(crate) const AMOUNTOFSUBSTANCE_YOCTOMOLE_CONVERSION: f64 =
            1.0_E-24;
        pub(crate) const AMOUNTOFSUBSTANCE_PARTICLE_CONVERSION: f64 =
            1.0_E0 / 6.022_140_76_E23;
        pub(crate) const AMOUNTOFSUBSTANCE_STANDARD_CUBIC_METER_CONVERSION:
            f64 =
            1_E5 * 1.0_E0 / 8.314_462_618 / 273.15;
        pub(crate) const AMOUNTOFSUBSTANCE_STANDARD_LITER_CONVERSION: f64 =
            1_E5 * 1.0_E-3 / 8.314_462_618 / 273.15;
        pub(crate) const AMOUNTOFSUBSTANCE_STANDARD_CENTIMETER_CONVERSION: f64
            =
            1_E5 * 1.0_E-6 / 8.314_462_618 / 273.15;
        pub(crate) const AMOUNTOFSUBSTANCE_STANDARD_CUBIC_FOOT_CONVERSION: f64
            =
            1_E5 * 2.831_685_E-2 / 8.314_462_618 / 273.15;
        impl AmountOfSubstanceUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_yottamole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_YOTTAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zettamole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_ZETTAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_examole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_EXAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_petamole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_PETAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_teramole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_TERAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gigamole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_GIGAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_megamole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_MEGAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kilomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_KILOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hectomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_HECTOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decamole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_DECAMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_mole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_MOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decimole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_DECIMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_centimole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_CENTIMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_millimole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_MILLIMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_micromole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_MICROMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nanomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_NANOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_picomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_PICOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_femtomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_FEMTOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_attomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_ATTOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zeptomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_ZEPTOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yoctomole() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_YOCTOMOLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_particle() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_PARTICLE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_standard_cubic_meter() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_STANDARD_CUBIC_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_standard_liter() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_STANDARD_LITER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_standard_centimeter() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_STANDARD_CENTIMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_standard_cubic_foot() -> UnitDefinition {
                UnitDefinition {
                    base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                    multiplier: AMOUNTOFSUBSTANCE_STANDARD_CUBIC_FOOT_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    AmountOfSubstanceUnit::yottamole =>
                        AMOUNTOFSUBSTANCE_YOTTAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::zettamole =>
                        AMOUNTOFSUBSTANCE_ZETTAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::examole =>
                        AMOUNTOFSUBSTANCE_EXAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::petamole =>
                        AMOUNTOFSUBSTANCE_PETAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::teramole =>
                        AMOUNTOFSUBSTANCE_TERAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::gigamole =>
                        AMOUNTOFSUBSTANCE_GIGAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::megamole =>
                        AMOUNTOFSUBSTANCE_MEGAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::kilomole =>
                        AMOUNTOFSUBSTANCE_KILOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::hectomole =>
                        AMOUNTOFSUBSTANCE_HECTOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::decamole =>
                        AMOUNTOFSUBSTANCE_DECAMOLE_CONVERSION,
                    AmountOfSubstanceUnit::mole =>
                        AMOUNTOFSUBSTANCE_MOLE_CONVERSION,
                    AmountOfSubstanceUnit::decimole =>
                        AMOUNTOFSUBSTANCE_DECIMOLE_CONVERSION,
                    AmountOfSubstanceUnit::centimole =>
                        AMOUNTOFSUBSTANCE_CENTIMOLE_CONVERSION,
                    AmountOfSubstanceUnit::millimole =>
                        AMOUNTOFSUBSTANCE_MILLIMOLE_CONVERSION,
                    AmountOfSubstanceUnit::micromole =>
                        AMOUNTOFSUBSTANCE_MICROMOLE_CONVERSION,
                    AmountOfSubstanceUnit::nanomole =>
                        AMOUNTOFSUBSTANCE_NANOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::picomole =>
                        AMOUNTOFSUBSTANCE_PICOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::femtomole =>
                        AMOUNTOFSUBSTANCE_FEMTOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::attomole =>
                        AMOUNTOFSUBSTANCE_ATTOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::zeptomole =>
                        AMOUNTOFSUBSTANCE_ZEPTOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::yoctomole =>
                        AMOUNTOFSUBSTANCE_YOCTOMOLE_CONVERSION,
                    AmountOfSubstanceUnit::particle =>
                        AMOUNTOFSUBSTANCE_PARTICLE_CONVERSION,
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        AMOUNTOFSUBSTANCE_STANDARD_CUBIC_METER_CONVERSION,
                    AmountOfSubstanceUnit::standard_liter =>
                        AMOUNTOFSUBSTANCE_STANDARD_LITER_CONVERSION,
                    AmountOfSubstanceUnit::standard_centimeter =>
                        AMOUNTOFSUBSTANCE_STANDARD_CENTIMETER_CONVERSION,
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        AMOUNTOFSUBSTANCE_STANDARD_CUBIC_FOOT_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    AmountOfSubstanceUnit::yottamole => "Ymol",
                    AmountOfSubstanceUnit::zettamole => "Zmol",
                    AmountOfSubstanceUnit::examole => "Emol",
                    AmountOfSubstanceUnit::petamole => "Pmol",
                    AmountOfSubstanceUnit::teramole => "Tmol",
                    AmountOfSubstanceUnit::gigamole => "Gmol",
                    AmountOfSubstanceUnit::megamole => "Mmol",
                    AmountOfSubstanceUnit::kilomole => "kmol",
                    AmountOfSubstanceUnit::hectomole => "hmol",
                    AmountOfSubstanceUnit::decamole => "damol",
                    AmountOfSubstanceUnit::mole => "mol",
                    AmountOfSubstanceUnit::decimole => "dmol",
                    AmountOfSubstanceUnit::centimole => "cmol",
                    AmountOfSubstanceUnit::millimole => "mmol",
                    AmountOfSubstanceUnit::micromole => "mol",
                    AmountOfSubstanceUnit::nanomole => "nmol",
                    AmountOfSubstanceUnit::picomole => "pmol",
                    AmountOfSubstanceUnit::femtomole => "fmol",
                    AmountOfSubstanceUnit::attomole => "amol",
                    AmountOfSubstanceUnit::zeptomole => "zmol",
                    AmountOfSubstanceUnit::yoctomole => "ymol",
                    AmountOfSubstanceUnit::particle => "particle",
                    AmountOfSubstanceUnit::standard_cubic_meter => "m(STP)",
                    AmountOfSubstanceUnit::standard_liter => "L(STP)",
                    AmountOfSubstanceUnit::standard_centimeter => "cm(STP)",
                    AmountOfSubstanceUnit::standard_cubic_foot => "scf",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    AmountOfSubstanceUnit::yottamole => "yottamole",
                    AmountOfSubstanceUnit::zettamole => "zettamole",
                    AmountOfSubstanceUnit::examole => "examole",
                    AmountOfSubstanceUnit::petamole => "petamole",
                    AmountOfSubstanceUnit::teramole => "teramole",
                    AmountOfSubstanceUnit::gigamole => "gigamole",
                    AmountOfSubstanceUnit::megamole => "megamole",
                    AmountOfSubstanceUnit::kilomole => "kilomole",
                    AmountOfSubstanceUnit::hectomole => "hectomole",
                    AmountOfSubstanceUnit::decamole => "decamole",
                    AmountOfSubstanceUnit::mole => "mole",
                    AmountOfSubstanceUnit::decimole => "decimole",
                    AmountOfSubstanceUnit::centimole => "centimole",
                    AmountOfSubstanceUnit::millimole => "millimole",
                    AmountOfSubstanceUnit::micromole => "micromole",
                    AmountOfSubstanceUnit::nanomole => "nanomole",
                    AmountOfSubstanceUnit::picomole => "picomole",
                    AmountOfSubstanceUnit::femtomole => "femtomole",
                    AmountOfSubstanceUnit::attomole => "attomole",
                    AmountOfSubstanceUnit::zeptomole => "zeptomole",
                    AmountOfSubstanceUnit::yoctomole => "yoctomole",
                    AmountOfSubstanceUnit::particle => "particle",
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        "standard cubic meter",
                    AmountOfSubstanceUnit::standard_liter => "standard liter",
                    AmountOfSubstanceUnit::standard_centimeter =>
                        "standard cubic centimeter",
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        "standard cubic foot",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    AmountOfSubstanceUnit::yottamole => "yottamoles",
                    AmountOfSubstanceUnit::zettamole => "zettamoles",
                    AmountOfSubstanceUnit::examole => "examoles",
                    AmountOfSubstanceUnit::petamole => "petamoles",
                    AmountOfSubstanceUnit::teramole => "teramoles",
                    AmountOfSubstanceUnit::gigamole => "gigamoles",
                    AmountOfSubstanceUnit::megamole => "megamoles",
                    AmountOfSubstanceUnit::kilomole => "kilomoles",
                    AmountOfSubstanceUnit::hectomole => "hectomoles",
                    AmountOfSubstanceUnit::decamole => "decamoles",
                    AmountOfSubstanceUnit::mole => "moles",
                    AmountOfSubstanceUnit::decimole => "decimoles",
                    AmountOfSubstanceUnit::centimole => "centimoles",
                    AmountOfSubstanceUnit::millimole => "millimoles",
                    AmountOfSubstanceUnit::micromole => "micromoles",
                    AmountOfSubstanceUnit::nanomole => "nanomoles",
                    AmountOfSubstanceUnit::picomole => "picomoles",
                    AmountOfSubstanceUnit::femtomole => "femtomoles",
                    AmountOfSubstanceUnit::attomole => "attomoles",
                    AmountOfSubstanceUnit::zeptomole => "zeptomoles",
                    AmountOfSubstanceUnit::yoctomole => "yoctomoles",
                    AmountOfSubstanceUnit::particle => "particles",
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        "standard cubic mols",
                    AmountOfSubstanceUnit::standard_liter => "standard liters",
                    AmountOfSubstanceUnit::standard_centimeter =>
                        "standard cubic centimols",
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        "standard cubic feet",
                }
            }
            #[doc = "Available units for this `[AmountOfSubstanceUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["yottamole", "zettamole", "examole", "petamole",
                                "teramole", "gigamole", "megamole", "kilomole", "hectomole",
                                "decamole", "mole", "decimole", "centimole", "millimole",
                                "micromole", "nanomole", "picomole", "femtomole",
                                "attomole", "zeptomole", "yoctomole", "particle",
                                "standard cubic meter", "standard liter",
                                "standard cubic centimeter", "standard cubic foot"];
                UNITS
            }
        }
        impl crate::traits::Unit for AmountOfSubstanceUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    AmountOfSubstanceUnit::yottamole =>
                        AmountOfSubstanceUnit::get_yottamole(),
                    AmountOfSubstanceUnit::zettamole =>
                        AmountOfSubstanceUnit::get_zettamole(),
                    AmountOfSubstanceUnit::examole =>
                        AmountOfSubstanceUnit::get_examole(),
                    AmountOfSubstanceUnit::petamole =>
                        AmountOfSubstanceUnit::get_petamole(),
                    AmountOfSubstanceUnit::teramole =>
                        AmountOfSubstanceUnit::get_teramole(),
                    AmountOfSubstanceUnit::gigamole =>
                        AmountOfSubstanceUnit::get_gigamole(),
                    AmountOfSubstanceUnit::megamole =>
                        AmountOfSubstanceUnit::get_megamole(),
                    AmountOfSubstanceUnit::kilomole =>
                        AmountOfSubstanceUnit::get_kilomole(),
                    AmountOfSubstanceUnit::hectomole =>
                        AmountOfSubstanceUnit::get_hectomole(),
                    AmountOfSubstanceUnit::decamole =>
                        AmountOfSubstanceUnit::get_decamole(),
                    AmountOfSubstanceUnit::mole =>
                        AmountOfSubstanceUnit::get_mole(),
                    AmountOfSubstanceUnit::decimole =>
                        AmountOfSubstanceUnit::get_decimole(),
                    AmountOfSubstanceUnit::centimole =>
                        AmountOfSubstanceUnit::get_centimole(),
                    AmountOfSubstanceUnit::millimole =>
                        AmountOfSubstanceUnit::get_millimole(),
                    AmountOfSubstanceUnit::micromole =>
                        AmountOfSubstanceUnit::get_micromole(),
                    AmountOfSubstanceUnit::nanomole =>
                        AmountOfSubstanceUnit::get_nanomole(),
                    AmountOfSubstanceUnit::picomole =>
                        AmountOfSubstanceUnit::get_picomole(),
                    AmountOfSubstanceUnit::femtomole =>
                        AmountOfSubstanceUnit::get_femtomole(),
                    AmountOfSubstanceUnit::attomole =>
                        AmountOfSubstanceUnit::get_attomole(),
                    AmountOfSubstanceUnit::zeptomole =>
                        AmountOfSubstanceUnit::get_zeptomole(),
                    AmountOfSubstanceUnit::yoctomole =>
                        AmountOfSubstanceUnit::get_yoctomole(),
                    AmountOfSubstanceUnit::particle =>
                        AmountOfSubstanceUnit::get_particle(),
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        AmountOfSubstanceUnit::get_standard_cubic_meter(),
                    AmountOfSubstanceUnit::standard_liter =>
                        AmountOfSubstanceUnit::get_standard_liter(),
                    AmountOfSubstanceUnit::standard_centimeter =>
                        AmountOfSubstanceUnit::get_standard_centimeter(),
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        AmountOfSubstanceUnit::get_standard_cubic_foot(),
                }
            }
            #[inline]
            fn base() -> UnitBase { AMOUNTOFSUBSTANCE_UNIT_BASE }
        }
        impl From<AmountOfSubstanceUnit> for crate::Units {
            fn from(value: AmountOfSubstanceUnit) -> Self {
                match value {
                    AmountOfSubstanceUnit::yottamole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::yottamole),
                    AmountOfSubstanceUnit::zettamole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::zettamole),
                    AmountOfSubstanceUnit::examole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::examole),
                    AmountOfSubstanceUnit::petamole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::petamole),
                    AmountOfSubstanceUnit::teramole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::teramole),
                    AmountOfSubstanceUnit::gigamole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::gigamole),
                    AmountOfSubstanceUnit::megamole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::megamole),
                    AmountOfSubstanceUnit::kilomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::kilomole),
                    AmountOfSubstanceUnit::hectomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::hectomole),
                    AmountOfSubstanceUnit::decamole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::decamole),
                    AmountOfSubstanceUnit::mole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::mole),
                    AmountOfSubstanceUnit::decimole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::decimole),
                    AmountOfSubstanceUnit::centimole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::centimole),
                    AmountOfSubstanceUnit::millimole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::millimole),
                    AmountOfSubstanceUnit::micromole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::micromole),
                    AmountOfSubstanceUnit::nanomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::nanomole),
                    AmountOfSubstanceUnit::picomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::picomole),
                    AmountOfSubstanceUnit::femtomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::femtomole),
                    AmountOfSubstanceUnit::attomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::attomole),
                    AmountOfSubstanceUnit::zeptomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::zeptomole),
                    AmountOfSubstanceUnit::yoctomole =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::yoctomole),
                    AmountOfSubstanceUnit::particle =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::particle),
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_cubic_meter),
                    AmountOfSubstanceUnit::standard_liter =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_liter),
                    AmountOfSubstanceUnit::standard_centimeter =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_centimeter),
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_cubic_foot),
                }
            }
        }
        impl TryFrom<UnitDefinition> for AmountOfSubstanceUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_YOTTAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::yottamole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_ZETTAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::zettamole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_EXAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::examole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_PETAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::petamole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_TERAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::teramole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_GIGAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::gigamole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_MEGAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::megamole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_KILOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::kilomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_HECTOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::hectomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_DECAMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::decamole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_MOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::mole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_DECIMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::decimole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_CENTIMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::centimole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_MILLIMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::millimole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_MICROMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::micromole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_NANOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::nanomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_PICOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::picomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_FEMTOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::femtomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_ATTOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::attomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_ZEPTOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::zeptomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_YOCTOMOLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::yoctomole),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_PARTICLE_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::particle),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_STANDARD_CUBIC_METER_CONVERSION
                        } => Ok(AmountOfSubstanceUnit::standard_cubic_meter),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_STANDARD_LITER_CONVERSION } =>
                        Ok(AmountOfSubstanceUnit::standard_liter),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_STANDARD_CENTIMETER_CONVERSION
                        } => Ok(AmountOfSubstanceUnit::standard_centimeter),
                    UnitDefinition {
                        base: AMOUNTOFSUBSTANCE_UNIT_BASE,
                        multiplier: AMOUNTOFSUBSTANCE_STANDARD_CUBIC_FOOT_CONVERSION
                        } => Ok(AmountOfSubstanceUnit::standard_cubic_foot),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "AmountOfSubstance"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for AmountOfSubstanceUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::yottamole)
                        => Ok(AmountOfSubstanceUnit::yottamole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::zettamole)
                        => Ok(AmountOfSubstanceUnit::zettamole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::examole)
                        => Ok(AmountOfSubstanceUnit::examole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::petamole)
                        => Ok(AmountOfSubstanceUnit::petamole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::teramole)
                        => Ok(AmountOfSubstanceUnit::teramole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::gigamole)
                        => Ok(AmountOfSubstanceUnit::gigamole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::megamole)
                        => Ok(AmountOfSubstanceUnit::megamole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::kilomole)
                        => Ok(AmountOfSubstanceUnit::kilomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::hectomole)
                        => Ok(AmountOfSubstanceUnit::hectomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::decamole)
                        => Ok(AmountOfSubstanceUnit::decamole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::mole)
                        => Ok(AmountOfSubstanceUnit::mole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::decimole)
                        => Ok(AmountOfSubstanceUnit::decimole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::centimole)
                        => Ok(AmountOfSubstanceUnit::centimole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::millimole)
                        => Ok(AmountOfSubstanceUnit::millimole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::micromole)
                        => Ok(AmountOfSubstanceUnit::micromole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::nanomole)
                        => Ok(AmountOfSubstanceUnit::nanomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::picomole)
                        => Ok(AmountOfSubstanceUnit::picomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::femtomole)
                        => Ok(AmountOfSubstanceUnit::femtomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::attomole)
                        => Ok(AmountOfSubstanceUnit::attomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::zeptomole)
                        => Ok(AmountOfSubstanceUnit::zeptomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::yoctomole)
                        => Ok(AmountOfSubstanceUnit::yoctomole),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::particle)
                        => Ok(AmountOfSubstanceUnit::particle),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_cubic_meter)
                        => Ok(AmountOfSubstanceUnit::standard_cubic_meter),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_liter)
                        => Ok(AmountOfSubstanceUnit::standard_liter),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_centimeter)
                        => Ok(AmountOfSubstanceUnit::standard_centimeter),
                    crate::Units::AmountOfSubstance(AmountOfSubstanceUnit::standard_cubic_foot)
                        => Ok(AmountOfSubstanceUnit::standard_cubic_foot),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "AmountOfSubstance"));
                                        res
                                    }))),
                }
            }
        }
        impl From<AmountOfSubstance> for crate::Units {
            fn from(value: AmountOfSubstance) -> Self {
                crate::Units::AmountOfSubstance(value.unit)
            }
        }
        impl From<&AmountOfSubstance> for crate::Units {
            fn from(value: &AmountOfSubstance) -> Self {
                crate::Units::AmountOfSubstance(value.unit)
            }
        }
        impl From<AmountOfSubstanceVec> for crate::Units {
            fn from(value: AmountOfSubstanceVec) -> Self {
                crate::Units::AmountOfSubstance(value.unit)
            }
        }
        impl From<&AmountOfSubstanceVec> for crate::Units {
            fn from(value: &AmountOfSubstanceVec) -> Self {
                crate::Units::AmountOfSubstance(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Amount of substance (base UnitDefinition mole, mol)."]
        #[schema(title = "AmountOfSubstance")]
        #[doc =
        "Scalar storage of a quantity (f64 and [`AmountOfSubstanceUnit`])."]
        pub struct AmountOfSubstance {
            pub(crate) value: f64,
            pub(crate) unit: AmountOfSubstanceUnit,
        }
        impl utoipa::__dev::ComposeSchema for AmountOfSubstance {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("AmountOfSubstance")).description(Some(" Amount of substance (base UnitDefinition mole, mol).\nScalar storage of a quantity (f64 and [`AmountOfSubstanceUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for AmountOfSubstance {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("AmountOfSubstance")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <AmountOfSubstanceUnit as
                                        utoipa::PartialSchema>::schema())]);
                <AmountOfSubstanceUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AmountOfSubstance {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "AmountOfSubstance", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for AmountOfSubstance {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<AmountOfSubstance>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = AmountOfSubstance;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct AmountOfSubstance")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct AmountOfSubstance with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<AmountOfSubstanceUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct AmountOfSubstance with 2 elements")),
                                    };
                                _serde::__private::Ok(AmountOfSubstance {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1:
                                        _serde::__private::Option<AmountOfSubstanceUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<AmountOfSubstanceUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(AmountOfSubstance {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "AmountOfSubstance", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<AmountOfSubstance>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for AmountOfSubstance { }
        #[automatically_derived]
        impl ::core::clone::Clone for AmountOfSubstance {
            #[inline]
            fn clone(&self) -> AmountOfSubstance {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _:
                        ::core::clone::AssertParamIsClone<AmountOfSubstanceUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AmountOfSubstance {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "AmountOfSubstance", "value", &self.value, "unit",
                    &&self.unit)
            }
        }
        impl AmountOfSubstance {
            #[doc = "Create a new [`AmountOfSubstanceUnit`]."]
            pub fn new(value: f64, unit: AmountOfSubstanceUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::yottamole`]."]
            pub fn yottamole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::yottamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::zettamole`]."]
            pub fn zettamole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::zettamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::examole`]."]
            pub fn examole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::examole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::petamole`]."]
            pub fn petamole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::petamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::teramole`]."]
            pub fn teramole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::teramole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::gigamole`]."]
            pub fn gigamole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::gigamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::megamole`]."]
            pub fn megamole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::megamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::kilomole`]."]
            pub fn kilomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::kilomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::hectomole`]."]
            pub fn hectomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::hectomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::decamole`]."]
            pub fn decamole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::decamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::mole`]."]
            pub fn mole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::mole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::decimole`]."]
            pub fn decimole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::decimole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::centimole`]."]
            pub fn centimole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::centimole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::millimole`]."]
            pub fn millimole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::millimole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::micromole`]."]
            pub fn micromole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::micromole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::nanomole`]."]
            pub fn nanomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::nanomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::picomole`]."]
            pub fn picomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::picomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::femtomole`]."]
            pub fn femtomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::femtomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::attomole`]."]
            pub fn attomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::attomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::zeptomole`]."]
            pub fn zeptomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::zeptomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::yoctomole`]."]
            pub fn yoctomole(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::yoctomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::particle`]."]
            pub fn particle(value: f64) -> Self {
                Self { value, unit: AmountOfSubstanceUnit::particle.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_cubic_meter`]."]
            pub fn standard_cubic_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: AmountOfSubstanceUnit::standard_cubic_meter.into(),
                }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_liter`]."]
            pub fn standard_liter(value: f64) -> Self {
                Self {
                    value,
                    unit: AmountOfSubstanceUnit::standard_liter.into(),
                }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_centimeter`]."]
            pub fn standard_centimeter(value: f64) -> Self {
                Self {
                    value,
                    unit: AmountOfSubstanceUnit::standard_centimeter.into(),
                }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_cubic_foot`]."]
            pub fn standard_cubic_foot(value: f64) -> Self {
                Self {
                    value,
                    unit: AmountOfSubstanceUnit::standard_cubic_foot.into(),
                }
            }
            #[doc =
            "Retrieve the value associated with this [`AmountOfSubstance`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`AmountOfSubstance`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`AmountOfSubstance`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::yottamole`]."]
            #[inline]
            pub fn to_yottamole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_YOTTAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::yottamole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::zettamole`]."]
            #[inline]
            pub fn to_zettamole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_ZETTAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::zettamole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::examole`]."]
            #[inline]
            pub fn to_examole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_EXAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::examole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::petamole`]."]
            #[inline]
            pub fn to_petamole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_PETAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::petamole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::teramole`]."]
            #[inline]
            pub fn to_teramole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_TERAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::teramole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::gigamole`]."]
            #[inline]
            pub fn to_gigamole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_GIGAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::gigamole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::megamole`]."]
            #[inline]
            pub fn to_megamole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_MEGAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::megamole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::kilomole`]."]
            #[inline]
            pub fn to_kilomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_KILOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::kilomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::hectomole`]."]
            #[inline]
            pub fn to_hectomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_HECTOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::hectomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::decamole`]."]
            #[inline]
            pub fn to_decamole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_DECAMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::decamole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::mole`]."]
            #[inline]
            pub fn to_mole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_MOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::mole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::decimole`]."]
            #[inline]
            pub fn to_decimole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_DECIMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::decimole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::centimole`]."]
            #[inline]
            pub fn to_centimole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_CENTIMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::centimole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::millimole`]."]
            #[inline]
            pub fn to_millimole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_MILLIMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::millimole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::micromole`]."]
            #[inline]
            pub fn to_micromole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_MICROMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::micromole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::nanomole`]."]
            #[inline]
            pub fn to_nanomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_NANOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::nanomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::picomole`]."]
            #[inline]
            pub fn to_picomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_PICOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::picomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::femtomole`]."]
            #[inline]
            pub fn to_femtomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_FEMTOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::femtomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::attomole`]."]
            #[inline]
            pub fn to_attomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_ATTOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::attomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::zeptomole`]."]
            #[inline]
            pub fn to_zeptomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_ZEPTOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::zeptomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::yoctomole`]."]
            #[inline]
            pub fn to_yoctomole(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_YOCTOMOLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::yoctomole,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::particle`]."]
            #[inline]
            pub fn to_particle(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_PARTICLE_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::particle,
                }
            }
            #[doc =
            "Convert to [`AmountOfSubstanceUnit::standard_cubic_meter`]."]
            #[inline]
            pub fn to_standard_cubic_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_STANDARD_CUBIC_METER_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::standard_cubic_meter,
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::standard_liter`]."]
            #[inline]
            pub fn to_standard_liter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_STANDARD_LITER_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::standard_liter,
                }
            }
            #[doc =
            "Convert to [`AmountOfSubstanceUnit::standard_centimeter`]."]
            #[inline]
            pub fn to_standard_centimeter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_STANDARD_CENTIMETER_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::standard_centimeter,
                }
            }
            #[doc =
            "Convert to [`AmountOfSubstanceUnit::standard_cubic_foot`]."]
            #[inline]
            pub fn to_standard_cubic_foot(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (AMOUNTOFSUBSTANCE_STANDARD_CUBIC_FOOT_CONVERSION)) as f64,
                    unit: AmountOfSubstanceUnit::standard_cubic_foot,
                }
            }
        }
        impl FixedQuantity<AmountOfSubstanceUnit> for AmountOfSubstance {
            #[inline]
            fn unit(&self) -> AmountOfSubstanceUnit { self.unit }
            #[inline]
            fn convert(&self, unit: AmountOfSubstanceUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: AmountOfSubstanceUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut AmountOfSubstanceUnit {
                &mut self.unit
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: AmountOfSubstanceUnit =
                    unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<AmountOfSubstance> for UnitDefinition {
            #[inline]
            fn from(value: AmountOfSubstance) -> Self {
                match value.unit {
                    AmountOfSubstanceUnit::yottamole =>
                        AmountOfSubstanceUnit::get_yottamole(),
                    AmountOfSubstanceUnit::zettamole =>
                        AmountOfSubstanceUnit::get_zettamole(),
                    AmountOfSubstanceUnit::examole =>
                        AmountOfSubstanceUnit::get_examole(),
                    AmountOfSubstanceUnit::petamole =>
                        AmountOfSubstanceUnit::get_petamole(),
                    AmountOfSubstanceUnit::teramole =>
                        AmountOfSubstanceUnit::get_teramole(),
                    AmountOfSubstanceUnit::gigamole =>
                        AmountOfSubstanceUnit::get_gigamole(),
                    AmountOfSubstanceUnit::megamole =>
                        AmountOfSubstanceUnit::get_megamole(),
                    AmountOfSubstanceUnit::kilomole =>
                        AmountOfSubstanceUnit::get_kilomole(),
                    AmountOfSubstanceUnit::hectomole =>
                        AmountOfSubstanceUnit::get_hectomole(),
                    AmountOfSubstanceUnit::decamole =>
                        AmountOfSubstanceUnit::get_decamole(),
                    AmountOfSubstanceUnit::mole =>
                        AmountOfSubstanceUnit::get_mole(),
                    AmountOfSubstanceUnit::decimole =>
                        AmountOfSubstanceUnit::get_decimole(),
                    AmountOfSubstanceUnit::centimole =>
                        AmountOfSubstanceUnit::get_centimole(),
                    AmountOfSubstanceUnit::millimole =>
                        AmountOfSubstanceUnit::get_millimole(),
                    AmountOfSubstanceUnit::micromole =>
                        AmountOfSubstanceUnit::get_micromole(),
                    AmountOfSubstanceUnit::nanomole =>
                        AmountOfSubstanceUnit::get_nanomole(),
                    AmountOfSubstanceUnit::picomole =>
                        AmountOfSubstanceUnit::get_picomole(),
                    AmountOfSubstanceUnit::femtomole =>
                        AmountOfSubstanceUnit::get_femtomole(),
                    AmountOfSubstanceUnit::attomole =>
                        AmountOfSubstanceUnit::get_attomole(),
                    AmountOfSubstanceUnit::zeptomole =>
                        AmountOfSubstanceUnit::get_zeptomole(),
                    AmountOfSubstanceUnit::yoctomole =>
                        AmountOfSubstanceUnit::get_yoctomole(),
                    AmountOfSubstanceUnit::particle =>
                        AmountOfSubstanceUnit::get_particle(),
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        AmountOfSubstanceUnit::get_standard_cubic_meter(),
                    AmountOfSubstanceUnit::standard_liter =>
                        AmountOfSubstanceUnit::get_standard_liter(),
                    AmountOfSubstanceUnit::standard_centimeter =>
                        AmountOfSubstanceUnit::get_standard_centimeter(),
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        AmountOfSubstanceUnit::get_standard_cubic_foot(),
                }
            }
        }
        impl From<AmountOfSubstance> for Quantity {
            fn from(quantity: AmountOfSubstance) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for AmountOfSubstance {
            fn from(quantity: Quantity) -> AmountOfSubstance {
                AmountOfSubstance {
                    value: quantity.value,
                    unit: AmountOfSubstanceUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for AmountOfSubstance {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl AmountOfSubstanceVec {
            #[doc = "Create a new vector of [`AmountOfSubstanceUnit`]."]
            pub fn new(values: Vec<f64>, unit: AmountOfSubstanceUnit)
                -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc =
            "Retrieve values associated with this [`AmountOfSubstanceSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`AmountOfSubstanceSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::yottamole`]."]
            pub fn yottamole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::yottamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::zettamole`]."]
            pub fn zettamole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::zettamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::examole`]."]
            pub fn examole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::examole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::petamole`]."]
            pub fn petamole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::petamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::teramole`]."]
            pub fn teramole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::teramole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::gigamole`]."]
            pub fn gigamole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::gigamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::megamole`]."]
            pub fn megamole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::megamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::kilomole`]."]
            pub fn kilomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::kilomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::hectomole`]."]
            pub fn hectomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::hectomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::decamole`]."]
            pub fn decamole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::decamole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::mole`]."]
            pub fn mole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::mole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::decimole`]."]
            pub fn decimole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::decimole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::centimole`]."]
            pub fn centimole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::centimole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::millimole`]."]
            pub fn millimole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::millimole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::micromole`]."]
            pub fn micromole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::micromole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::nanomole`]."]
            pub fn nanomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::nanomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::picomole`]."]
            pub fn picomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::picomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::femtomole`]."]
            pub fn femtomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::femtomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::attomole`]."]
            pub fn attomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::attomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::zeptomole`]."]
            pub fn zeptomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::zeptomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::yoctomole`]."]
            pub fn yoctomole(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::yoctomole.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::particle`]."]
            pub fn particle(values: Vec<f64>) -> Self {
                Self { values, unit: AmountOfSubstanceUnit::particle.into() }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_cubic_meter`]."]
            pub fn standard_cubic_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: AmountOfSubstanceUnit::standard_cubic_meter.into(),
                }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_liter`]."]
            pub fn standard_liter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: AmountOfSubstanceUnit::standard_liter.into(),
                }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_centimeter`]."]
            pub fn standard_centimeter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: AmountOfSubstanceUnit::standard_centimeter.into(),
                }
            }
            #[doc =
            "Create a new [`AmountOfSubstance`] with units of [`AmountOfSubstanceUnit::standard_cubic_foot`]."]
            pub fn standard_cubic_foot(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: AmountOfSubstanceUnit::standard_cubic_foot.into(),
                }
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::yottamole`]."]
            #[inline]
            pub fn to_yottamole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::yottamole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::zettamole`]."]
            #[inline]
            pub fn to_zettamole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::zettamole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::examole`]."]
            #[inline]
            pub fn to_examole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::examole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::petamole`]."]
            #[inline]
            pub fn to_petamole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::petamole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::teramole`]."]
            #[inline]
            pub fn to_teramole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::teramole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::gigamole`]."]
            #[inline]
            pub fn to_gigamole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::gigamole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::megamole`]."]
            #[inline]
            pub fn to_megamole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::megamole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::kilomole`]."]
            #[inline]
            pub fn to_kilomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::kilomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::hectomole`]."]
            #[inline]
            pub fn to_hectomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::hectomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::decamole`]."]
            #[inline]
            pub fn to_decamole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::decamole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::mole`]."]
            #[inline]
            pub fn to_mole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::mole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::decimole`]."]
            #[inline]
            pub fn to_decimole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::decimole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::centimole`]."]
            #[inline]
            pub fn to_centimole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::centimole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::millimole`]."]
            #[inline]
            pub fn to_millimole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::millimole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::micromole`]."]
            #[inline]
            pub fn to_micromole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::micromole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::nanomole`]."]
            #[inline]
            pub fn to_nanomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::nanomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::picomole`]."]
            #[inline]
            pub fn to_picomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::picomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::femtomole`]."]
            #[inline]
            pub fn to_femtomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::femtomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::attomole`]."]
            #[inline]
            pub fn to_attomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::attomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::zeptomole`]."]
            #[inline]
            pub fn to_zeptomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::zeptomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::yoctomole`]."]
            #[inline]
            pub fn to_yoctomole(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::yoctomole);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::particle`]."]
            #[inline]
            pub fn to_particle(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::particle);
                r
            }
            #[doc =
            "Convert to [`AmountOfSubstanceUnit::standard_cubic_meter`]."]
            #[inline]
            pub fn to_standard_cubic_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::standard_cubic_meter);
                r
            }
            #[doc = "Convert to [`AmountOfSubstanceUnit::standard_liter`]."]
            #[inline]
            pub fn to_standard_liter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::standard_liter);
                r
            }
            #[doc =
            "Convert to [`AmountOfSubstanceUnit::standard_centimeter`]."]
            #[inline]
            pub fn to_standard_centimeter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::standard_centimeter);
                r
            }
            #[doc =
            "Convert to [`AmountOfSubstanceUnit::standard_cubic_foot`]."]
            #[inline]
            pub fn to_standard_cubic_foot(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AmountOfSubstanceUnit::standard_cubic_foot);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for AmountOfSubstance {
            type Output = AmountOfSubstance;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for AmountOfSubstance {
            type Output = AmountOfSubstance;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for AmountOfSubstance {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for AmountOfSubstance {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for AmountOfSubstance {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<AmountOfSubstance> for Quantity {
            fn eq(&self, other: &AmountOfSubstance) -> bool {
                *other == *self
            }
        }
        impl PartialEq<AmountOfSubstance> for AmountOfSubstance {
            fn eq(&self, other: &AmountOfSubstance) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for AmountOfSubstance {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for AmountOfSubstance {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<AmountOfSubstance> for AmountOfSubstance {
            type Output = Self;
            fn add(self, rhs: AmountOfSubstance) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<AmountOfSubstance> for AmountOfSubstance {
            type Output = Self;
            fn sub(self, rhs: AmountOfSubstance) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for AmountOfSubstance {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for AmountOfSubstance {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for AmountOfSubstance {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for AmountOfSubstance {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for AmountOfSubstance {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for AmountOfSubstance {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc =
        "Array storage for a series of values and [`AmountOfSubstanceUnit`]."]
        pub struct AmountOfSubstanceArray<const N : usize> {
            pub(crate) unit: AmountOfSubstanceUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for
            AmountOfSubstanceArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`AmountOfSubstanceUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for AmountOfSubstanceArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("AmountOfSubstanceArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <AmountOfSubstanceUnit as
                                        utoipa::PartialSchema>::schema())]);
                <AmountOfSubstanceUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for
                    AmountOfSubstanceArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "AmountOfSubstanceArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<AmountOfSubstanceArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<AmountOfSubstanceArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    AmountOfSubstanceArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<AmountOfSubstanceArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = AmountOfSubstanceArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct AmountOfSubstanceArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<AmountOfSubstanceUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct AmountOfSubstanceArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<AmountOfSubstanceArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct AmountOfSubstanceArray with 2 elements")),
                                    };
                                _serde::__private::Ok(AmountOfSubstanceArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<AmountOfSubstanceUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<AmountOfSubstanceUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<AmountOfSubstanceArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(AmountOfSubstanceArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "AmountOfSubstanceArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<AmountOfSubstanceArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for
            AmountOfSubstanceArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for
            AmountOfSubstanceArray<N> {
            #[inline]
            fn clone(&self) -> AmountOfSubstanceArray<N> {
                let _:
                        ::core::clone::AssertParamIsClone<AmountOfSubstanceUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for AmountOfSubstanceArray<N>
            {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "AmountOfSubstanceArray", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            AmountOfSubstanceArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for
            AmountOfSubstanceArray<N> {
            #[inline]
            fn eq(&self, other: &AmountOfSubstanceArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for AmountOfSubstanceArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for AmountOfSubstanceArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc =
        "Vector storage for a series of values and [`AmountOfSubstanceUnit`]."]
        pub struct AmountOfSubstanceVec {
            pub(crate) unit: AmountOfSubstanceUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for AmountOfSubstanceVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`AmountOfSubstanceUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for AmountOfSubstanceVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("AmountOfSubstanceVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <AmountOfSubstanceUnit as
                                        utoipa::PartialSchema>::schema())]);
                <AmountOfSubstanceUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AmountOfSubstanceVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "AmountOfSubstanceVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for AmountOfSubstanceVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<AmountOfSubstanceVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = AmountOfSubstanceVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct AmountOfSubstanceVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<AmountOfSubstanceUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct AmountOfSubstanceVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct AmountOfSubstanceVec with 2 elements")),
                                    };
                                _serde::__private::Ok(AmountOfSubstanceVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<AmountOfSubstanceUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<AmountOfSubstanceUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(AmountOfSubstanceVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "AmountOfSubstanceVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<AmountOfSubstanceVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for AmountOfSubstanceVec {
            #[inline]
            fn clone(&self) -> AmountOfSubstanceVec {
                AmountOfSubstanceVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AmountOfSubstanceVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "AmountOfSubstanceVec", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AmountOfSubstanceVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AmountOfSubstanceVec {
            #[inline]
            fn eq(&self, other: &AmountOfSubstanceVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for AmountOfSubstanceVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for AmountOfSubstanceVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<AmountOfSubstanceUnit, f64> for
            AmountOfSubstanceVec {
            fn unit(&self) -> AmountOfSubstanceUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: AmountOfSubstanceUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: AmountOfSubstanceUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: AmountOfSubstanceUnit =
                    unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize>
            crate::traits::FixedSliceQuantity<AmountOfSubstanceUnit, f64> for
            AmountOfSubstanceArray<N> {
            fn unit(&self) -> AmountOfSubstanceUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: AmountOfSubstanceUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: AmountOfSubstanceUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: AmountOfSubstanceUnit =
                    unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for AmountOfSubstanceVec {
            type Output = AmountOfSubstanceVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for AmountOfSubstanceVec {
            type Output = AmountOfSubstanceVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for AmountOfSubstanceVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for AmountOfSubstanceVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<AmountOfSubstanceVec> for AmountOfSubstanceVec {
            fn add_assign(&mut self, rhs: AmountOfSubstanceVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<AmountOfSubstanceVec> for AmountOfSubstanceVec {
            fn sub_assign(&mut self, rhs: AmountOfSubstanceVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for AmountOfSubstanceArray<N> {
            type Output = AmountOfSubstanceArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for AmountOfSubstanceArray<N> {
            type Output = AmountOfSubstanceArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for AmountOfSubstanceArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for AmountOfSubstanceArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<AmountOfSubstanceArray<N>> for
            AmountOfSubstanceArray<N> {
            fn add_assign(&mut self, rhs: AmountOfSubstanceArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<AmountOfSubstanceArray<N>> for
            AmountOfSubstanceArray<N> {
            fn sub_assign(&mut self, rhs: AmountOfSubstanceArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<AmountOfSubstanceVec> for VecQuantity {
            fn from(input: AmountOfSubstanceVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<AmountOfSubstanceUnit> for UnitDefinition {
            #[inline]
            fn from(value: AmountOfSubstanceUnit) -> Self {
                match value {
                    AmountOfSubstanceUnit::yottamole =>
                        AmountOfSubstanceUnit::get_yottamole(),
                    AmountOfSubstanceUnit::zettamole =>
                        AmountOfSubstanceUnit::get_zettamole(),
                    AmountOfSubstanceUnit::examole =>
                        AmountOfSubstanceUnit::get_examole(),
                    AmountOfSubstanceUnit::petamole =>
                        AmountOfSubstanceUnit::get_petamole(),
                    AmountOfSubstanceUnit::teramole =>
                        AmountOfSubstanceUnit::get_teramole(),
                    AmountOfSubstanceUnit::gigamole =>
                        AmountOfSubstanceUnit::get_gigamole(),
                    AmountOfSubstanceUnit::megamole =>
                        AmountOfSubstanceUnit::get_megamole(),
                    AmountOfSubstanceUnit::kilomole =>
                        AmountOfSubstanceUnit::get_kilomole(),
                    AmountOfSubstanceUnit::hectomole =>
                        AmountOfSubstanceUnit::get_hectomole(),
                    AmountOfSubstanceUnit::decamole =>
                        AmountOfSubstanceUnit::get_decamole(),
                    AmountOfSubstanceUnit::mole =>
                        AmountOfSubstanceUnit::get_mole(),
                    AmountOfSubstanceUnit::decimole =>
                        AmountOfSubstanceUnit::get_decimole(),
                    AmountOfSubstanceUnit::centimole =>
                        AmountOfSubstanceUnit::get_centimole(),
                    AmountOfSubstanceUnit::millimole =>
                        AmountOfSubstanceUnit::get_millimole(),
                    AmountOfSubstanceUnit::micromole =>
                        AmountOfSubstanceUnit::get_micromole(),
                    AmountOfSubstanceUnit::nanomole =>
                        AmountOfSubstanceUnit::get_nanomole(),
                    AmountOfSubstanceUnit::picomole =>
                        AmountOfSubstanceUnit::get_picomole(),
                    AmountOfSubstanceUnit::femtomole =>
                        AmountOfSubstanceUnit::get_femtomole(),
                    AmountOfSubstanceUnit::attomole =>
                        AmountOfSubstanceUnit::get_attomole(),
                    AmountOfSubstanceUnit::zeptomole =>
                        AmountOfSubstanceUnit::get_zeptomole(),
                    AmountOfSubstanceUnit::yoctomole =>
                        AmountOfSubstanceUnit::get_yoctomole(),
                    AmountOfSubstanceUnit::particle =>
                        AmountOfSubstanceUnit::get_particle(),
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        AmountOfSubstanceUnit::get_standard_cubic_meter(),
                    AmountOfSubstanceUnit::standard_liter =>
                        AmountOfSubstanceUnit::get_standard_liter(),
                    AmountOfSubstanceUnit::standard_centimeter =>
                        AmountOfSubstanceUnit::get_standard_centimeter(),
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        AmountOfSubstanceUnit::get_standard_cubic_foot(),
                }
            }
        }
        impl TryFrom<&str> for AmountOfSubstanceUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<AmountOfSubstanceUnit> =
                    match value {
                        "Ymol" => Some(AmountOfSubstanceUnit::yottamole),
                        "Zmol" => Some(AmountOfSubstanceUnit::zettamole),
                        "Emol" => Some(AmountOfSubstanceUnit::examole),
                        "Pmol" => Some(AmountOfSubstanceUnit::petamole),
                        "Tmol" => Some(AmountOfSubstanceUnit::teramole),
                        "Gmol" => Some(AmountOfSubstanceUnit::gigamole),
                        "Mmol" => Some(AmountOfSubstanceUnit::megamole),
                        "kmol" => Some(AmountOfSubstanceUnit::kilomole),
                        "hmol" => Some(AmountOfSubstanceUnit::hectomole),
                        "damol" => Some(AmountOfSubstanceUnit::decamole),
                        "mol" => Some(AmountOfSubstanceUnit::mole),
                        "dmol" => Some(AmountOfSubstanceUnit::decimole),
                        "cmol" => Some(AmountOfSubstanceUnit::centimole),
                        "mmol" => Some(AmountOfSubstanceUnit::millimole),
                        "mol" => Some(AmountOfSubstanceUnit::micromole),
                        "nmol" => Some(AmountOfSubstanceUnit::nanomole),
                        "pmol" => Some(AmountOfSubstanceUnit::picomole),
                        "fmol" => Some(AmountOfSubstanceUnit::femtomole),
                        "amol" => Some(AmountOfSubstanceUnit::attomole),
                        "zmol" => Some(AmountOfSubstanceUnit::zeptomole),
                        "ymol" => Some(AmountOfSubstanceUnit::yoctomole),
                        "particle" => Some(AmountOfSubstanceUnit::particle),
                        "m(STP)" =>
                            Some(AmountOfSubstanceUnit::standard_cubic_meter),
                        "L(STP)" => Some(AmountOfSubstanceUnit::standard_liter),
                        "cm(STP)" =>
                            Some(AmountOfSubstanceUnit::standard_centimeter),
                        "scf" => Some(AmountOfSubstanceUnit::standard_cubic_foot),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<AmountOfSubstanceUnit> =
                    match value {
                        "yottamole" => Some(AmountOfSubstanceUnit::yottamole),
                        "zettamole" => Some(AmountOfSubstanceUnit::zettamole),
                        "examole" => Some(AmountOfSubstanceUnit::examole),
                        "petamole" => Some(AmountOfSubstanceUnit::petamole),
                        "teramole" => Some(AmountOfSubstanceUnit::teramole),
                        "gigamole" => Some(AmountOfSubstanceUnit::gigamole),
                        "megamole" => Some(AmountOfSubstanceUnit::megamole),
                        "kilomole" => Some(AmountOfSubstanceUnit::kilomole),
                        "hectomole" => Some(AmountOfSubstanceUnit::hectomole),
                        "decamole" => Some(AmountOfSubstanceUnit::decamole),
                        "mole" => Some(AmountOfSubstanceUnit::mole),
                        "decimole" => Some(AmountOfSubstanceUnit::decimole),
                        "centimole" => Some(AmountOfSubstanceUnit::centimole),
                        "millimole" => Some(AmountOfSubstanceUnit::millimole),
                        "micromole" => Some(AmountOfSubstanceUnit::micromole),
                        "nanomole" => Some(AmountOfSubstanceUnit::nanomole),
                        "picomole" => Some(AmountOfSubstanceUnit::picomole),
                        "femtomole" => Some(AmountOfSubstanceUnit::femtomole),
                        "attomole" => Some(AmountOfSubstanceUnit::attomole),
                        "zeptomole" => Some(AmountOfSubstanceUnit::zeptomole),
                        "yoctomole" => Some(AmountOfSubstanceUnit::yoctomole),
                        "particle" => Some(AmountOfSubstanceUnit::particle),
                        "standard cubic meter" =>
                            Some(AmountOfSubstanceUnit::standard_cubic_meter),
                        "standard liter" =>
                            Some(AmountOfSubstanceUnit::standard_liter),
                        "standard cubic centimeter" =>
                            Some(AmountOfSubstanceUnit::standard_centimeter),
                        "standard cubic foot" =>
                            Some(AmountOfSubstanceUnit::standard_cubic_foot),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<AmountOfSubstanceUnit> =
                    match value {
                        "yottamoles" => Some(AmountOfSubstanceUnit::yottamole),
                        "zettamoles" => Some(AmountOfSubstanceUnit::zettamole),
                        "examoles" => Some(AmountOfSubstanceUnit::examole),
                        "petamoles" => Some(AmountOfSubstanceUnit::petamole),
                        "teramoles" => Some(AmountOfSubstanceUnit::teramole),
                        "gigamoles" => Some(AmountOfSubstanceUnit::gigamole),
                        "megamoles" => Some(AmountOfSubstanceUnit::megamole),
                        "kilomoles" => Some(AmountOfSubstanceUnit::kilomole),
                        "hectomoles" => Some(AmountOfSubstanceUnit::hectomole),
                        "decamoles" => Some(AmountOfSubstanceUnit::decamole),
                        "moles" => Some(AmountOfSubstanceUnit::mole),
                        "decimoles" => Some(AmountOfSubstanceUnit::decimole),
                        "centimoles" => Some(AmountOfSubstanceUnit::centimole),
                        "millimoles" => Some(AmountOfSubstanceUnit::millimole),
                        "micromoles" => Some(AmountOfSubstanceUnit::micromole),
                        "nanomoles" => Some(AmountOfSubstanceUnit::nanomole),
                        "picomoles" => Some(AmountOfSubstanceUnit::picomole),
                        "femtomoles" => Some(AmountOfSubstanceUnit::femtomole),
                        "attomoles" => Some(AmountOfSubstanceUnit::attomole),
                        "zeptomoles" => Some(AmountOfSubstanceUnit::zeptomole),
                        "yoctomoles" => Some(AmountOfSubstanceUnit::yoctomole),
                        "particles" => Some(AmountOfSubstanceUnit::particle),
                        "standard cubic mols" =>
                            Some(AmountOfSubstanceUnit::standard_cubic_meter),
                        "standard liters" =>
                            Some(AmountOfSubstanceUnit::standard_liter),
                        "standard cubic centimols" =>
                            Some(AmountOfSubstanceUnit::standard_centimeter),
                        "standard cubic feet" =>
                            Some(AmountOfSubstanceUnit::standard_cubic_foot),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"AmountOfSubstance\"")
                   }
            }
        }
        impl core::fmt::Display for AmountOfSubstanceUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    AmountOfSubstanceUnit::yottamole =>
                        f.write_fmt(format_args!("{0}", "yottamole")),
                    AmountOfSubstanceUnit::zettamole =>
                        f.write_fmt(format_args!("{0}", "zettamole")),
                    AmountOfSubstanceUnit::examole =>
                        f.write_fmt(format_args!("{0}", "examole")),
                    AmountOfSubstanceUnit::petamole =>
                        f.write_fmt(format_args!("{0}", "petamole")),
                    AmountOfSubstanceUnit::teramole =>
                        f.write_fmt(format_args!("{0}", "teramole")),
                    AmountOfSubstanceUnit::gigamole =>
                        f.write_fmt(format_args!("{0}", "gigamole")),
                    AmountOfSubstanceUnit::megamole =>
                        f.write_fmt(format_args!("{0}", "megamole")),
                    AmountOfSubstanceUnit::kilomole =>
                        f.write_fmt(format_args!("{0}", "kilomole")),
                    AmountOfSubstanceUnit::hectomole =>
                        f.write_fmt(format_args!("{0}", "hectomole")),
                    AmountOfSubstanceUnit::decamole =>
                        f.write_fmt(format_args!("{0}", "decamole")),
                    AmountOfSubstanceUnit::mole =>
                        f.write_fmt(format_args!("{0}", "mole")),
                    AmountOfSubstanceUnit::decimole =>
                        f.write_fmt(format_args!("{0}", "decimole")),
                    AmountOfSubstanceUnit::centimole =>
                        f.write_fmt(format_args!("{0}", "centimole")),
                    AmountOfSubstanceUnit::millimole =>
                        f.write_fmt(format_args!("{0}", "millimole")),
                    AmountOfSubstanceUnit::micromole =>
                        f.write_fmt(format_args!("{0}", "micromole")),
                    AmountOfSubstanceUnit::nanomole =>
                        f.write_fmt(format_args!("{0}", "nanomole")),
                    AmountOfSubstanceUnit::picomole =>
                        f.write_fmt(format_args!("{0}", "picomole")),
                    AmountOfSubstanceUnit::femtomole =>
                        f.write_fmt(format_args!("{0}", "femtomole")),
                    AmountOfSubstanceUnit::attomole =>
                        f.write_fmt(format_args!("{0}", "attomole")),
                    AmountOfSubstanceUnit::zeptomole =>
                        f.write_fmt(format_args!("{0}", "zeptomole")),
                    AmountOfSubstanceUnit::yoctomole =>
                        f.write_fmt(format_args!("{0}", "yoctomole")),
                    AmountOfSubstanceUnit::particle =>
                        f.write_fmt(format_args!("{0}", "particle")),
                    AmountOfSubstanceUnit::standard_cubic_meter =>
                        f.write_fmt(format_args!("{0}", "standard cubic meter")),
                    AmountOfSubstanceUnit::standard_liter =>
                        f.write_fmt(format_args!("{0}", "standard liter")),
                    AmountOfSubstanceUnit::standard_centimeter =>
                        f.write_fmt(format_args!("{0}",
                                "standard cubic centimeter")),
                    AmountOfSubstanceUnit::standard_cubic_foot =>
                        f.write_fmt(format_args!("{0}", "standard cubic foot")),
                }
            }
        }
    }
    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
    pub use crate::unit_definitions::amount_of_substance::AmountOfSubstanceArray;
    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
    pub use crate::unit_definitions::amount_of_substance::AmountOfSubstance;
    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
    pub use crate::unit_definitions::amount_of_substance::AmountOfSubstanceVec;
    #[cfg(any(feature = "Angle", feature = "All"))]
    mod angle {
        //! Angle (dimensionless quantity).
        use crate::quantity;
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Angle (dimensionless quantity)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "AngleUnit")]
        pub enum AngleUnit {
            radian,
            revolution,
            degree,
            gon,
            mil,
            minute,
            second,
        }
        impl utoipa::__dev::ComposeSchema for AngleUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 7usize],
                                &str>(Some(["radian", "revolution", "degree", "gon", "mil",
                                            "minute",
                                            "second"])).title(Some("AngleUnit")).description(Some("Angle (dimensionless quantity).")).into()
            }
        }
        impl utoipa::ToSchema for AngleUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("AngleUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AngleUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            AngleUnit::radian =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AngleUnit", 0u32, "radian"),
                            AngleUnit::revolution =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AngleUnit", 1u32, "revolution"),
                            AngleUnit::degree =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AngleUnit", 2u32, "degree"),
                            AngleUnit::gon =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AngleUnit", 3u32, "gon"),
                            AngleUnit::mil =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AngleUnit", 4u32, "mil"),
                            AngleUnit::minute =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AngleUnit", 5u32, "minute"),
                            AngleUnit::second =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "AngleUnit", 6u32, "second"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for AngleUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 7")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "radian" => _serde::__private::Ok(__Field::__field0),
                                    "revolution" => _serde::__private::Ok(__Field::__field1),
                                    "degree" => _serde::__private::Ok(__Field::__field2),
                                    "gon" => _serde::__private::Ok(__Field::__field3),
                                    "mil" => _serde::__private::Ok(__Field::__field4),
                                    "minute" => _serde::__private::Ok(__Field::__field5),
                                    "second" => _serde::__private::Ok(__Field::__field6),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"radian" => _serde::__private::Ok(__Field::__field0),
                                    b"revolution" => _serde::__private::Ok(__Field::__field1),
                                    b"degree" => _serde::__private::Ok(__Field::__field2),
                                    b"gon" => _serde::__private::Ok(__Field::__field3),
                                    b"mil" => _serde::__private::Ok(__Field::__field4),
                                    b"minute" => _serde::__private::Ok(__Field::__field5),
                                    b"second" => _serde::__private::Ok(__Field::__field6),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<AngleUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = AngleUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum AngleUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AngleUnit::radian)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AngleUnit::revolution)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AngleUnit::degree)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AngleUnit::gon)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AngleUnit::mil)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AngleUnit::minute)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(AngleUnit::second)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["radian", "revolution", "degree", "gon", "mil", "minute",
                                        "second"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "AngleUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<AngleUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for AngleUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for AngleUnit {
            #[inline]
            fn clone(&self) -> AngleUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for AngleUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        AngleUnit::radian => "radian",
                        AngleUnit::revolution => "revolution",
                        AngleUnit::degree => "degree",
                        AngleUnit::gon => "gon",
                        AngleUnit::mil => "mil",
                        AngleUnit::minute => "minute",
                        AngleUnit::second => "second",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for AngleUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for AngleUnit {
            #[inline]
            fn eq(&self, other: &AngleUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for AngleUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for AngleUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const ANGLE_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const ANGLE_RADIAN_CONVERSION: f64 = 1.0_E0;
        pub(crate) const ANGLE_REVOLUTION_CONVERSION: f64 =
            6.283_185_307_179_586_E0;
        pub(crate) const ANGLE_DEGREE_CONVERSION: f64 =
            1.745_329_251_994_329_5_E-2;
        pub(crate) const ANGLE_GON_CONVERSION: f64 =
            1.570_796_326_794_896_7_E-2;
        pub(crate) const ANGLE_MIL_CONVERSION: f64 = 9.817_477_E-4;
        pub(crate) const ANGLE_MINUTE_CONVERSION: f64 =
            2.908_882_086_657_216_E-4;
        pub(crate) const ANGLE_SECOND_CONVERSION: f64 =
            4.848_136_811_095_36_E-6;
        impl AngleUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_radian() -> UnitDefinition {
                UnitDefinition {
                    base: ANGLE_UNIT_BASE,
                    multiplier: ANGLE_RADIAN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_revolution() -> UnitDefinition {
                UnitDefinition {
                    base: ANGLE_UNIT_BASE,
                    multiplier: ANGLE_REVOLUTION_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_degree() -> UnitDefinition {
                UnitDefinition {
                    base: ANGLE_UNIT_BASE,
                    multiplier: ANGLE_DEGREE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gon() -> UnitDefinition {
                UnitDefinition {
                    base: ANGLE_UNIT_BASE,
                    multiplier: ANGLE_GON_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_mil() -> UnitDefinition {
                UnitDefinition {
                    base: ANGLE_UNIT_BASE,
                    multiplier: ANGLE_MIL_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_minute() -> UnitDefinition {
                UnitDefinition {
                    base: ANGLE_UNIT_BASE,
                    multiplier: ANGLE_MINUTE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_second() -> UnitDefinition {
                UnitDefinition {
                    base: ANGLE_UNIT_BASE,
                    multiplier: ANGLE_SECOND_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    AngleUnit::radian => ANGLE_RADIAN_CONVERSION,
                    AngleUnit::revolution => ANGLE_REVOLUTION_CONVERSION,
                    AngleUnit::degree => ANGLE_DEGREE_CONVERSION,
                    AngleUnit::gon => ANGLE_GON_CONVERSION,
                    AngleUnit::mil => ANGLE_MIL_CONVERSION,
                    AngleUnit::minute => ANGLE_MINUTE_CONVERSION,
                    AngleUnit::second => ANGLE_SECOND_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    AngleUnit::radian => "rad",
                    AngleUnit::revolution => "r",
                    AngleUnit::degree => "",
                    AngleUnit::gon => "gon",
                    AngleUnit::mil => "mil",
                    AngleUnit::minute => "",
                    AngleUnit::second => "",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    AngleUnit::radian => "radian",
                    AngleUnit::revolution => "revolution",
                    AngleUnit::degree => "degree",
                    AngleUnit::gon => "gon",
                    AngleUnit::mil => "mil",
                    AngleUnit::minute => "minute",
                    AngleUnit::second => "second",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    AngleUnit::radian => "radians",
                    AngleUnit::revolution => "revolutions",
                    AngleUnit::degree => "degrees",
                    AngleUnit::gon => "gons",
                    AngleUnit::mil => "mils",
                    AngleUnit::minute => "minutes",
                    AngleUnit::second => "seconds",
                }
            }
            #[doc = "Available units for this `[AngleUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["radian", "revolution", "degree", "gon", "mil", "minute",
                                "second"];
                UNITS
            }
        }
        impl crate::traits::Unit for AngleUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    AngleUnit::radian => AngleUnit::get_radian(),
                    AngleUnit::revolution => AngleUnit::get_revolution(),
                    AngleUnit::degree => AngleUnit::get_degree(),
                    AngleUnit::gon => AngleUnit::get_gon(),
                    AngleUnit::mil => AngleUnit::get_mil(),
                    AngleUnit::minute => AngleUnit::get_minute(),
                    AngleUnit::second => AngleUnit::get_second(),
                }
            }
            #[inline]
            fn base() -> UnitBase { ANGLE_UNIT_BASE }
        }
        impl From<AngleUnit> for crate::Units {
            fn from(value: AngleUnit) -> Self {
                match value {
                    AngleUnit::radian => crate::Units::Angle(AngleUnit::radian),
                    AngleUnit::revolution =>
                        crate::Units::Angle(AngleUnit::revolution),
                    AngleUnit::degree => crate::Units::Angle(AngleUnit::degree),
                    AngleUnit::gon => crate::Units::Angle(AngleUnit::gon),
                    AngleUnit::mil => crate::Units::Angle(AngleUnit::mil),
                    AngleUnit::minute => crate::Units::Angle(AngleUnit::minute),
                    AngleUnit::second => crate::Units::Angle(AngleUnit::second),
                }
            }
        }
        impl TryFrom<UnitDefinition> for AngleUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: ANGLE_UNIT_BASE, multiplier: ANGLE_RADIAN_CONVERSION }
                        => Ok(AngleUnit::radian),
                    UnitDefinition {
                        base: ANGLE_UNIT_BASE,
                        multiplier: ANGLE_REVOLUTION_CONVERSION } =>
                        Ok(AngleUnit::revolution),
                    UnitDefinition {
                        base: ANGLE_UNIT_BASE, multiplier: ANGLE_DEGREE_CONVERSION }
                        => Ok(AngleUnit::degree),
                    UnitDefinition {
                        base: ANGLE_UNIT_BASE, multiplier: ANGLE_GON_CONVERSION } =>
                        Ok(AngleUnit::gon),
                    UnitDefinition {
                        base: ANGLE_UNIT_BASE, multiplier: ANGLE_MIL_CONVERSION } =>
                        Ok(AngleUnit::mil),
                    UnitDefinition {
                        base: ANGLE_UNIT_BASE, multiplier: ANGLE_MINUTE_CONVERSION }
                        => Ok(AngleUnit::minute),
                    UnitDefinition {
                        base: ANGLE_UNIT_BASE, multiplier: ANGLE_SECOND_CONVERSION }
                        => Ok(AngleUnit::second),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "Angle"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for AngleUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::Angle(AngleUnit::radian) =>
                        Ok(AngleUnit::radian),
                    crate::Units::Angle(AngleUnit::revolution) =>
                        Ok(AngleUnit::revolution),
                    crate::Units::Angle(AngleUnit::degree) =>
                        Ok(AngleUnit::degree),
                    crate::Units::Angle(AngleUnit::gon) => Ok(AngleUnit::gon),
                    crate::Units::Angle(AngleUnit::mil) => Ok(AngleUnit::mil),
                    crate::Units::Angle(AngleUnit::minute) =>
                        Ok(AngleUnit::minute),
                    crate::Units::Angle(AngleUnit::second) =>
                        Ok(AngleUnit::second),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "Angle"));
                                        res
                                    }))),
                }
            }
        }
        impl From<Angle> for crate::Units {
            fn from(value: Angle) -> Self { crate::Units::Angle(value.unit) }
        }
        impl From<&Angle> for crate::Units {
            fn from(value: &Angle) -> Self { crate::Units::Angle(value.unit) }
        }
        impl From<AngleVec> for crate::Units {
            fn from(value: AngleVec) -> Self {
                crate::Units::Angle(value.unit)
            }
        }
        impl From<&AngleVec> for crate::Units {
            fn from(value: &AngleVec) -> Self {
                crate::Units::Angle(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Angle (dimensionless quantity)."]
        #[schema(title = "Angle")]
        #[doc = "Scalar storage of a quantity (f64 and [`AngleUnit`])."]
        pub struct Angle {
            pub(crate) value: f64,
            pub(crate) unit: AngleUnit,
        }
        impl utoipa::__dev::ComposeSchema for Angle {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <AngleUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("Angle")).description(Some(" Angle (dimensionless quantity).\nScalar storage of a quantity (f64 and [`AngleUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for Angle {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("Angle")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <AngleUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <AngleUnit as utoipa::PartialSchema>::schema())]);
                <AngleUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Angle {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer, "Angle",
                                    false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Angle {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Angle>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Angle;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct Angle")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct Angle with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<AngleUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct Angle with 2 elements")),
                                    };
                                _serde::__private::Ok(Angle {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<AngleUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<AngleUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(Angle {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "Angle", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Angle>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for Angle { }
        #[automatically_derived]
        impl ::core::clone::Clone for Angle {
            #[inline]
            fn clone(&self) -> Angle {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _: ::core::clone::AssertParamIsClone<AngleUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Angle {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f, "Angle",
                    "value", &self.value, "unit", &&self.unit)
            }
        }
        impl Angle {
            #[doc = "Create a new [`AngleUnit`]."]
            pub fn new(value: f64, unit: AngleUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::radian`]."]
            pub fn radian(value: f64) -> Self {
                Self { value, unit: AngleUnit::radian.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::revolution`]."]
            pub fn revolution(value: f64) -> Self {
                Self { value, unit: AngleUnit::revolution.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::degree`]."]
            pub fn degree(value: f64) -> Self {
                Self { value, unit: AngleUnit::degree.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::gon`]."]
            pub fn gon(value: f64) -> Self {
                Self { value, unit: AngleUnit::gon.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::mil`]."]
            pub fn mil(value: f64) -> Self {
                Self { value, unit: AngleUnit::mil.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::minute`]."]
            pub fn minute(value: f64) -> Self {
                Self { value, unit: AngleUnit::minute.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::second`]."]
            pub fn second(value: f64) -> Self {
                Self { value, unit: AngleUnit::second.into() }
            }
            #[doc = "Retrieve the value associated with this [`Angle`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`Angle`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`Angle`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`AngleUnit::radian`]."]
            #[inline]
            pub fn to_radian(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (ANGLE_RADIAN_CONVERSION))
                            as f64,
                    unit: AngleUnit::radian,
                }
            }
            #[doc = "Convert to [`AngleUnit::revolution`]."]
            #[inline]
            pub fn to_revolution(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ANGLE_REVOLUTION_CONVERSION)) as f64,
                    unit: AngleUnit::revolution,
                }
            }
            #[doc = "Convert to [`AngleUnit::degree`]."]
            #[inline]
            pub fn to_degree(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (ANGLE_DEGREE_CONVERSION))
                            as f64,
                    unit: AngleUnit::degree,
                }
            }
            #[doc = "Convert to [`AngleUnit::gon`]."]
            #[inline]
            pub fn to_gon(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (ANGLE_GON_CONVERSION)) as
                            f64,
                    unit: AngleUnit::gon,
                }
            }
            #[doc = "Convert to [`AngleUnit::mil`]."]
            #[inline]
            pub fn to_mil(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (ANGLE_MIL_CONVERSION)) as
                            f64,
                    unit: AngleUnit::mil,
                }
            }
            #[doc = "Convert to [`AngleUnit::minute`]."]
            #[inline]
            pub fn to_minute(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (ANGLE_MINUTE_CONVERSION))
                            as f64,
                    unit: AngleUnit::minute,
                }
            }
            #[doc = "Convert to [`AngleUnit::second`]."]
            #[inline]
            pub fn to_second(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (ANGLE_SECOND_CONVERSION))
                            as f64,
                    unit: AngleUnit::second,
                }
            }
        }
        impl FixedQuantity<AngleUnit> for Angle {
            #[inline]
            fn unit(&self) -> AngleUnit { self.unit }
            #[inline]
            fn convert(&self, unit: AngleUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: AngleUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut AngleUnit { &mut self.unit }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: AngleUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<Angle> for UnitDefinition {
            #[inline]
            fn from(value: Angle) -> Self {
                match value.unit {
                    AngleUnit::radian => AngleUnit::get_radian(),
                    AngleUnit::revolution => AngleUnit::get_revolution(),
                    AngleUnit::degree => AngleUnit::get_degree(),
                    AngleUnit::gon => AngleUnit::get_gon(),
                    AngleUnit::mil => AngleUnit::get_mil(),
                    AngleUnit::minute => AngleUnit::get_minute(),
                    AngleUnit::second => AngleUnit::get_second(),
                }
            }
        }
        impl From<Angle> for Quantity {
            fn from(quantity: Angle) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for Angle {
            fn from(quantity: Quantity) -> Angle {
                Angle {
                    value: quantity.value,
                    unit: AngleUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for Angle {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl AngleVec {
            #[doc = "Create a new vector of [`AngleUnit`]."]
            pub fn new(values: Vec<f64>, unit: AngleUnit) -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc = "Retrieve values associated with this [`AngleSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`AngleSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::radian`]."]
            pub fn radian(values: Vec<f64>) -> Self {
                Self { values, unit: AngleUnit::radian.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::revolution`]."]
            pub fn revolution(values: Vec<f64>) -> Self {
                Self { values, unit: AngleUnit::revolution.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::degree`]."]
            pub fn degree(values: Vec<f64>) -> Self {
                Self { values, unit: AngleUnit::degree.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::gon`]."]
            pub fn gon(values: Vec<f64>) -> Self {
                Self { values, unit: AngleUnit::gon.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::mil`]."]
            pub fn mil(values: Vec<f64>) -> Self {
                Self { values, unit: AngleUnit::mil.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::minute`]."]
            pub fn minute(values: Vec<f64>) -> Self {
                Self { values, unit: AngleUnit::minute.into() }
            }
            #[doc =
            "Create a new [`Angle`] with units of [`AngleUnit::second`]."]
            pub fn second(values: Vec<f64>) -> Self {
                Self { values, unit: AngleUnit::second.into() }
            }
            #[doc = "Convert to [`AngleUnit::radian`]."]
            #[inline]
            pub fn to_radian(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AngleUnit::radian);
                r
            }
            #[doc = "Convert to [`AngleUnit::revolution`]."]
            #[inline]
            pub fn to_revolution(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AngleUnit::revolution);
                r
            }
            #[doc = "Convert to [`AngleUnit::degree`]."]
            #[inline]
            pub fn to_degree(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AngleUnit::degree);
                r
            }
            #[doc = "Convert to [`AngleUnit::gon`]."]
            #[inline]
            pub fn to_gon(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AngleUnit::gon);
                r
            }
            #[doc = "Convert to [`AngleUnit::mil`]."]
            #[inline]
            pub fn to_mil(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AngleUnit::mil);
                r
            }
            #[doc = "Convert to [`AngleUnit::minute`]."]
            #[inline]
            pub fn to_minute(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AngleUnit::minute);
                r
            }
            #[doc = "Convert to [`AngleUnit::second`]."]
            #[inline]
            pub fn to_second(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(AngleUnit::second);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for Angle {
            type Output = Angle;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for Angle {
            type Output = Angle;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for Angle {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for Angle {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for Angle {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<Angle> for Quantity {
            fn eq(&self, other: &Angle) -> bool { *other == *self }
        }
        impl PartialEq<Angle> for Angle {
            fn eq(&self, other: &Angle) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for Angle {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for Angle {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<Angle> for Angle {
            type Output = Self;
            fn add(self, rhs: Angle) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Angle> for Angle {
            type Output = Self;
            fn sub(self, rhs: Angle) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for Angle {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for Angle {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for Angle {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for Angle {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for Angle {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for Angle {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc = "Array storage for a series of values and [`AngleUnit`]."]
        pub struct AngleArray<const N : usize> {
            pub(crate) unit: AngleUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for AngleArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <AngleUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`AngleUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for AngleArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("AngleArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <AngleUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <AngleUnit as utoipa::PartialSchema>::schema())]);
                <AngleUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for AngleArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "AngleArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<AngleArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<AngleArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    AngleArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<AngleArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = AngleArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct AngleArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<AngleUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct AngleArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<AngleArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct AngleArray with 2 elements")),
                                    };
                                _serde::__private::Ok(AngleArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<AngleUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<AngleUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<AngleArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(AngleArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "AngleArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<AngleArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for AngleArray<N> { }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for AngleArray<N> {
            #[inline]
            fn clone(&self) -> AngleArray<N> {
                let _: ::core::clone::AssertParamIsClone<AngleUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for AngleArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "AngleArray", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            AngleArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for AngleArray<N> {
            #[inline]
            fn eq(&self, other: &AngleArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for AngleArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for AngleArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc = "Vector storage for a series of values and [`AngleUnit`]."]
        pub struct AngleVec {
            pub(crate) unit: AngleUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for AngleVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <AngleUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`AngleUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for AngleVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("AngleVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <AngleUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <AngleUnit as utoipa::PartialSchema>::schema())]);
                <AngleUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AngleVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "AngleVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for AngleVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<AngleVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = AngleVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct AngleVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<AngleUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct AngleVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct AngleVec with 2 elements")),
                                    };
                                _serde::__private::Ok(AngleVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<AngleUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<AngleUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(AngleVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "AngleVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<AngleVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for AngleVec {
            #[inline]
            fn clone(&self) -> AngleVec {
                AngleVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AngleVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "AngleVec", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AngleVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AngleVec {
            #[inline]
            fn eq(&self, other: &AngleVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for AngleVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for AngleVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<AngleUnit, f64> for AngleVec {
            fn unit(&self) -> AngleUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: AngleUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: AngleUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: AngleUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize>
            crate::traits::FixedSliceQuantity<AngleUnit, f64> for
            AngleArray<N> {
            fn unit(&self) -> AngleUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: AngleUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: AngleUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: AngleUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for AngleVec {
            type Output = AngleVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for AngleVec {
            type Output = AngleVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for AngleVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for AngleVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<AngleVec> for AngleVec {
            fn add_assign(&mut self, rhs: AngleVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<AngleVec> for AngleVec {
            fn sub_assign(&mut self, rhs: AngleVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for AngleArray<N> {
            type Output = AngleArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for AngleArray<N> {
            type Output = AngleArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for AngleArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for AngleArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<AngleArray<N>> for AngleArray<N> {
            fn add_assign(&mut self, rhs: AngleArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<AngleArray<N>> for AngleArray<N> {
            fn sub_assign(&mut self, rhs: AngleArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<AngleVec> for VecQuantity {
            fn from(input: AngleVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<AngleUnit> for UnitDefinition {
            #[inline]
            fn from(value: AngleUnit) -> Self {
                match value {
                    AngleUnit::radian => AngleUnit::get_radian(),
                    AngleUnit::revolution => AngleUnit::get_revolution(),
                    AngleUnit::degree => AngleUnit::get_degree(),
                    AngleUnit::gon => AngleUnit::get_gon(),
                    AngleUnit::mil => AngleUnit::get_mil(),
                    AngleUnit::minute => AngleUnit::get_minute(),
                    AngleUnit::second => AngleUnit::get_second(),
                }
            }
        }
        impl TryFrom<&str> for AngleUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<AngleUnit> =
                    match value {
                        "rad" => Some(AngleUnit::radian),
                        "r" => Some(AngleUnit::revolution),
                        "" => Some(AngleUnit::degree),
                        "gon" => Some(AngleUnit::gon),
                        "mil" => Some(AngleUnit::mil),
                        "" => Some(AngleUnit::minute),
                        "" => Some(AngleUnit::second),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<AngleUnit> =
                    match value {
                        "radian" => Some(AngleUnit::radian),
                        "revolution" => Some(AngleUnit::revolution),
                        "degree" => Some(AngleUnit::degree),
                        "gon" => Some(AngleUnit::gon),
                        "mil" => Some(AngleUnit::mil),
                        "minute" => Some(AngleUnit::minute),
                        "second" => Some(AngleUnit::second),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<AngleUnit> =
                    match value {
                        "radians" => Some(AngleUnit::radian),
                        "revolutions" => Some(AngleUnit::revolution),
                        "degrees" => Some(AngleUnit::degree),
                        "gons" => Some(AngleUnit::gon),
                        "mils" => Some(AngleUnit::mil),
                        "minutes" => Some(AngleUnit::minute),
                        "seconds" => Some(AngleUnit::second),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"Angle\"")
                   }
            }
        }
        impl core::fmt::Display for AngleUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    AngleUnit::radian =>
                        f.write_fmt(format_args!("{0}", "radian")),
                    AngleUnit::revolution =>
                        f.write_fmt(format_args!("{0}", "revolution")),
                    AngleUnit::degree =>
                        f.write_fmt(format_args!("{0}", "degree")),
                    AngleUnit::gon => f.write_fmt(format_args!("{0}", "gon")),
                    AngleUnit::mil => f.write_fmt(format_args!("{0}", "mil")),
                    AngleUnit::minute =>
                        f.write_fmt(format_args!("{0}", "minute")),
                    AngleUnit::second =>
                        f.write_fmt(format_args!("{0}", "second")),
                }
            }
        }
        #[cfg(feature="Angle")]
        impl Angle {
            /// Computes the value of the cosine of the angle.
            #[must_use =
            "method returns a new number and does not mutate the original value"]
            #[inline(always)]
            pub fn cos(self) -> f64 {
                self.convert_unchecked(AngleUnit::get_radian()).cos()
            }
            /// Computes the value of the hyperbolic cosine of the angle.
            #[must_use =
            "method returns a new number and does not mutate the original value"]
            #[inline(always)]
            pub fn cosh(self) -> f64 {
                self.convert_unchecked(AngleUnit::get_radian()).cosh()
            }
            /// Computes the value of the sine of the angle.
            #[must_use =
            "method returns a new number and does not mutate the original value"]
            #[inline(always)]
            pub fn sin(self) -> f64 {
                self.convert_unchecked(AngleUnit::get_radian()).sin()
            }
            /// Computes the value of the hyperbolic sine of the angle.
            #[must_use =
            "method returns a new number and does not mutate the original value"]
            #[inline(always)]
            pub fn sinh(self) -> f64 {
                self.convert_unchecked(AngleUnit::get_radian()).sinh()
            }
            /// Computes the value of both the sine and cosine of the angle.
            #[must_use =
            "method returns a new number and does not mutate the original value"]
            #[inline(always)]
            pub fn sin_cos(self) -> (f64, f64) {
                let (sin, cos) =
                    self.convert_unchecked(AngleUnit::get_radian()).sin_cos();
                (sin.into(), cos.into())
            }
            /// Computes the value of the tangent of the angle.
            #[must_use =
            "method returns a new number and does not mutate the original value"]
            #[inline(always)]
            pub fn tan(self) -> f64 {
                self.convert_unchecked(AngleUnit::get_radian()).tan()
            }
            /// Computes the value of the hyperbolic tangent of the angle.
            #[must_use =
            "method returns a new number and does not mutate the original value"]
            #[inline(always)]
            pub fn tanh(self) -> f64 {
                self.convert_unchecked(AngleUnit::get_radian()).tanh()
            }
        }
    }
    #[cfg(any(feature = "Angle", feature = "All"))]
    pub use crate::unit_definitions::angle::AngleArray;
    #[cfg(any(feature = "Angle", feature = "All"))]
    pub use crate::unit_definitions::angle::Angle;
    #[cfg(any(feature = "Angle", feature = "All"))]
    pub use crate::unit_definitions::angle::AngleVec;
    #[cfg(any(feature = "Dimensionless", feature = "All"))]
    mod dimensionless {
        //! Dimensionless (dimensionless quantity).
        use crate::quantity;
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Dimensionless (dimensionless quantity)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "DimensionlessUnit")]
        pub enum DimensionlessUnit { scalar, }
        impl utoipa::__dev::ComposeSchema for DimensionlessUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 1usize],
                                &str>(Some(["scalar"])).title(Some("DimensionlessUnit")).description(Some("Dimensionless (dimensionless quantity).")).into()
            }
        }
        impl utoipa::ToSchema for DimensionlessUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("DimensionlessUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DimensionlessUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            DimensionlessUnit::scalar =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "DimensionlessUnit", 0u32, "scalar"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DimensionlessUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 1")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "scalar" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"scalar" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<DimensionlessUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DimensionlessUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum DimensionlessUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(DimensionlessUnit::scalar)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &["scalar"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "DimensionlessUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<DimensionlessUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for DimensionlessUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for DimensionlessUnit {
            #[inline]
            fn clone(&self) -> DimensionlessUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for DimensionlessUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "scalar")
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for DimensionlessUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for DimensionlessUnit {
            #[inline]
            fn eq(&self, other: &DimensionlessUnit) -> bool { true }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for DimensionlessUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for DimensionlessUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H)
                -> () {}
        }
        pub(crate) const DIMENSIONLESS_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const DIMENSIONLESS_SCALAR_CONVERSION: f64 = 1.0;
        impl DimensionlessUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_scalar() -> UnitDefinition {
                UnitDefinition {
                    base: DIMENSIONLESS_UNIT_BASE,
                    multiplier: DIMENSIONLESS_SCALAR_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    DimensionlessUnit::scalar =>
                        DIMENSIONLESS_SCALAR_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self { DimensionlessUnit::scalar => "scalar", }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self { DimensionlessUnit::scalar => "scalar", }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self { DimensionlessUnit::scalar => "scalars", }
            }
            #[doc = "Available units for this `[DimensionlessUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] = &["scalar"];
                UNITS
            }
        }
        impl crate::traits::Unit for DimensionlessUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    DimensionlessUnit::scalar =>
                        DimensionlessUnit::get_scalar(),
                }
            }
            #[inline]
            fn base() -> UnitBase { DIMENSIONLESS_UNIT_BASE }
        }
        impl From<DimensionlessUnit> for crate::Units {
            fn from(value: DimensionlessUnit) -> Self {
                match value {
                    DimensionlessUnit::scalar =>
                        crate::Units::Dimensionless(DimensionlessUnit::scalar),
                }
            }
        }
        impl TryFrom<UnitDefinition> for DimensionlessUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: DIMENSIONLESS_UNIT_BASE,
                        multiplier: DIMENSIONLESS_SCALAR_CONVERSION } =>
                        Ok(DimensionlessUnit::scalar),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "Dimensionless"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for DimensionlessUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::Dimensionless(DimensionlessUnit::scalar) =>
                        Ok(DimensionlessUnit::scalar),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "Dimensionless"));
                                        res
                                    }))),
                }
            }
        }
        impl From<Dimensionless> for crate::Units {
            fn from(value: Dimensionless) -> Self {
                crate::Units::Dimensionless(value.unit)
            }
        }
        impl From<&Dimensionless> for crate::Units {
            fn from(value: &Dimensionless) -> Self {
                crate::Units::Dimensionless(value.unit)
            }
        }
        impl From<DimensionlessVec> for crate::Units {
            fn from(value: DimensionlessVec) -> Self {
                crate::Units::Dimensionless(value.unit)
            }
        }
        impl From<&DimensionlessVec> for crate::Units {
            fn from(value: &DimensionlessVec) -> Self {
                crate::Units::Dimensionless(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Dimensionless (dimensionless quantity)."]
        #[schema(title = "Dimensionless")]
        #[doc =
        "Scalar storage of a quantity (f64 and [`DimensionlessUnit`])."]
        pub struct Dimensionless {
            pub(crate) value: f64,
            pub(crate) unit: DimensionlessUnit,
        }
        impl utoipa::__dev::ComposeSchema for Dimensionless {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <DimensionlessUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("Dimensionless")).description(Some(" Dimensionless (dimensionless quantity).\nScalar storage of a quantity (f64 and [`DimensionlessUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for Dimensionless {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("Dimensionless")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <DimensionlessUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <DimensionlessUnit as utoipa::PartialSchema>::schema())]);
                <DimensionlessUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Dimensionless {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "Dimensionless", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Dimensionless {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Dimensionless>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Dimensionless;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct Dimensionless")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct Dimensionless with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<DimensionlessUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct Dimensionless with 2 elements")),
                                    };
                                _serde::__private::Ok(Dimensionless {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1:
                                        _serde::__private::Option<DimensionlessUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<DimensionlessUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(Dimensionless {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "Dimensionless", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Dimensionless>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for Dimensionless { }
        #[automatically_derived]
        impl ::core::clone::Clone for Dimensionless {
            #[inline]
            fn clone(&self) -> Dimensionless {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _: ::core::clone::AssertParamIsClone<DimensionlessUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Dimensionless {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "Dimensionless", "value", &self.value, "unit", &&self.unit)
            }
        }
        impl Dimensionless {
            #[doc = "Create a new [`DimensionlessUnit`]."]
            pub fn new(value: f64, unit: DimensionlessUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`Dimensionless`] with units of [`DimensionlessUnit::scalar`]."]
            pub fn scalar(value: f64) -> Self {
                Self { value, unit: DimensionlessUnit::scalar.into() }
            }
            #[doc =
            "Retrieve the value associated with this [`Dimensionless`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`Dimensionless`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`Dimensionless`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`DimensionlessUnit::scalar`]."]
            #[inline]
            pub fn to_scalar(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (DIMENSIONLESS_SCALAR_CONVERSION)) as f64,
                    unit: DimensionlessUnit::scalar,
                }
            }
        }
        impl FixedQuantity<DimensionlessUnit> for Dimensionless {
            #[inline]
            fn unit(&self) -> DimensionlessUnit { self.unit }
            #[inline]
            fn convert(&self, unit: DimensionlessUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: DimensionlessUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut DimensionlessUnit {
                &mut self.unit
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: DimensionlessUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<Dimensionless> for UnitDefinition {
            #[inline]
            fn from(value: Dimensionless) -> Self {
                match value.unit {
                    DimensionlessUnit::scalar =>
                        DimensionlessUnit::get_scalar(),
                }
            }
        }
        impl From<Dimensionless> for Quantity {
            fn from(quantity: Dimensionless) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for Dimensionless {
            fn from(quantity: Quantity) -> Dimensionless {
                Dimensionless {
                    value: quantity.value,
                    unit: DimensionlessUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for Dimensionless {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl DimensionlessVec {
            #[doc = "Create a new vector of [`DimensionlessUnit`]."]
            pub fn new(values: Vec<f64>, unit: DimensionlessUnit) -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc =
            "Retrieve values associated with this [`DimensionlessSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`DimensionlessSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`Dimensionless`] with units of [`DimensionlessUnit::scalar`]."]
            pub fn scalar(values: Vec<f64>) -> Self {
                Self { values, unit: DimensionlessUnit::scalar.into() }
            }
            #[doc = "Convert to [`DimensionlessUnit::scalar`]."]
            #[inline]
            pub fn to_scalar(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(DimensionlessUnit::scalar);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for Dimensionless {
            type Output = Dimensionless;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for Dimensionless {
            type Output = Dimensionless;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for Dimensionless {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for Dimensionless {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for Dimensionless {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<Dimensionless> for Quantity {
            fn eq(&self, other: &Dimensionless) -> bool { *other == *self }
        }
        impl PartialEq<Dimensionless> for Dimensionless {
            fn eq(&self, other: &Dimensionless) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for Dimensionless {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for Dimensionless {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<Dimensionless> for Dimensionless {
            type Output = Self;
            fn add(self, rhs: Dimensionless) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Dimensionless> for Dimensionless {
            type Output = Self;
            fn sub(self, rhs: Dimensionless) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for Dimensionless {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for Dimensionless {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for Dimensionless {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for Dimensionless {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for Dimensionless {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for Dimensionless {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc =
        "Array storage for a series of values and [`DimensionlessUnit`]."]
        pub struct DimensionlessArray<const N : usize> {
            pub(crate) unit: DimensionlessUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for
            DimensionlessArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <DimensionlessUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`DimensionlessUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for DimensionlessArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("DimensionlessArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <DimensionlessUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <DimensionlessUnit as utoipa::PartialSchema>::schema())]);
                <DimensionlessUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for
                    DimensionlessArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "DimensionlessArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<DimensionlessArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<DimensionlessArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    DimensionlessArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<DimensionlessArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = DimensionlessArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct DimensionlessArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<DimensionlessUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct DimensionlessArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<DimensionlessArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct DimensionlessArray with 2 elements")),
                                    };
                                _serde::__private::Ok(DimensionlessArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<DimensionlessUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<DimensionlessUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<DimensionlessArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(DimensionlessArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "DimensionlessArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<DimensionlessArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for DimensionlessArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for DimensionlessArray<N> {
            #[inline]
            fn clone(&self) -> DimensionlessArray<N> {
                let _: ::core::clone::AssertParamIsClone<DimensionlessUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for DimensionlessArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "DimensionlessArray", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            DimensionlessArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for DimensionlessArray<N>
            {
            #[inline]
            fn eq(&self, other: &DimensionlessArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for DimensionlessArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for DimensionlessArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc =
        "Vector storage for a series of values and [`DimensionlessUnit`]."]
        pub struct DimensionlessVec {
            pub(crate) unit: DimensionlessUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for DimensionlessVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <DimensionlessUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`DimensionlessUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for DimensionlessVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("DimensionlessVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <DimensionlessUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <DimensionlessUnit as utoipa::PartialSchema>::schema())]);
                <DimensionlessUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DimensionlessVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "DimensionlessVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DimensionlessVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<DimensionlessVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DimensionlessVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct DimensionlessVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<DimensionlessUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct DimensionlessVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct DimensionlessVec with 2 elements")),
                                    };
                                _serde::__private::Ok(DimensionlessVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<DimensionlessUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<DimensionlessUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(DimensionlessVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "DimensionlessVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<DimensionlessVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for DimensionlessVec {
            #[inline]
            fn clone(&self) -> DimensionlessVec {
                DimensionlessVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DimensionlessVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "DimensionlessVec", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DimensionlessVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DimensionlessVec {
            #[inline]
            fn eq(&self, other: &DimensionlessVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for DimensionlessVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for DimensionlessVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<DimensionlessUnit, f64> for
            DimensionlessVec {
            fn unit(&self) -> DimensionlessUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: DimensionlessUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: DimensionlessUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: DimensionlessUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize>
            crate::traits::FixedSliceQuantity<DimensionlessUnit, f64> for
            DimensionlessArray<N> {
            fn unit(&self) -> DimensionlessUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: DimensionlessUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: DimensionlessUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: DimensionlessUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for DimensionlessVec {
            type Output = DimensionlessVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for DimensionlessVec {
            type Output = DimensionlessVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for DimensionlessVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for DimensionlessVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<DimensionlessVec> for DimensionlessVec {
            fn add_assign(&mut self, rhs: DimensionlessVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<DimensionlessVec> for DimensionlessVec {
            fn sub_assign(&mut self, rhs: DimensionlessVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for DimensionlessArray<N> {
            type Output = DimensionlessArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for DimensionlessArray<N> {
            type Output = DimensionlessArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for DimensionlessArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for DimensionlessArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<DimensionlessArray<N>> for
            DimensionlessArray<N> {
            fn add_assign(&mut self, rhs: DimensionlessArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<DimensionlessArray<N>> for
            DimensionlessArray<N> {
            fn sub_assign(&mut self, rhs: DimensionlessArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<DimensionlessVec> for VecQuantity {
            fn from(input: DimensionlessVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<DimensionlessUnit> for UnitDefinition {
            #[inline]
            fn from(value: DimensionlessUnit) -> Self {
                match value {
                    DimensionlessUnit::scalar =>
                        DimensionlessUnit::get_scalar(),
                }
            }
        }
        impl TryFrom<&str> for DimensionlessUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<DimensionlessUnit> =
                    match value {
                        "scalar" => Some(DimensionlessUnit::scalar),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<DimensionlessUnit> =
                    match value {
                        "scalar" => Some(DimensionlessUnit::scalar),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<DimensionlessUnit> =
                    match value {
                        "scalars" => Some(DimensionlessUnit::scalar),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"Dimensionless\"")
                   }
            }
        }
        impl core::fmt::Display for DimensionlessUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    DimensionlessUnit::scalar =>
                        f.write_fmt(format_args!("{0}", "scalar")),
                }
            }
        }
    }
    #[cfg(any(feature = "Dimensionless", feature = "All"))]
    pub use crate::unit_definitions::dimensionless::DimensionlessArray;
    #[cfg(any(feature = "Dimensionless", feature = "All"))]
    pub use crate::unit_definitions::dimensionless::Dimensionless;
    #[cfg(any(feature = "Dimensionless", feature = "All"))]
    pub use crate::unit_definitions::dimensionless::DimensionlessVec;
    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
    mod electric_current {
        //! Electric current (base UnitDefinition ampere, A).
        use crate::{prefix, quantity};
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Electric current (base UnitDefinition ampere, A)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "ElectricCurrentUnit")]
        pub enum ElectricCurrentUnit {
            yottaampere,
            zettaampere,
            exaampere,
            petaampere,
            teraampere,
            gigaampere,
            megaampere,
            kiloampere,
            hectoampere,
            decaampere,
            ampere,
            deciampere,
            centiampere,
            milliampere,
            microampere,
            nanoampere,
            picoampere,
            femtoampere,
            attoampere,
            zeptoampere,
            yoctoampere,
            elementary_charge_per_second,
            atomic_unit_of_charge_per_second,
            abampere,
            gilbert,
            statampere,
        }
        impl utoipa::__dev::ComposeSchema for ElectricCurrentUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 26usize],
                                &str>(Some(["yottaampere", "zettaampere", "exaampere",
                                            "petaampere", "teraampere", "gigaampere", "megaampere",
                                            "kiloampere", "hectoampere", "decaampere", "ampere",
                                            "deciampere", "centiampere", "milliampere", "microampere",
                                            "nanoampere", "picoampere", "femtoampere", "attoampere",
                                            "zeptoampere", "yoctoampere",
                                            "elementary_charge_per_second",
                                            "atomic_unit_of_charge_per_second", "abampere", "gilbert",
                                            "statampere"])).title(Some("ElectricCurrentUnit")).description(Some("Electric current (base UnitDefinition ampere, A).")).into()
            }
        }
        impl utoipa::ToSchema for ElectricCurrentUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("ElectricCurrentUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ElectricCurrentUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            ElectricCurrentUnit::yottaampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 0u32, "yottaampere"),
                            ElectricCurrentUnit::zettaampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 1u32, "zettaampere"),
                            ElectricCurrentUnit::exaampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 2u32, "exaampere"),
                            ElectricCurrentUnit::petaampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 3u32, "petaampere"),
                            ElectricCurrentUnit::teraampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 4u32, "teraampere"),
                            ElectricCurrentUnit::gigaampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 5u32, "gigaampere"),
                            ElectricCurrentUnit::megaampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 6u32, "megaampere"),
                            ElectricCurrentUnit::kiloampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 7u32, "kiloampere"),
                            ElectricCurrentUnit::hectoampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 8u32, "hectoampere"),
                            ElectricCurrentUnit::decaampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 9u32, "decaampere"),
                            ElectricCurrentUnit::ampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 10u32, "ampere"),
                            ElectricCurrentUnit::deciampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 11u32, "deciampere"),
                            ElectricCurrentUnit::centiampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 12u32, "centiampere"),
                            ElectricCurrentUnit::milliampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 13u32, "milliampere"),
                            ElectricCurrentUnit::microampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 14u32, "microampere"),
                            ElectricCurrentUnit::nanoampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 15u32, "nanoampere"),
                            ElectricCurrentUnit::picoampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 16u32, "picoampere"),
                            ElectricCurrentUnit::femtoampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 17u32, "femtoampere"),
                            ElectricCurrentUnit::attoampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 18u32, "attoampere"),
                            ElectricCurrentUnit::zeptoampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 19u32, "zeptoampere"),
                            ElectricCurrentUnit::yoctoampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 20u32, "yoctoampere"),
                            ElectricCurrentUnit::elementary_charge_per_second =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 21u32,
                                    "elementary_charge_per_second"),
                            ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 22u32,
                                    "atomic_unit_of_charge_per_second"),
                            ElectricCurrentUnit::abampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 23u32, "abampere"),
                            ElectricCurrentUnit::gilbert =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 24u32, "gilbert"),
                            ElectricCurrentUnit::statampere =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "ElectricCurrentUnit", 25u32, "statampere"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ElectricCurrentUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                            __field24,
                            __field25,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    17u64 => _serde::__private::Ok(__Field::__field17),
                                    18u64 => _serde::__private::Ok(__Field::__field18),
                                    19u64 => _serde::__private::Ok(__Field::__field19),
                                    20u64 => _serde::__private::Ok(__Field::__field20),
                                    21u64 => _serde::__private::Ok(__Field::__field21),
                                    22u64 => _serde::__private::Ok(__Field::__field22),
                                    23u64 => _serde::__private::Ok(__Field::__field23),
                                    24u64 => _serde::__private::Ok(__Field::__field24),
                                    25u64 => _serde::__private::Ok(__Field::__field25),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 26")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "yottaampere" => _serde::__private::Ok(__Field::__field0),
                                    "zettaampere" => _serde::__private::Ok(__Field::__field1),
                                    "exaampere" => _serde::__private::Ok(__Field::__field2),
                                    "petaampere" => _serde::__private::Ok(__Field::__field3),
                                    "teraampere" => _serde::__private::Ok(__Field::__field4),
                                    "gigaampere" => _serde::__private::Ok(__Field::__field5),
                                    "megaampere" => _serde::__private::Ok(__Field::__field6),
                                    "kiloampere" => _serde::__private::Ok(__Field::__field7),
                                    "hectoampere" => _serde::__private::Ok(__Field::__field8),
                                    "decaampere" => _serde::__private::Ok(__Field::__field9),
                                    "ampere" => _serde::__private::Ok(__Field::__field10),
                                    "deciampere" => _serde::__private::Ok(__Field::__field11),
                                    "centiampere" => _serde::__private::Ok(__Field::__field12),
                                    "milliampere" => _serde::__private::Ok(__Field::__field13),
                                    "microampere" => _serde::__private::Ok(__Field::__field14),
                                    "nanoampere" => _serde::__private::Ok(__Field::__field15),
                                    "picoampere" => _serde::__private::Ok(__Field::__field16),
                                    "femtoampere" => _serde::__private::Ok(__Field::__field17),
                                    "attoampere" => _serde::__private::Ok(__Field::__field18),
                                    "zeptoampere" => _serde::__private::Ok(__Field::__field19),
                                    "yoctoampere" => _serde::__private::Ok(__Field::__field20),
                                    "elementary_charge_per_second" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    "atomic_unit_of_charge_per_second" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    "abampere" => _serde::__private::Ok(__Field::__field23),
                                    "gilbert" => _serde::__private::Ok(__Field::__field24),
                                    "statampere" => _serde::__private::Ok(__Field::__field25),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"yottaampere" => _serde::__private::Ok(__Field::__field0),
                                    b"zettaampere" => _serde::__private::Ok(__Field::__field1),
                                    b"exaampere" => _serde::__private::Ok(__Field::__field2),
                                    b"petaampere" => _serde::__private::Ok(__Field::__field3),
                                    b"teraampere" => _serde::__private::Ok(__Field::__field4),
                                    b"gigaampere" => _serde::__private::Ok(__Field::__field5),
                                    b"megaampere" => _serde::__private::Ok(__Field::__field6),
                                    b"kiloampere" => _serde::__private::Ok(__Field::__field7),
                                    b"hectoampere" => _serde::__private::Ok(__Field::__field8),
                                    b"decaampere" => _serde::__private::Ok(__Field::__field9),
                                    b"ampere" => _serde::__private::Ok(__Field::__field10),
                                    b"deciampere" => _serde::__private::Ok(__Field::__field11),
                                    b"centiampere" => _serde::__private::Ok(__Field::__field12),
                                    b"milliampere" => _serde::__private::Ok(__Field::__field13),
                                    b"microampere" => _serde::__private::Ok(__Field::__field14),
                                    b"nanoampere" => _serde::__private::Ok(__Field::__field15),
                                    b"picoampere" => _serde::__private::Ok(__Field::__field16),
                                    b"femtoampere" => _serde::__private::Ok(__Field::__field17),
                                    b"attoampere" => _serde::__private::Ok(__Field::__field18),
                                    b"zeptoampere" => _serde::__private::Ok(__Field::__field19),
                                    b"yoctoampere" => _serde::__private::Ok(__Field::__field20),
                                    b"elementary_charge_per_second" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    b"atomic_unit_of_charge_per_second" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    b"abampere" => _serde::__private::Ok(__Field::__field23),
                                    b"gilbert" => _serde::__private::Ok(__Field::__field24),
                                    b"statampere" => _serde::__private::Ok(__Field::__field25),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ElectricCurrentUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ElectricCurrentUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum ElectricCurrentUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::yottaampere)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::zettaampere)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::exaampere)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::petaampere)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::teraampere)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::gigaampere)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::megaampere)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::kiloampere)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::hectoampere)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::decaampere)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::ampere)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::deciampere)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::centiampere)
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::milliampere)
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::microampere)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::nanoampere)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::picoampere)
                                    }
                                    (__Field::__field17, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::femtoampere)
                                    }
                                    (__Field::__field18, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::attoampere)
                                    }
                                    (__Field::__field19, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::zeptoampere)
                                    }
                                    (__Field::__field20, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::yoctoampere)
                                    }
                                    (__Field::__field21, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::elementary_charge_per_second)
                                    }
                                    (__Field::__field22, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::atomic_unit_of_charge_per_second)
                                    }
                                    (__Field::__field23, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::abampere)
                                    }
                                    (__Field::__field24, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::gilbert)
                                    }
                                    (__Field::__field25, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ElectricCurrentUnit::statampere)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["yottaampere", "zettaampere", "exaampere", "petaampere",
                                        "teraampere", "gigaampere", "megaampere", "kiloampere",
                                        "hectoampere", "decaampere", "ampere", "deciampere",
                                        "centiampere", "milliampere", "microampere", "nanoampere",
                                        "picoampere", "femtoampere", "attoampere", "zeptoampere",
                                        "yoctoampere", "elementary_charge_per_second",
                                        "atomic_unit_of_charge_per_second", "abampere", "gilbert",
                                        "statampere"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "ElectricCurrentUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ElectricCurrentUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for ElectricCurrentUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for ElectricCurrentUnit {
            #[inline]
            fn clone(&self) -> ElectricCurrentUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for ElectricCurrentUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        ElectricCurrentUnit::yottaampere => "yottaampere",
                        ElectricCurrentUnit::zettaampere => "zettaampere",
                        ElectricCurrentUnit::exaampere => "exaampere",
                        ElectricCurrentUnit::petaampere => "petaampere",
                        ElectricCurrentUnit::teraampere => "teraampere",
                        ElectricCurrentUnit::gigaampere => "gigaampere",
                        ElectricCurrentUnit::megaampere => "megaampere",
                        ElectricCurrentUnit::kiloampere => "kiloampere",
                        ElectricCurrentUnit::hectoampere => "hectoampere",
                        ElectricCurrentUnit::decaampere => "decaampere",
                        ElectricCurrentUnit::ampere => "ampere",
                        ElectricCurrentUnit::deciampere => "deciampere",
                        ElectricCurrentUnit::centiampere => "centiampere",
                        ElectricCurrentUnit::milliampere => "milliampere",
                        ElectricCurrentUnit::microampere => "microampere",
                        ElectricCurrentUnit::nanoampere => "nanoampere",
                        ElectricCurrentUnit::picoampere => "picoampere",
                        ElectricCurrentUnit::femtoampere => "femtoampere",
                        ElectricCurrentUnit::attoampere => "attoampere",
                        ElectricCurrentUnit::zeptoampere => "zeptoampere",
                        ElectricCurrentUnit::yoctoampere => "yoctoampere",
                        ElectricCurrentUnit::elementary_charge_per_second =>
                            "elementary_charge_per_second",
                        ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                            "atomic_unit_of_charge_per_second",
                        ElectricCurrentUnit::abampere => "abampere",
                        ElectricCurrentUnit::gilbert => "gilbert",
                        ElectricCurrentUnit::statampere => "statampere",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for ElectricCurrentUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for ElectricCurrentUnit {
            #[inline]
            fn eq(&self, other: &ElectricCurrentUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for ElectricCurrentUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for ElectricCurrentUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const ELECTRICCURRENT_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::P1,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const ELECTRICCURRENT_YOTTAAMPERE_CONVERSION: f64 =
            1.0_E24;
        pub(crate) const ELECTRICCURRENT_ZETTAAMPERE_CONVERSION: f64 =
            1.0_E21;
        pub(crate) const ELECTRICCURRENT_EXAAMPERE_CONVERSION: f64 = 1.0_E18;
        pub(crate) const ELECTRICCURRENT_PETAAMPERE_CONVERSION: f64 = 1.0_E15;
        pub(crate) const ELECTRICCURRENT_TERAAMPERE_CONVERSION: f64 = 1.0_E12;
        pub(crate) const ELECTRICCURRENT_GIGAAMPERE_CONVERSION: f64 = 1.0_E9;
        pub(crate) const ELECTRICCURRENT_MEGAAMPERE_CONVERSION: f64 = 1.0_E6;
        pub(crate) const ELECTRICCURRENT_KILOAMPERE_CONVERSION: f64 = 1.0_E3;
        pub(crate) const ELECTRICCURRENT_HECTOAMPERE_CONVERSION: f64 = 1.0_E2;
        pub(crate) const ELECTRICCURRENT_DECAAMPERE_CONVERSION: f64 = 1.0_E1;
        pub(crate) const ELECTRICCURRENT_AMPERE_CONVERSION: f64 = 1.0_E0;
        pub(crate) const ELECTRICCURRENT_DECIAMPERE_CONVERSION: f64 = 1.0_E-1;
        pub(crate) const ELECTRICCURRENT_CENTIAMPERE_CONVERSION: f64 =
            1.0_E-2;
        pub(crate) const ELECTRICCURRENT_MILLIAMPERE_CONVERSION: f64 =
            1.0_E-3;
        pub(crate) const ELECTRICCURRENT_MICROAMPERE_CONVERSION: f64 =
            1.0_E-6;
        pub(crate) const ELECTRICCURRENT_NANOAMPERE_CONVERSION: f64 = 1.0_E-9;
        pub(crate) const ELECTRICCURRENT_PICOAMPERE_CONVERSION: f64 =
            1.0_E-12;
        pub(crate) const ELECTRICCURRENT_FEMTOAMPERE_CONVERSION: f64 =
            1.0_E-15;
        pub(crate) const ELECTRICCURRENT_ATTOAMPERE_CONVERSION: f64 =
            1.0_E-18;
        pub(crate) const ELECTRICCURRENT_ZEPTOAMPERE_CONVERSION: f64 =
            1.0_E-21;
        pub(crate) const ELECTRICCURRENT_YOCTOAMPERE_CONVERSION: f64 =
            1.0_E-24;
        pub(crate) const
            ELECTRICCURRENT_ELEMENTARY_CHARGE_PER_SECOND_CONVERSION: f64 =
            1.602_176_634_E-19;
        pub(crate) const
            ELECTRICCURRENT_ATOMIC_UNIT_OF_CHARGE_PER_SECOND_CONVERSION: f64 =
            1.602_176_634_E-19;
        pub(crate) const ELECTRICCURRENT_ABAMPERE_CONVERSION: f64 = 1.0_E1;
        pub(crate) const ELECTRICCURRENT_GILBERT_CONVERSION: f64 =
            7.957_747_E-1;
        pub(crate) const ELECTRICCURRENT_STATAMPERE_CONVERSION: f64 =
            3.33564095198152E-10;
        impl ElectricCurrentUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_yottaampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_YOTTAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zettaampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_ZETTAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_exaampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_EXAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_petaampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_PETAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_teraampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_TERAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gigaampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_GIGAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_megaampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_MEGAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kiloampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_KILOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hectoampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_HECTOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decaampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_DECAAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_ampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_AMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_deciampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_DECIAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_centiampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_CENTIAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_milliampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_MILLIAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_microampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_MICROAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nanoampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_NANOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_picoampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_PICOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_femtoampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_FEMTOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_attoampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_ATTOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zeptoampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_ZEPTOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yoctoampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_YOCTOAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_elementary_charge_per_second() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_ELEMENTARY_CHARGE_PER_SECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_atomic_unit_of_charge_per_second() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_ATOMIC_UNIT_OF_CHARGE_PER_SECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_abampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_ABAMPERE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gilbert() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_GILBERT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_statampere() -> UnitDefinition {
                UnitDefinition {
                    base: ELECTRICCURRENT_UNIT_BASE,
                    multiplier: ELECTRICCURRENT_STATAMPERE_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    ElectricCurrentUnit::yottaampere =>
                        ELECTRICCURRENT_YOTTAAMPERE_CONVERSION,
                    ElectricCurrentUnit::zettaampere =>
                        ELECTRICCURRENT_ZETTAAMPERE_CONVERSION,
                    ElectricCurrentUnit::exaampere =>
                        ELECTRICCURRENT_EXAAMPERE_CONVERSION,
                    ElectricCurrentUnit::petaampere =>
                        ELECTRICCURRENT_PETAAMPERE_CONVERSION,
                    ElectricCurrentUnit::teraampere =>
                        ELECTRICCURRENT_TERAAMPERE_CONVERSION,
                    ElectricCurrentUnit::gigaampere =>
                        ELECTRICCURRENT_GIGAAMPERE_CONVERSION,
                    ElectricCurrentUnit::megaampere =>
                        ELECTRICCURRENT_MEGAAMPERE_CONVERSION,
                    ElectricCurrentUnit::kiloampere =>
                        ELECTRICCURRENT_KILOAMPERE_CONVERSION,
                    ElectricCurrentUnit::hectoampere =>
                        ELECTRICCURRENT_HECTOAMPERE_CONVERSION,
                    ElectricCurrentUnit::decaampere =>
                        ELECTRICCURRENT_DECAAMPERE_CONVERSION,
                    ElectricCurrentUnit::ampere =>
                        ELECTRICCURRENT_AMPERE_CONVERSION,
                    ElectricCurrentUnit::deciampere =>
                        ELECTRICCURRENT_DECIAMPERE_CONVERSION,
                    ElectricCurrentUnit::centiampere =>
                        ELECTRICCURRENT_CENTIAMPERE_CONVERSION,
                    ElectricCurrentUnit::milliampere =>
                        ELECTRICCURRENT_MILLIAMPERE_CONVERSION,
                    ElectricCurrentUnit::microampere =>
                        ELECTRICCURRENT_MICROAMPERE_CONVERSION,
                    ElectricCurrentUnit::nanoampere =>
                        ELECTRICCURRENT_NANOAMPERE_CONVERSION,
                    ElectricCurrentUnit::picoampere =>
                        ELECTRICCURRENT_PICOAMPERE_CONVERSION,
                    ElectricCurrentUnit::femtoampere =>
                        ELECTRICCURRENT_FEMTOAMPERE_CONVERSION,
                    ElectricCurrentUnit::attoampere =>
                        ELECTRICCURRENT_ATTOAMPERE_CONVERSION,
                    ElectricCurrentUnit::zeptoampere =>
                        ELECTRICCURRENT_ZEPTOAMPERE_CONVERSION,
                    ElectricCurrentUnit::yoctoampere =>
                        ELECTRICCURRENT_YOCTOAMPERE_CONVERSION,
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        ELECTRICCURRENT_ELEMENTARY_CHARGE_PER_SECOND_CONVERSION,
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        ELECTRICCURRENT_ATOMIC_UNIT_OF_CHARGE_PER_SECOND_CONVERSION,
                    ElectricCurrentUnit::abampere =>
                        ELECTRICCURRENT_ABAMPERE_CONVERSION,
                    ElectricCurrentUnit::gilbert =>
                        ELECTRICCURRENT_GILBERT_CONVERSION,
                    ElectricCurrentUnit::statampere =>
                        ELECTRICCURRENT_STATAMPERE_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    ElectricCurrentUnit::yottaampere => "YA",
                    ElectricCurrentUnit::zettaampere => "ZA",
                    ElectricCurrentUnit::exaampere => "EA",
                    ElectricCurrentUnit::petaampere => "PA",
                    ElectricCurrentUnit::teraampere => "TA",
                    ElectricCurrentUnit::gigaampere => "GA",
                    ElectricCurrentUnit::megaampere => "MA",
                    ElectricCurrentUnit::kiloampere => "kA",
                    ElectricCurrentUnit::hectoampere => "hA",
                    ElectricCurrentUnit::decaampere => "daA",
                    ElectricCurrentUnit::ampere => "A",
                    ElectricCurrentUnit::deciampere => "dA",
                    ElectricCurrentUnit::centiampere => "cA",
                    ElectricCurrentUnit::milliampere => "mA",
                    ElectricCurrentUnit::microampere => "A",
                    ElectricCurrentUnit::nanoampere => "nA",
                    ElectricCurrentUnit::picoampere => "pA",
                    ElectricCurrentUnit::femtoampere => "fA",
                    ElectricCurrentUnit::attoampere => "aA",
                    ElectricCurrentUnit::zeptoampere => "zA",
                    ElectricCurrentUnit::yoctoampere => "yA",
                    ElectricCurrentUnit::elementary_charge_per_second => "e/s",
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        "a.u. of charge/s",
                    ElectricCurrentUnit::abampere => "abA",
                    ElectricCurrentUnit::gilbert => "Gi",
                    ElectricCurrentUnit::statampere => "statA",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    ElectricCurrentUnit::yottaampere => "yottaampere",
                    ElectricCurrentUnit::zettaampere => "zettaampere",
                    ElectricCurrentUnit::exaampere => "exaampere",
                    ElectricCurrentUnit::petaampere => "petaampere",
                    ElectricCurrentUnit::teraampere => "teraampere",
                    ElectricCurrentUnit::gigaampere => "gigaampere",
                    ElectricCurrentUnit::megaampere => "megaampere",
                    ElectricCurrentUnit::kiloampere => "kiloampere",
                    ElectricCurrentUnit::hectoampere => "hectoampere",
                    ElectricCurrentUnit::decaampere => "decaampere",
                    ElectricCurrentUnit::ampere => "ampere",
                    ElectricCurrentUnit::deciampere => "deciampere",
                    ElectricCurrentUnit::centiampere => "centiampere",
                    ElectricCurrentUnit::milliampere => "millampere",
                    ElectricCurrentUnit::microampere => "microampere",
                    ElectricCurrentUnit::nanoampere => "nanoampere",
                    ElectricCurrentUnit::picoampere => "picoampere",
                    ElectricCurrentUnit::femtoampere => "femtoampere",
                    ElectricCurrentUnit::attoampere => "attoampere",
                    ElectricCurrentUnit::zeptoampere => "zeptoampere",
                    ElectricCurrentUnit::yoctoampere => "yoctoampere",
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        "elementary charge per second",
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        "atomic UnitDefinition of charge per second",
                    ElectricCurrentUnit::abampere => "abampere",
                    ElectricCurrentUnit::gilbert => "gilbert",
                    ElectricCurrentUnit::statampere => "statampere",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    ElectricCurrentUnit::yottaampere => "yottaamperes",
                    ElectricCurrentUnit::zettaampere => "zettaamperes",
                    ElectricCurrentUnit::exaampere => "exaamperes",
                    ElectricCurrentUnit::petaampere => "petaamperes",
                    ElectricCurrentUnit::teraampere => "teraamperes",
                    ElectricCurrentUnit::gigaampere => "gigaamperes",
                    ElectricCurrentUnit::megaampere => "megaamperes",
                    ElectricCurrentUnit::kiloampere => "kiloamperes",
                    ElectricCurrentUnit::hectoampere => "hectoamperes",
                    ElectricCurrentUnit::decaampere => "decaamperes",
                    ElectricCurrentUnit::ampere => "amperes",
                    ElectricCurrentUnit::deciampere => "deciamperes",
                    ElectricCurrentUnit::centiampere => "centiamperes",
                    ElectricCurrentUnit::milliampere => "millamperes",
                    ElectricCurrentUnit::microampere => "microamperes",
                    ElectricCurrentUnit::nanoampere => "nanoamperes",
                    ElectricCurrentUnit::picoampere => "picoamperes",
                    ElectricCurrentUnit::femtoampere => "femtoamperes",
                    ElectricCurrentUnit::attoampere => "attoamperes",
                    ElectricCurrentUnit::zeptoampere => "zeptoamperes",
                    ElectricCurrentUnit::yoctoampere => "yoctoamperes",
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        "elementary charges per second",
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        "atomic units of charge per second",
                    ElectricCurrentUnit::abampere => "abamperes",
                    ElectricCurrentUnit::gilbert => "gilberts",
                    ElectricCurrentUnit::statampere => "statamperes",
                }
            }
            #[doc = "Available units for this `[ElectricCurrentUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["yottaampere", "zettaampere", "exaampere", "petaampere",
                                "teraampere", "gigaampere", "megaampere", "kiloampere",
                                "hectoampere", "decaampere", "ampere", "deciampere",
                                "centiampere", "millampere", "microampere", "nanoampere",
                                "picoampere", "femtoampere", "attoampere", "zeptoampere",
                                "yoctoampere", "elementary charge per second",
                                "atomic UnitDefinition of charge per second", "abampere",
                                "gilbert", "statampere"];
                UNITS
            }
        }
        impl crate::traits::Unit for ElectricCurrentUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    ElectricCurrentUnit::yottaampere =>
                        ElectricCurrentUnit::get_yottaampere(),
                    ElectricCurrentUnit::zettaampere =>
                        ElectricCurrentUnit::get_zettaampere(),
                    ElectricCurrentUnit::exaampere =>
                        ElectricCurrentUnit::get_exaampere(),
                    ElectricCurrentUnit::petaampere =>
                        ElectricCurrentUnit::get_petaampere(),
                    ElectricCurrentUnit::teraampere =>
                        ElectricCurrentUnit::get_teraampere(),
                    ElectricCurrentUnit::gigaampere =>
                        ElectricCurrentUnit::get_gigaampere(),
                    ElectricCurrentUnit::megaampere =>
                        ElectricCurrentUnit::get_megaampere(),
                    ElectricCurrentUnit::kiloampere =>
                        ElectricCurrentUnit::get_kiloampere(),
                    ElectricCurrentUnit::hectoampere =>
                        ElectricCurrentUnit::get_hectoampere(),
                    ElectricCurrentUnit::decaampere =>
                        ElectricCurrentUnit::get_decaampere(),
                    ElectricCurrentUnit::ampere =>
                        ElectricCurrentUnit::get_ampere(),
                    ElectricCurrentUnit::deciampere =>
                        ElectricCurrentUnit::get_deciampere(),
                    ElectricCurrentUnit::centiampere =>
                        ElectricCurrentUnit::get_centiampere(),
                    ElectricCurrentUnit::milliampere =>
                        ElectricCurrentUnit::get_milliampere(),
                    ElectricCurrentUnit::microampere =>
                        ElectricCurrentUnit::get_microampere(),
                    ElectricCurrentUnit::nanoampere =>
                        ElectricCurrentUnit::get_nanoampere(),
                    ElectricCurrentUnit::picoampere =>
                        ElectricCurrentUnit::get_picoampere(),
                    ElectricCurrentUnit::femtoampere =>
                        ElectricCurrentUnit::get_femtoampere(),
                    ElectricCurrentUnit::attoampere =>
                        ElectricCurrentUnit::get_attoampere(),
                    ElectricCurrentUnit::zeptoampere =>
                        ElectricCurrentUnit::get_zeptoampere(),
                    ElectricCurrentUnit::yoctoampere =>
                        ElectricCurrentUnit::get_yoctoampere(),
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        ElectricCurrentUnit::get_elementary_charge_per_second(),
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        ElectricCurrentUnit::get_atomic_unit_of_charge_per_second(),
                    ElectricCurrentUnit::abampere =>
                        ElectricCurrentUnit::get_abampere(),
                    ElectricCurrentUnit::gilbert =>
                        ElectricCurrentUnit::get_gilbert(),
                    ElectricCurrentUnit::statampere =>
                        ElectricCurrentUnit::get_statampere(),
                }
            }
            #[inline]
            fn base() -> UnitBase { ELECTRICCURRENT_UNIT_BASE }
        }
        impl From<ElectricCurrentUnit> for crate::Units {
            fn from(value: ElectricCurrentUnit) -> Self {
                match value {
                    ElectricCurrentUnit::yottaampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::yottaampere),
                    ElectricCurrentUnit::zettaampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::zettaampere),
                    ElectricCurrentUnit::exaampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::exaampere),
                    ElectricCurrentUnit::petaampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::petaampere),
                    ElectricCurrentUnit::teraampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::teraampere),
                    ElectricCurrentUnit::gigaampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::gigaampere),
                    ElectricCurrentUnit::megaampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::megaampere),
                    ElectricCurrentUnit::kiloampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::kiloampere),
                    ElectricCurrentUnit::hectoampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::hectoampere),
                    ElectricCurrentUnit::decaampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::decaampere),
                    ElectricCurrentUnit::ampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::ampere),
                    ElectricCurrentUnit::deciampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::deciampere),
                    ElectricCurrentUnit::centiampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::centiampere),
                    ElectricCurrentUnit::milliampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::milliampere),
                    ElectricCurrentUnit::microampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::microampere),
                    ElectricCurrentUnit::nanoampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::nanoampere),
                    ElectricCurrentUnit::picoampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::picoampere),
                    ElectricCurrentUnit::femtoampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::femtoampere),
                    ElectricCurrentUnit::attoampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::attoampere),
                    ElectricCurrentUnit::zeptoampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::zeptoampere),
                    ElectricCurrentUnit::yoctoampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::yoctoampere),
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::elementary_charge_per_second),
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::atomic_unit_of_charge_per_second),
                    ElectricCurrentUnit::abampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::abampere),
                    ElectricCurrentUnit::gilbert =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::gilbert),
                    ElectricCurrentUnit::statampere =>
                        crate::Units::ElectricCurrent(ElectricCurrentUnit::statampere),
                }
            }
        }
        impl TryFrom<UnitDefinition> for ElectricCurrentUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_YOTTAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::yottaampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_ZETTAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::zettaampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_EXAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::exaampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_PETAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::petaampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_TERAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::teraampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_GIGAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::gigaampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_MEGAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::megaampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_KILOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::kiloampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_HECTOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::hectoampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_DECAAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::decaampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_AMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::ampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_DECIAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::deciampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_CENTIAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::centiampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_MILLIAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::milliampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_MICROAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::microampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_NANOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::nanoampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_PICOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::picoampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_FEMTOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::femtoampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_ATTOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::attoampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_ZEPTOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::zeptoampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_YOCTOAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::yoctoampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_ELEMENTARY_CHARGE_PER_SECOND_CONVERSION
                        } => Ok(ElectricCurrentUnit::elementary_charge_per_second),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_ATOMIC_UNIT_OF_CHARGE_PER_SECOND_CONVERSION
                        } =>
                        Ok(ElectricCurrentUnit::atomic_unit_of_charge_per_second),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_ABAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::abampere),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_GILBERT_CONVERSION } =>
                        Ok(ElectricCurrentUnit::gilbert),
                    UnitDefinition {
                        base: ELECTRICCURRENT_UNIT_BASE,
                        multiplier: ELECTRICCURRENT_STATAMPERE_CONVERSION } =>
                        Ok(ElectricCurrentUnit::statampere),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "ElectricCurrent"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for ElectricCurrentUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::yottaampere)
                        => Ok(ElectricCurrentUnit::yottaampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::zettaampere)
                        => Ok(ElectricCurrentUnit::zettaampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::exaampere)
                        => Ok(ElectricCurrentUnit::exaampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::petaampere)
                        => Ok(ElectricCurrentUnit::petaampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::teraampere)
                        => Ok(ElectricCurrentUnit::teraampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::gigaampere)
                        => Ok(ElectricCurrentUnit::gigaampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::megaampere)
                        => Ok(ElectricCurrentUnit::megaampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::kiloampere)
                        => Ok(ElectricCurrentUnit::kiloampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::hectoampere)
                        => Ok(ElectricCurrentUnit::hectoampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::decaampere)
                        => Ok(ElectricCurrentUnit::decaampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::ampere)
                        => Ok(ElectricCurrentUnit::ampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::deciampere)
                        => Ok(ElectricCurrentUnit::deciampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::centiampere)
                        => Ok(ElectricCurrentUnit::centiampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::milliampere)
                        => Ok(ElectricCurrentUnit::milliampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::microampere)
                        => Ok(ElectricCurrentUnit::microampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::nanoampere)
                        => Ok(ElectricCurrentUnit::nanoampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::picoampere)
                        => Ok(ElectricCurrentUnit::picoampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::femtoampere)
                        => Ok(ElectricCurrentUnit::femtoampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::attoampere)
                        => Ok(ElectricCurrentUnit::attoampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::zeptoampere)
                        => Ok(ElectricCurrentUnit::zeptoampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::yoctoampere)
                        => Ok(ElectricCurrentUnit::yoctoampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::elementary_charge_per_second)
                        => Ok(ElectricCurrentUnit::elementary_charge_per_second),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::atomic_unit_of_charge_per_second)
                        =>
                        Ok(ElectricCurrentUnit::atomic_unit_of_charge_per_second),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::abampere)
                        => Ok(ElectricCurrentUnit::abampere),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::gilbert)
                        => Ok(ElectricCurrentUnit::gilbert),
                    crate::Units::ElectricCurrent(ElectricCurrentUnit::statampere)
                        => Ok(ElectricCurrentUnit::statampere),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "ElectricCurrent"));
                                        res
                                    }))),
                }
            }
        }
        impl From<ElectricCurrent> for crate::Units {
            fn from(value: ElectricCurrent) -> Self {
                crate::Units::ElectricCurrent(value.unit)
            }
        }
        impl From<&ElectricCurrent> for crate::Units {
            fn from(value: &ElectricCurrent) -> Self {
                crate::Units::ElectricCurrent(value.unit)
            }
        }
        impl From<ElectricCurrentVec> for crate::Units {
            fn from(value: ElectricCurrentVec) -> Self {
                crate::Units::ElectricCurrent(value.unit)
            }
        }
        impl From<&ElectricCurrentVec> for crate::Units {
            fn from(value: &ElectricCurrentVec) -> Self {
                crate::Units::ElectricCurrent(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Electric current (base UnitDefinition ampere, A)."]
        #[schema(title = "ElectricCurrent")]
        #[doc =
        "Scalar storage of a quantity (f64 and [`ElectricCurrentUnit`])."]
        pub struct ElectricCurrent {
            pub(crate) value: f64,
            pub(crate) unit: ElectricCurrentUnit,
        }
        impl utoipa::__dev::ComposeSchema for ElectricCurrent {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("ElectricCurrent")).description(Some(" Electric current (base UnitDefinition ampere, A).\nScalar storage of a quantity (f64 and [`ElectricCurrentUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for ElectricCurrent {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("ElectricCurrent")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <ElectricCurrentUnit as utoipa::PartialSchema>::schema())]);
                <ElectricCurrentUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ElectricCurrent {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "ElectricCurrent", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ElectricCurrent {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ElectricCurrent>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ElectricCurrent;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct ElectricCurrent")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct ElectricCurrent with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<ElectricCurrentUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct ElectricCurrent with 2 elements")),
                                    };
                                _serde::__private::Ok(ElectricCurrent {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1:
                                        _serde::__private::Option<ElectricCurrentUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<ElectricCurrentUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(ElectricCurrent {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "ElectricCurrent", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ElectricCurrent>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for ElectricCurrent { }
        #[automatically_derived]
        impl ::core::clone::Clone for ElectricCurrent {
            #[inline]
            fn clone(&self) -> ElectricCurrent {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _: ::core::clone::AssertParamIsClone<ElectricCurrentUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElectricCurrent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "ElectricCurrent", "value", &self.value, "unit",
                    &&self.unit)
            }
        }
        impl ElectricCurrent {
            #[doc = "Create a new [`ElectricCurrentUnit`]."]
            pub fn new(value: f64, unit: ElectricCurrentUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::yottaampere`]."]
            pub fn yottaampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::yottaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::zettaampere`]."]
            pub fn zettaampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::zettaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::exaampere`]."]
            pub fn exaampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::exaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::petaampere`]."]
            pub fn petaampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::petaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::teraampere`]."]
            pub fn teraampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::teraampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::gigaampere`]."]
            pub fn gigaampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::gigaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::megaampere`]."]
            pub fn megaampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::megaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::kiloampere`]."]
            pub fn kiloampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::kiloampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::hectoampere`]."]
            pub fn hectoampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::hectoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::decaampere`]."]
            pub fn decaampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::decaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::ampere`]."]
            pub fn ampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::ampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::deciampere`]."]
            pub fn deciampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::deciampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::centiampere`]."]
            pub fn centiampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::centiampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::milliampere`]."]
            pub fn milliampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::milliampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::microampere`]."]
            pub fn microampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::microampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::nanoampere`]."]
            pub fn nanoampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::nanoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::picoampere`]."]
            pub fn picoampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::picoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::femtoampere`]."]
            pub fn femtoampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::femtoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::attoampere`]."]
            pub fn attoampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::attoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::zeptoampere`]."]
            pub fn zeptoampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::zeptoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::yoctoampere`]."]
            pub fn yoctoampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::yoctoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::elementary_charge_per_second`]."]
            pub fn elementary_charge_per_second(value: f64) -> Self {
                Self {
                    value,
                    unit: ElectricCurrentUnit::elementary_charge_per_second.into(),
                }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::atomic_unit_of_charge_per_second`]."]
            pub fn atomic_unit_of_charge_per_second(value: f64) -> Self {
                Self {
                    value,
                    unit: ElectricCurrentUnit::atomic_unit_of_charge_per_second.into(),
                }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::abampere`]."]
            pub fn abampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::abampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::gilbert`]."]
            pub fn gilbert(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::gilbert.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::statampere`]."]
            pub fn statampere(value: f64) -> Self {
                Self { value, unit: ElectricCurrentUnit::statampere.into() }
            }
            #[doc =
            "Retrieve the value associated with this [`ElectricCurrent`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`ElectricCurrent`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`ElectricCurrent`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::yottaampere`]."]
            #[inline]
            pub fn to_yottaampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_YOTTAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::yottaampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::zettaampere`]."]
            #[inline]
            pub fn to_zettaampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_ZETTAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::zettaampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::exaampere`]."]
            #[inline]
            pub fn to_exaampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_EXAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::exaampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::petaampere`]."]
            #[inline]
            pub fn to_petaampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_PETAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::petaampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::teraampere`]."]
            #[inline]
            pub fn to_teraampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_TERAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::teraampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::gigaampere`]."]
            #[inline]
            pub fn to_gigaampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_GIGAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::gigaampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::megaampere`]."]
            #[inline]
            pub fn to_megaampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_MEGAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::megaampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::kiloampere`]."]
            #[inline]
            pub fn to_kiloampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_KILOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::kiloampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::hectoampere`]."]
            #[inline]
            pub fn to_hectoampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_HECTOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::hectoampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::decaampere`]."]
            #[inline]
            pub fn to_decaampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_DECAAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::decaampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::ampere`]."]
            #[inline]
            pub fn to_ampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_AMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::ampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::deciampere`]."]
            #[inline]
            pub fn to_deciampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_DECIAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::deciampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::centiampere`]."]
            #[inline]
            pub fn to_centiampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_CENTIAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::centiampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::milliampere`]."]
            #[inline]
            pub fn to_milliampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_MILLIAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::milliampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::microampere`]."]
            #[inline]
            pub fn to_microampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_MICROAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::microampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::nanoampere`]."]
            #[inline]
            pub fn to_nanoampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_NANOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::nanoampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::picoampere`]."]
            #[inline]
            pub fn to_picoampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_PICOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::picoampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::femtoampere`]."]
            #[inline]
            pub fn to_femtoampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_FEMTOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::femtoampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::attoampere`]."]
            #[inline]
            pub fn to_attoampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_ATTOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::attoampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::zeptoampere`]."]
            #[inline]
            pub fn to_zeptoampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_ZEPTOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::zeptoampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::yoctoampere`]."]
            #[inline]
            pub fn to_yoctoampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_YOCTOAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::yoctoampere,
                }
            }
            #[doc =
            "Convert to [`ElectricCurrentUnit::elementary_charge_per_second`]."]
            #[inline]
            pub fn to_elementary_charge_per_second(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_ELEMENTARY_CHARGE_PER_SECOND_CONVERSION))
                            as f64,
                    unit: ElectricCurrentUnit::elementary_charge_per_second,
                }
            }
            #[doc =
            "Convert to [`ElectricCurrentUnit::atomic_unit_of_charge_per_second`]."]
            #[inline]
            pub fn to_atomic_unit_of_charge_per_second(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_ATOMIC_UNIT_OF_CHARGE_PER_SECOND_CONVERSION))
                            as f64,
                    unit: ElectricCurrentUnit::atomic_unit_of_charge_per_second,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::abampere`]."]
            #[inline]
            pub fn to_abampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_ABAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::abampere,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::gilbert`]."]
            #[inline]
            pub fn to_gilbert(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_GILBERT_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::gilbert,
                }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::statampere`]."]
            #[inline]
            pub fn to_statampere(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (ELECTRICCURRENT_STATAMPERE_CONVERSION)) as f64,
                    unit: ElectricCurrentUnit::statampere,
                }
            }
        }
        impl FixedQuantity<ElectricCurrentUnit> for ElectricCurrent {
            #[inline]
            fn unit(&self) -> ElectricCurrentUnit { self.unit }
            #[inline]
            fn convert(&self, unit: ElectricCurrentUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: ElectricCurrentUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut ElectricCurrentUnit {
                &mut self.unit
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: ElectricCurrentUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<ElectricCurrent> for UnitDefinition {
            #[inline]
            fn from(value: ElectricCurrent) -> Self {
                match value.unit {
                    ElectricCurrentUnit::yottaampere =>
                        ElectricCurrentUnit::get_yottaampere(),
                    ElectricCurrentUnit::zettaampere =>
                        ElectricCurrentUnit::get_zettaampere(),
                    ElectricCurrentUnit::exaampere =>
                        ElectricCurrentUnit::get_exaampere(),
                    ElectricCurrentUnit::petaampere =>
                        ElectricCurrentUnit::get_petaampere(),
                    ElectricCurrentUnit::teraampere =>
                        ElectricCurrentUnit::get_teraampere(),
                    ElectricCurrentUnit::gigaampere =>
                        ElectricCurrentUnit::get_gigaampere(),
                    ElectricCurrentUnit::megaampere =>
                        ElectricCurrentUnit::get_megaampere(),
                    ElectricCurrentUnit::kiloampere =>
                        ElectricCurrentUnit::get_kiloampere(),
                    ElectricCurrentUnit::hectoampere =>
                        ElectricCurrentUnit::get_hectoampere(),
                    ElectricCurrentUnit::decaampere =>
                        ElectricCurrentUnit::get_decaampere(),
                    ElectricCurrentUnit::ampere =>
                        ElectricCurrentUnit::get_ampere(),
                    ElectricCurrentUnit::deciampere =>
                        ElectricCurrentUnit::get_deciampere(),
                    ElectricCurrentUnit::centiampere =>
                        ElectricCurrentUnit::get_centiampere(),
                    ElectricCurrentUnit::milliampere =>
                        ElectricCurrentUnit::get_milliampere(),
                    ElectricCurrentUnit::microampere =>
                        ElectricCurrentUnit::get_microampere(),
                    ElectricCurrentUnit::nanoampere =>
                        ElectricCurrentUnit::get_nanoampere(),
                    ElectricCurrentUnit::picoampere =>
                        ElectricCurrentUnit::get_picoampere(),
                    ElectricCurrentUnit::femtoampere =>
                        ElectricCurrentUnit::get_femtoampere(),
                    ElectricCurrentUnit::attoampere =>
                        ElectricCurrentUnit::get_attoampere(),
                    ElectricCurrentUnit::zeptoampere =>
                        ElectricCurrentUnit::get_zeptoampere(),
                    ElectricCurrentUnit::yoctoampere =>
                        ElectricCurrentUnit::get_yoctoampere(),
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        ElectricCurrentUnit::get_elementary_charge_per_second(),
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        ElectricCurrentUnit::get_atomic_unit_of_charge_per_second(),
                    ElectricCurrentUnit::abampere =>
                        ElectricCurrentUnit::get_abampere(),
                    ElectricCurrentUnit::gilbert =>
                        ElectricCurrentUnit::get_gilbert(),
                    ElectricCurrentUnit::statampere =>
                        ElectricCurrentUnit::get_statampere(),
                }
            }
        }
        impl From<ElectricCurrent> for Quantity {
            fn from(quantity: ElectricCurrent) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for ElectricCurrent {
            fn from(quantity: Quantity) -> ElectricCurrent {
                ElectricCurrent {
                    value: quantity.value,
                    unit: ElectricCurrentUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for ElectricCurrent {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl ElectricCurrentVec {
            #[doc = "Create a new vector of [`ElectricCurrentUnit`]."]
            pub fn new(values: Vec<f64>, unit: ElectricCurrentUnit) -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc =
            "Retrieve values associated with this [`ElectricCurrentSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`ElectricCurrentSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::yottaampere`]."]
            pub fn yottaampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::yottaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::zettaampere`]."]
            pub fn zettaampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::zettaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::exaampere`]."]
            pub fn exaampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::exaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::petaampere`]."]
            pub fn petaampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::petaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::teraampere`]."]
            pub fn teraampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::teraampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::gigaampere`]."]
            pub fn gigaampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::gigaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::megaampere`]."]
            pub fn megaampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::megaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::kiloampere`]."]
            pub fn kiloampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::kiloampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::hectoampere`]."]
            pub fn hectoampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::hectoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::decaampere`]."]
            pub fn decaampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::decaampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::ampere`]."]
            pub fn ampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::ampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::deciampere`]."]
            pub fn deciampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::deciampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::centiampere`]."]
            pub fn centiampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::centiampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::milliampere`]."]
            pub fn milliampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::milliampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::microampere`]."]
            pub fn microampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::microampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::nanoampere`]."]
            pub fn nanoampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::nanoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::picoampere`]."]
            pub fn picoampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::picoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::femtoampere`]."]
            pub fn femtoampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::femtoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::attoampere`]."]
            pub fn attoampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::attoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::zeptoampere`]."]
            pub fn zeptoampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::zeptoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::yoctoampere`]."]
            pub fn yoctoampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::yoctoampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::elementary_charge_per_second`]."]
            pub fn elementary_charge_per_second(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: ElectricCurrentUnit::elementary_charge_per_second.into(),
                }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::atomic_unit_of_charge_per_second`]."]
            pub fn atomic_unit_of_charge_per_second(values: Vec<f64>)
                -> Self {
                Self {
                    values,
                    unit: ElectricCurrentUnit::atomic_unit_of_charge_per_second.into(),
                }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::abampere`]."]
            pub fn abampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::abampere.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::gilbert`]."]
            pub fn gilbert(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::gilbert.into() }
            }
            #[doc =
            "Create a new [`ElectricCurrent`] with units of [`ElectricCurrentUnit::statampere`]."]
            pub fn statampere(values: Vec<f64>) -> Self {
                Self { values, unit: ElectricCurrentUnit::statampere.into() }
            }
            #[doc = "Convert to [`ElectricCurrentUnit::yottaampere`]."]
            #[inline]
            pub fn to_yottaampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::yottaampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::zettaampere`]."]
            #[inline]
            pub fn to_zettaampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::zettaampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::exaampere`]."]
            #[inline]
            pub fn to_exaampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::exaampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::petaampere`]."]
            #[inline]
            pub fn to_petaampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::petaampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::teraampere`]."]
            #[inline]
            pub fn to_teraampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::teraampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::gigaampere`]."]
            #[inline]
            pub fn to_gigaampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::gigaampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::megaampere`]."]
            #[inline]
            pub fn to_megaampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::megaampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::kiloampere`]."]
            #[inline]
            pub fn to_kiloampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::kiloampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::hectoampere`]."]
            #[inline]
            pub fn to_hectoampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::hectoampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::decaampere`]."]
            #[inline]
            pub fn to_decaampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::decaampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::ampere`]."]
            #[inline]
            pub fn to_ampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::ampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::deciampere`]."]
            #[inline]
            pub fn to_deciampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::deciampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::centiampere`]."]
            #[inline]
            pub fn to_centiampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::centiampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::milliampere`]."]
            #[inline]
            pub fn to_milliampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::milliampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::microampere`]."]
            #[inline]
            pub fn to_microampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::microampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::nanoampere`]."]
            #[inline]
            pub fn to_nanoampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::nanoampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::picoampere`]."]
            #[inline]
            pub fn to_picoampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::picoampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::femtoampere`]."]
            #[inline]
            pub fn to_femtoampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::femtoampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::attoampere`]."]
            #[inline]
            pub fn to_attoampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::attoampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::zeptoampere`]."]
            #[inline]
            pub fn to_zeptoampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::zeptoampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::yoctoampere`]."]
            #[inline]
            pub fn to_yoctoampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::yoctoampere);
                r
            }
            #[doc =
            "Convert to [`ElectricCurrentUnit::elementary_charge_per_second`]."]
            #[inline]
            pub fn to_elementary_charge_per_second(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::elementary_charge_per_second);
                r
            }
            #[doc =
            "Convert to [`ElectricCurrentUnit::atomic_unit_of_charge_per_second`]."]
            #[inline]
            pub fn to_atomic_unit_of_charge_per_second(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::atomic_unit_of_charge_per_second);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::abampere`]."]
            #[inline]
            pub fn to_abampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::abampere);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::gilbert`]."]
            #[inline]
            pub fn to_gilbert(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::gilbert);
                r
            }
            #[doc = "Convert to [`ElectricCurrentUnit::statampere`]."]
            #[inline]
            pub fn to_statampere(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(ElectricCurrentUnit::statampere);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for ElectricCurrent {
            type Output = ElectricCurrent;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for ElectricCurrent {
            type Output = ElectricCurrent;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for ElectricCurrent {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for ElectricCurrent {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for ElectricCurrent {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<ElectricCurrent> for Quantity {
            fn eq(&self, other: &ElectricCurrent) -> bool { *other == *self }
        }
        impl PartialEq<ElectricCurrent> for ElectricCurrent {
            fn eq(&self, other: &ElectricCurrent) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for ElectricCurrent {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for ElectricCurrent {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<ElectricCurrent> for ElectricCurrent {
            type Output = Self;
            fn add(self, rhs: ElectricCurrent) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<ElectricCurrent> for ElectricCurrent {
            type Output = Self;
            fn sub(self, rhs: ElectricCurrent) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for ElectricCurrent {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for ElectricCurrent {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for ElectricCurrent {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for ElectricCurrent {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for ElectricCurrent {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for ElectricCurrent {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc =
        "Array storage for a series of values and [`ElectricCurrentUnit`]."]
        pub struct ElectricCurrentArray<const N : usize> {
            pub(crate) unit: ElectricCurrentUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for
            ElectricCurrentArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`ElectricCurrentUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for ElectricCurrentArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("ElectricCurrentArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <ElectricCurrentUnit as utoipa::PartialSchema>::schema())]);
                <ElectricCurrentUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for
                    ElectricCurrentArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "ElectricCurrentArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<ElectricCurrentArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<ElectricCurrentArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    ElectricCurrentArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<ElectricCurrentArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = ElectricCurrentArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct ElectricCurrentArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<ElectricCurrentUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct ElectricCurrentArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<ElectricCurrentArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct ElectricCurrentArray with 2 elements")),
                                    };
                                _serde::__private::Ok(ElectricCurrentArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<ElectricCurrentUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<ElectricCurrentUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<ElectricCurrentArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(ElectricCurrentArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "ElectricCurrentArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ElectricCurrentArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for ElectricCurrentArray<N>
            {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for ElectricCurrentArray<N>
            {
            #[inline]
            fn clone(&self) -> ElectricCurrentArray<N> {
                let _: ::core::clone::AssertParamIsClone<ElectricCurrentUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for ElectricCurrentArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "ElectricCurrentArray", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            ElectricCurrentArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for
            ElectricCurrentArray<N> {
            #[inline]
            fn eq(&self, other: &ElectricCurrentArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for ElectricCurrentArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for ElectricCurrentArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc =
        "Vector storage for a series of values and [`ElectricCurrentUnit`]."]
        pub struct ElectricCurrentVec {
            pub(crate) unit: ElectricCurrentUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for ElectricCurrentVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`ElectricCurrentUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for ElectricCurrentVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("ElectricCurrentVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <ElectricCurrentUnit as utoipa::PartialSchema>::schema())]);
                <ElectricCurrentUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ElectricCurrentVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "ElectricCurrentVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ElectricCurrentVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ElectricCurrentVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ElectricCurrentVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct ElectricCurrentVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<ElectricCurrentUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct ElectricCurrentVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct ElectricCurrentVec with 2 elements")),
                                    };
                                _serde::__private::Ok(ElectricCurrentVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<ElectricCurrentUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<ElectricCurrentUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(ElectricCurrentVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "ElectricCurrentVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ElectricCurrentVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for ElectricCurrentVec {
            #[inline]
            fn clone(&self) -> ElectricCurrentVec {
                ElectricCurrentVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ElectricCurrentVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "ElectricCurrentVec", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ElectricCurrentVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ElectricCurrentVec {
            #[inline]
            fn eq(&self, other: &ElectricCurrentVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for ElectricCurrentVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for ElectricCurrentVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<ElectricCurrentUnit, f64> for
            ElectricCurrentVec {
            fn unit(&self) -> ElectricCurrentUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: ElectricCurrentUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: ElectricCurrentUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: ElectricCurrentUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize>
            crate::traits::FixedSliceQuantity<ElectricCurrentUnit, f64> for
            ElectricCurrentArray<N> {
            fn unit(&self) -> ElectricCurrentUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: ElectricCurrentUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: ElectricCurrentUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: ElectricCurrentUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for ElectricCurrentVec {
            type Output = ElectricCurrentVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for ElectricCurrentVec {
            type Output = ElectricCurrentVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for ElectricCurrentVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for ElectricCurrentVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<ElectricCurrentVec> for ElectricCurrentVec {
            fn add_assign(&mut self, rhs: ElectricCurrentVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<ElectricCurrentVec> for ElectricCurrentVec {
            fn sub_assign(&mut self, rhs: ElectricCurrentVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for ElectricCurrentArray<N> {
            type Output = ElectricCurrentArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for ElectricCurrentArray<N> {
            type Output = ElectricCurrentArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for ElectricCurrentArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for ElectricCurrentArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<ElectricCurrentArray<N>> for
            ElectricCurrentArray<N> {
            fn add_assign(&mut self, rhs: ElectricCurrentArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<ElectricCurrentArray<N>> for
            ElectricCurrentArray<N> {
            fn sub_assign(&mut self, rhs: ElectricCurrentArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<ElectricCurrentVec> for VecQuantity {
            fn from(input: ElectricCurrentVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<ElectricCurrentUnit> for UnitDefinition {
            #[inline]
            fn from(value: ElectricCurrentUnit) -> Self {
                match value {
                    ElectricCurrentUnit::yottaampere =>
                        ElectricCurrentUnit::get_yottaampere(),
                    ElectricCurrentUnit::zettaampere =>
                        ElectricCurrentUnit::get_zettaampere(),
                    ElectricCurrentUnit::exaampere =>
                        ElectricCurrentUnit::get_exaampere(),
                    ElectricCurrentUnit::petaampere =>
                        ElectricCurrentUnit::get_petaampere(),
                    ElectricCurrentUnit::teraampere =>
                        ElectricCurrentUnit::get_teraampere(),
                    ElectricCurrentUnit::gigaampere =>
                        ElectricCurrentUnit::get_gigaampere(),
                    ElectricCurrentUnit::megaampere =>
                        ElectricCurrentUnit::get_megaampere(),
                    ElectricCurrentUnit::kiloampere =>
                        ElectricCurrentUnit::get_kiloampere(),
                    ElectricCurrentUnit::hectoampere =>
                        ElectricCurrentUnit::get_hectoampere(),
                    ElectricCurrentUnit::decaampere =>
                        ElectricCurrentUnit::get_decaampere(),
                    ElectricCurrentUnit::ampere =>
                        ElectricCurrentUnit::get_ampere(),
                    ElectricCurrentUnit::deciampere =>
                        ElectricCurrentUnit::get_deciampere(),
                    ElectricCurrentUnit::centiampere =>
                        ElectricCurrentUnit::get_centiampere(),
                    ElectricCurrentUnit::milliampere =>
                        ElectricCurrentUnit::get_milliampere(),
                    ElectricCurrentUnit::microampere =>
                        ElectricCurrentUnit::get_microampere(),
                    ElectricCurrentUnit::nanoampere =>
                        ElectricCurrentUnit::get_nanoampere(),
                    ElectricCurrentUnit::picoampere =>
                        ElectricCurrentUnit::get_picoampere(),
                    ElectricCurrentUnit::femtoampere =>
                        ElectricCurrentUnit::get_femtoampere(),
                    ElectricCurrentUnit::attoampere =>
                        ElectricCurrentUnit::get_attoampere(),
                    ElectricCurrentUnit::zeptoampere =>
                        ElectricCurrentUnit::get_zeptoampere(),
                    ElectricCurrentUnit::yoctoampere =>
                        ElectricCurrentUnit::get_yoctoampere(),
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        ElectricCurrentUnit::get_elementary_charge_per_second(),
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        ElectricCurrentUnit::get_atomic_unit_of_charge_per_second(),
                    ElectricCurrentUnit::abampere =>
                        ElectricCurrentUnit::get_abampere(),
                    ElectricCurrentUnit::gilbert =>
                        ElectricCurrentUnit::get_gilbert(),
                    ElectricCurrentUnit::statampere =>
                        ElectricCurrentUnit::get_statampere(),
                }
            }
        }
        impl TryFrom<&str> for ElectricCurrentUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<ElectricCurrentUnit> =
                    match value {
                        "YA" => Some(ElectricCurrentUnit::yottaampere),
                        "ZA" => Some(ElectricCurrentUnit::zettaampere),
                        "EA" => Some(ElectricCurrentUnit::exaampere),
                        "PA" => Some(ElectricCurrentUnit::petaampere),
                        "TA" => Some(ElectricCurrentUnit::teraampere),
                        "GA" => Some(ElectricCurrentUnit::gigaampere),
                        "MA" => Some(ElectricCurrentUnit::megaampere),
                        "kA" => Some(ElectricCurrentUnit::kiloampere),
                        "hA" => Some(ElectricCurrentUnit::hectoampere),
                        "daA" => Some(ElectricCurrentUnit::decaampere),
                        "A" => Some(ElectricCurrentUnit::ampere),
                        "dA" => Some(ElectricCurrentUnit::deciampere),
                        "cA" => Some(ElectricCurrentUnit::centiampere),
                        "mA" => Some(ElectricCurrentUnit::milliampere),
                        "A" => Some(ElectricCurrentUnit::microampere),
                        "nA" => Some(ElectricCurrentUnit::nanoampere),
                        "pA" => Some(ElectricCurrentUnit::picoampere),
                        "fA" => Some(ElectricCurrentUnit::femtoampere),
                        "aA" => Some(ElectricCurrentUnit::attoampere),
                        "zA" => Some(ElectricCurrentUnit::zeptoampere),
                        "yA" => Some(ElectricCurrentUnit::yoctoampere),
                        "e/s" =>
                            Some(ElectricCurrentUnit::elementary_charge_per_second),
                        "a.u. of charge/s" =>
                            Some(ElectricCurrentUnit::atomic_unit_of_charge_per_second),
                        "abA" => Some(ElectricCurrentUnit::abampere),
                        "Gi" => Some(ElectricCurrentUnit::gilbert),
                        "statA" => Some(ElectricCurrentUnit::statampere),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<ElectricCurrentUnit> =
                    match value {
                        "yottaampere" => Some(ElectricCurrentUnit::yottaampere),
                        "zettaampere" => Some(ElectricCurrentUnit::zettaampere),
                        "exaampere" => Some(ElectricCurrentUnit::exaampere),
                        "petaampere" => Some(ElectricCurrentUnit::petaampere),
                        "teraampere" => Some(ElectricCurrentUnit::teraampere),
                        "gigaampere" => Some(ElectricCurrentUnit::gigaampere),
                        "megaampere" => Some(ElectricCurrentUnit::megaampere),
                        "kiloampere" => Some(ElectricCurrentUnit::kiloampere),
                        "hectoampere" => Some(ElectricCurrentUnit::hectoampere),
                        "decaampere" => Some(ElectricCurrentUnit::decaampere),
                        "ampere" => Some(ElectricCurrentUnit::ampere),
                        "deciampere" => Some(ElectricCurrentUnit::deciampere),
                        "centiampere" => Some(ElectricCurrentUnit::centiampere),
                        "millampere" => Some(ElectricCurrentUnit::milliampere),
                        "microampere" => Some(ElectricCurrentUnit::microampere),
                        "nanoampere" => Some(ElectricCurrentUnit::nanoampere),
                        "picoampere" => Some(ElectricCurrentUnit::picoampere),
                        "femtoampere" => Some(ElectricCurrentUnit::femtoampere),
                        "attoampere" => Some(ElectricCurrentUnit::attoampere),
                        "zeptoampere" => Some(ElectricCurrentUnit::zeptoampere),
                        "yoctoampere" => Some(ElectricCurrentUnit::yoctoampere),
                        "elementary charge per second" =>
                            Some(ElectricCurrentUnit::elementary_charge_per_second),
                        "atomic UnitDefinition of charge per second" =>
                            Some(ElectricCurrentUnit::atomic_unit_of_charge_per_second),
                        "abampere" => Some(ElectricCurrentUnit::abampere),
                        "gilbert" => Some(ElectricCurrentUnit::gilbert),
                        "statampere" => Some(ElectricCurrentUnit::statampere),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<ElectricCurrentUnit> =
                    match value {
                        "yottaamperes" => Some(ElectricCurrentUnit::yottaampere),
                        "zettaamperes" => Some(ElectricCurrentUnit::zettaampere),
                        "exaamperes" => Some(ElectricCurrentUnit::exaampere),
                        "petaamperes" => Some(ElectricCurrentUnit::petaampere),
                        "teraamperes" => Some(ElectricCurrentUnit::teraampere),
                        "gigaamperes" => Some(ElectricCurrentUnit::gigaampere),
                        "megaamperes" => Some(ElectricCurrentUnit::megaampere),
                        "kiloamperes" => Some(ElectricCurrentUnit::kiloampere),
                        "hectoamperes" => Some(ElectricCurrentUnit::hectoampere),
                        "decaamperes" => Some(ElectricCurrentUnit::decaampere),
                        "amperes" => Some(ElectricCurrentUnit::ampere),
                        "deciamperes" => Some(ElectricCurrentUnit::deciampere),
                        "centiamperes" => Some(ElectricCurrentUnit::centiampere),
                        "millamperes" => Some(ElectricCurrentUnit::milliampere),
                        "microamperes" => Some(ElectricCurrentUnit::microampere),
                        "nanoamperes" => Some(ElectricCurrentUnit::nanoampere),
                        "picoamperes" => Some(ElectricCurrentUnit::picoampere),
                        "femtoamperes" => Some(ElectricCurrentUnit::femtoampere),
                        "attoamperes" => Some(ElectricCurrentUnit::attoampere),
                        "zeptoamperes" => Some(ElectricCurrentUnit::zeptoampere),
                        "yoctoamperes" => Some(ElectricCurrentUnit::yoctoampere),
                        "elementary charges per second" =>
                            Some(ElectricCurrentUnit::elementary_charge_per_second),
                        "atomic units of charge per second" =>
                            Some(ElectricCurrentUnit::atomic_unit_of_charge_per_second),
                        "abamperes" => Some(ElectricCurrentUnit::abampere),
                        "gilberts" => Some(ElectricCurrentUnit::gilbert),
                        "statamperes" => Some(ElectricCurrentUnit::statampere),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"ElectricCurrent\"")
                   }
            }
        }
        impl core::fmt::Display for ElectricCurrentUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    ElectricCurrentUnit::yottaampere =>
                        f.write_fmt(format_args!("{0}", "yottaampere")),
                    ElectricCurrentUnit::zettaampere =>
                        f.write_fmt(format_args!("{0}", "zettaampere")),
                    ElectricCurrentUnit::exaampere =>
                        f.write_fmt(format_args!("{0}", "exaampere")),
                    ElectricCurrentUnit::petaampere =>
                        f.write_fmt(format_args!("{0}", "petaampere")),
                    ElectricCurrentUnit::teraampere =>
                        f.write_fmt(format_args!("{0}", "teraampere")),
                    ElectricCurrentUnit::gigaampere =>
                        f.write_fmt(format_args!("{0}", "gigaampere")),
                    ElectricCurrentUnit::megaampere =>
                        f.write_fmt(format_args!("{0}", "megaampere")),
                    ElectricCurrentUnit::kiloampere =>
                        f.write_fmt(format_args!("{0}", "kiloampere")),
                    ElectricCurrentUnit::hectoampere =>
                        f.write_fmt(format_args!("{0}", "hectoampere")),
                    ElectricCurrentUnit::decaampere =>
                        f.write_fmt(format_args!("{0}", "decaampere")),
                    ElectricCurrentUnit::ampere =>
                        f.write_fmt(format_args!("{0}", "ampere")),
                    ElectricCurrentUnit::deciampere =>
                        f.write_fmt(format_args!("{0}", "deciampere")),
                    ElectricCurrentUnit::centiampere =>
                        f.write_fmt(format_args!("{0}", "centiampere")),
                    ElectricCurrentUnit::milliampere =>
                        f.write_fmt(format_args!("{0}", "millampere")),
                    ElectricCurrentUnit::microampere =>
                        f.write_fmt(format_args!("{0}", "microampere")),
                    ElectricCurrentUnit::nanoampere =>
                        f.write_fmt(format_args!("{0}", "nanoampere")),
                    ElectricCurrentUnit::picoampere =>
                        f.write_fmt(format_args!("{0}", "picoampere")),
                    ElectricCurrentUnit::femtoampere =>
                        f.write_fmt(format_args!("{0}", "femtoampere")),
                    ElectricCurrentUnit::attoampere =>
                        f.write_fmt(format_args!("{0}", "attoampere")),
                    ElectricCurrentUnit::zeptoampere =>
                        f.write_fmt(format_args!("{0}", "zeptoampere")),
                    ElectricCurrentUnit::yoctoampere =>
                        f.write_fmt(format_args!("{0}", "yoctoampere")),
                    ElectricCurrentUnit::elementary_charge_per_second =>
                        f.write_fmt(format_args!("{0}",
                                "elementary charge per second")),
                    ElectricCurrentUnit::atomic_unit_of_charge_per_second =>
                        f.write_fmt(format_args!("{0}",
                                "atomic UnitDefinition of charge per second")),
                    ElectricCurrentUnit::abampere =>
                        f.write_fmt(format_args!("{0}", "abampere")),
                    ElectricCurrentUnit::gilbert =>
                        f.write_fmt(format_args!("{0}", "gilbert")),
                    ElectricCurrentUnit::statampere =>
                        f.write_fmt(format_args!("{0}", "statampere")),
                }
            }
        }
    }
    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
    pub use crate::unit_definitions::electric_current::ElectricCurrentArray;
    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
    pub use crate::unit_definitions::electric_current::ElectricCurrent;
    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
    pub use crate::unit_definitions::electric_current::ElectricCurrentVec;
    #[cfg(any(feature = "Length", feature = "All"))]
    mod length {
        //! Length (base UnitDefinition meter, m).
        use crate::{prefix, quantity};
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Length (base UnitDefinition meter, m)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "LengthUnit")]
        pub enum LengthUnit {
            yottameter,
            zettameter,
            exameter,
            petameter,
            terameter,
            gigameter,
            megameter,
            kilometer,
            hectometer,
            decameter,
            meter,
            decimeter,
            centimeter,
            millimeter,
            micrometer,
            nanometer,
            picometer,
            femtometer,
            attometer,
            zeptometer,
            yoctometer,
            angstrom,
            bohr_radius,
            atomic_unit_of_length,
            astronomical_unit,
            chain,
            fathom,
            fermi,
            foot,
            kilofoot,
            foot_survey,
            inch,
            light_year,
            microinch,
            micron,
            mil,
            mile,
            mile_survey,
            nautical_mile,
            parsec,
            pica_computer,
            pica_printers,
            point_computer,
            point_printers,
            rod,
            yard,
        }
        impl utoipa::__dev::ComposeSchema for LengthUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 46usize],
                                &str>(Some(["yottameter", "zettameter", "exameter",
                                            "petameter", "terameter", "gigameter", "megameter",
                                            "kilometer", "hectometer", "decameter", "meter",
                                            "decimeter", "centimeter", "millimeter", "micrometer",
                                            "nanometer", "picometer", "femtometer", "attometer",
                                            "zeptometer", "yoctometer", "angstrom", "bohr_radius",
                                            "atomic_unit_of_length", "astronomical_unit", "chain",
                                            "fathom", "fermi", "foot", "kilofoot", "foot_survey",
                                            "inch", "light_year", "microinch", "micron", "mil", "mile",
                                            "mile_survey", "nautical_mile", "parsec", "pica_computer",
                                            "pica_printers", "point_computer", "point_printers", "rod",
                                            "yard"])).title(Some("LengthUnit")).description(Some("Length (base UnitDefinition meter, m).")).into()
            }
        }
        impl utoipa::ToSchema for LengthUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("LengthUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LengthUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            LengthUnit::yottameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 0u32, "yottameter"),
                            LengthUnit::zettameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 1u32, "zettameter"),
                            LengthUnit::exameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 2u32, "exameter"),
                            LengthUnit::petameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 3u32, "petameter"),
                            LengthUnit::terameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 4u32, "terameter"),
                            LengthUnit::gigameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 5u32, "gigameter"),
                            LengthUnit::megameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 6u32, "megameter"),
                            LengthUnit::kilometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 7u32, "kilometer"),
                            LengthUnit::hectometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 8u32, "hectometer"),
                            LengthUnit::decameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 9u32, "decameter"),
                            LengthUnit::meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 10u32, "meter"),
                            LengthUnit::decimeter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 11u32, "decimeter"),
                            LengthUnit::centimeter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 12u32, "centimeter"),
                            LengthUnit::millimeter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 13u32, "millimeter"),
                            LengthUnit::micrometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 14u32, "micrometer"),
                            LengthUnit::nanometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 15u32, "nanometer"),
                            LengthUnit::picometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 16u32, "picometer"),
                            LengthUnit::femtometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 17u32, "femtometer"),
                            LengthUnit::attometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 18u32, "attometer"),
                            LengthUnit::zeptometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 19u32, "zeptometer"),
                            LengthUnit::yoctometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 20u32, "yoctometer"),
                            LengthUnit::angstrom =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 21u32, "angstrom"),
                            LengthUnit::bohr_radius =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 22u32, "bohr_radius"),
                            LengthUnit::atomic_unit_of_length =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 23u32, "atomic_unit_of_length"),
                            LengthUnit::astronomical_unit =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 24u32, "astronomical_unit"),
                            LengthUnit::chain =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 25u32, "chain"),
                            LengthUnit::fathom =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 26u32, "fathom"),
                            LengthUnit::fermi =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 27u32, "fermi"),
                            LengthUnit::foot =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 28u32, "foot"),
                            LengthUnit::kilofoot =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 29u32, "kilofoot"),
                            LengthUnit::foot_survey =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 30u32, "foot_survey"),
                            LengthUnit::inch =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 31u32, "inch"),
                            LengthUnit::light_year =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 32u32, "light_year"),
                            LengthUnit::microinch =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 33u32, "microinch"),
                            LengthUnit::micron =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 34u32, "micron"),
                            LengthUnit::mil =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 35u32, "mil"),
                            LengthUnit::mile =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 36u32, "mile"),
                            LengthUnit::mile_survey =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 37u32, "mile_survey"),
                            LengthUnit::nautical_mile =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 38u32, "nautical_mile"),
                            LengthUnit::parsec =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 39u32, "parsec"),
                            LengthUnit::pica_computer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 40u32, "pica_computer"),
                            LengthUnit::pica_printers =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 41u32, "pica_printers"),
                            LengthUnit::point_computer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 42u32, "point_computer"),
                            LengthUnit::point_printers =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 43u32, "point_printers"),
                            LengthUnit::rod =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 44u32, "rod"),
                            LengthUnit::yard =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LengthUnit", 45u32, "yard"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LengthUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                            __field24,
                            __field25,
                            __field26,
                            __field27,
                            __field28,
                            __field29,
                            __field30,
                            __field31,
                            __field32,
                            __field33,
                            __field34,
                            __field35,
                            __field36,
                            __field37,
                            __field38,
                            __field39,
                            __field40,
                            __field41,
                            __field42,
                            __field43,
                            __field44,
                            __field45,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    17u64 => _serde::__private::Ok(__Field::__field17),
                                    18u64 => _serde::__private::Ok(__Field::__field18),
                                    19u64 => _serde::__private::Ok(__Field::__field19),
                                    20u64 => _serde::__private::Ok(__Field::__field20),
                                    21u64 => _serde::__private::Ok(__Field::__field21),
                                    22u64 => _serde::__private::Ok(__Field::__field22),
                                    23u64 => _serde::__private::Ok(__Field::__field23),
                                    24u64 => _serde::__private::Ok(__Field::__field24),
                                    25u64 => _serde::__private::Ok(__Field::__field25),
                                    26u64 => _serde::__private::Ok(__Field::__field26),
                                    27u64 => _serde::__private::Ok(__Field::__field27),
                                    28u64 => _serde::__private::Ok(__Field::__field28),
                                    29u64 => _serde::__private::Ok(__Field::__field29),
                                    30u64 => _serde::__private::Ok(__Field::__field30),
                                    31u64 => _serde::__private::Ok(__Field::__field31),
                                    32u64 => _serde::__private::Ok(__Field::__field32),
                                    33u64 => _serde::__private::Ok(__Field::__field33),
                                    34u64 => _serde::__private::Ok(__Field::__field34),
                                    35u64 => _serde::__private::Ok(__Field::__field35),
                                    36u64 => _serde::__private::Ok(__Field::__field36),
                                    37u64 => _serde::__private::Ok(__Field::__field37),
                                    38u64 => _serde::__private::Ok(__Field::__field38),
                                    39u64 => _serde::__private::Ok(__Field::__field39),
                                    40u64 => _serde::__private::Ok(__Field::__field40),
                                    41u64 => _serde::__private::Ok(__Field::__field41),
                                    42u64 => _serde::__private::Ok(__Field::__field42),
                                    43u64 => _serde::__private::Ok(__Field::__field43),
                                    44u64 => _serde::__private::Ok(__Field::__field44),
                                    45u64 => _serde::__private::Ok(__Field::__field45),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 46")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "yottameter" => _serde::__private::Ok(__Field::__field0),
                                    "zettameter" => _serde::__private::Ok(__Field::__field1),
                                    "exameter" => _serde::__private::Ok(__Field::__field2),
                                    "petameter" => _serde::__private::Ok(__Field::__field3),
                                    "terameter" => _serde::__private::Ok(__Field::__field4),
                                    "gigameter" => _serde::__private::Ok(__Field::__field5),
                                    "megameter" => _serde::__private::Ok(__Field::__field6),
                                    "kilometer" => _serde::__private::Ok(__Field::__field7),
                                    "hectometer" => _serde::__private::Ok(__Field::__field8),
                                    "decameter" => _serde::__private::Ok(__Field::__field9),
                                    "meter" => _serde::__private::Ok(__Field::__field10),
                                    "decimeter" => _serde::__private::Ok(__Field::__field11),
                                    "centimeter" => _serde::__private::Ok(__Field::__field12),
                                    "millimeter" => _serde::__private::Ok(__Field::__field13),
                                    "micrometer" => _serde::__private::Ok(__Field::__field14),
                                    "nanometer" => _serde::__private::Ok(__Field::__field15),
                                    "picometer" => _serde::__private::Ok(__Field::__field16),
                                    "femtometer" => _serde::__private::Ok(__Field::__field17),
                                    "attometer" => _serde::__private::Ok(__Field::__field18),
                                    "zeptometer" => _serde::__private::Ok(__Field::__field19),
                                    "yoctometer" => _serde::__private::Ok(__Field::__field20),
                                    "angstrom" => _serde::__private::Ok(__Field::__field21),
                                    "bohr_radius" => _serde::__private::Ok(__Field::__field22),
                                    "atomic_unit_of_length" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    "astronomical_unit" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    "chain" => _serde::__private::Ok(__Field::__field25),
                                    "fathom" => _serde::__private::Ok(__Field::__field26),
                                    "fermi" => _serde::__private::Ok(__Field::__field27),
                                    "foot" => _serde::__private::Ok(__Field::__field28),
                                    "kilofoot" => _serde::__private::Ok(__Field::__field29),
                                    "foot_survey" => _serde::__private::Ok(__Field::__field30),
                                    "inch" => _serde::__private::Ok(__Field::__field31),
                                    "light_year" => _serde::__private::Ok(__Field::__field32),
                                    "microinch" => _serde::__private::Ok(__Field::__field33),
                                    "micron" => _serde::__private::Ok(__Field::__field34),
                                    "mil" => _serde::__private::Ok(__Field::__field35),
                                    "mile" => _serde::__private::Ok(__Field::__field36),
                                    "mile_survey" => _serde::__private::Ok(__Field::__field37),
                                    "nautical_mile" =>
                                        _serde::__private::Ok(__Field::__field38),
                                    "parsec" => _serde::__private::Ok(__Field::__field39),
                                    "pica_computer" =>
                                        _serde::__private::Ok(__Field::__field40),
                                    "pica_printers" =>
                                        _serde::__private::Ok(__Field::__field41),
                                    "point_computer" =>
                                        _serde::__private::Ok(__Field::__field42),
                                    "point_printers" =>
                                        _serde::__private::Ok(__Field::__field43),
                                    "rod" => _serde::__private::Ok(__Field::__field44),
                                    "yard" => _serde::__private::Ok(__Field::__field45),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"yottameter" => _serde::__private::Ok(__Field::__field0),
                                    b"zettameter" => _serde::__private::Ok(__Field::__field1),
                                    b"exameter" => _serde::__private::Ok(__Field::__field2),
                                    b"petameter" => _serde::__private::Ok(__Field::__field3),
                                    b"terameter" => _serde::__private::Ok(__Field::__field4),
                                    b"gigameter" => _serde::__private::Ok(__Field::__field5),
                                    b"megameter" => _serde::__private::Ok(__Field::__field6),
                                    b"kilometer" => _serde::__private::Ok(__Field::__field7),
                                    b"hectometer" => _serde::__private::Ok(__Field::__field8),
                                    b"decameter" => _serde::__private::Ok(__Field::__field9),
                                    b"meter" => _serde::__private::Ok(__Field::__field10),
                                    b"decimeter" => _serde::__private::Ok(__Field::__field11),
                                    b"centimeter" => _serde::__private::Ok(__Field::__field12),
                                    b"millimeter" => _serde::__private::Ok(__Field::__field13),
                                    b"micrometer" => _serde::__private::Ok(__Field::__field14),
                                    b"nanometer" => _serde::__private::Ok(__Field::__field15),
                                    b"picometer" => _serde::__private::Ok(__Field::__field16),
                                    b"femtometer" => _serde::__private::Ok(__Field::__field17),
                                    b"attometer" => _serde::__private::Ok(__Field::__field18),
                                    b"zeptometer" => _serde::__private::Ok(__Field::__field19),
                                    b"yoctometer" => _serde::__private::Ok(__Field::__field20),
                                    b"angstrom" => _serde::__private::Ok(__Field::__field21),
                                    b"bohr_radius" => _serde::__private::Ok(__Field::__field22),
                                    b"atomic_unit_of_length" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    b"astronomical_unit" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    b"chain" => _serde::__private::Ok(__Field::__field25),
                                    b"fathom" => _serde::__private::Ok(__Field::__field26),
                                    b"fermi" => _serde::__private::Ok(__Field::__field27),
                                    b"foot" => _serde::__private::Ok(__Field::__field28),
                                    b"kilofoot" => _serde::__private::Ok(__Field::__field29),
                                    b"foot_survey" => _serde::__private::Ok(__Field::__field30),
                                    b"inch" => _serde::__private::Ok(__Field::__field31),
                                    b"light_year" => _serde::__private::Ok(__Field::__field32),
                                    b"microinch" => _serde::__private::Ok(__Field::__field33),
                                    b"micron" => _serde::__private::Ok(__Field::__field34),
                                    b"mil" => _serde::__private::Ok(__Field::__field35),
                                    b"mile" => _serde::__private::Ok(__Field::__field36),
                                    b"mile_survey" => _serde::__private::Ok(__Field::__field37),
                                    b"nautical_mile" =>
                                        _serde::__private::Ok(__Field::__field38),
                                    b"parsec" => _serde::__private::Ok(__Field::__field39),
                                    b"pica_computer" =>
                                        _serde::__private::Ok(__Field::__field40),
                                    b"pica_printers" =>
                                        _serde::__private::Ok(__Field::__field41),
                                    b"point_computer" =>
                                        _serde::__private::Ok(__Field::__field42),
                                    b"point_printers" =>
                                        _serde::__private::Ok(__Field::__field43),
                                    b"rod" => _serde::__private::Ok(__Field::__field44),
                                    b"yard" => _serde::__private::Ok(__Field::__field45),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LengthUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LengthUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum LengthUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::yottameter)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::zettameter)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::exameter)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::petameter)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::terameter)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::gigameter)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::megameter)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::kilometer)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::hectometer)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::decameter)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::meter)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::decimeter)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::centimeter)
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::millimeter)
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::micrometer)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::nanometer)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::picometer)
                                    }
                                    (__Field::__field17, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::femtometer)
                                    }
                                    (__Field::__field18, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::attometer)
                                    }
                                    (__Field::__field19, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::zeptometer)
                                    }
                                    (__Field::__field20, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::yoctometer)
                                    }
                                    (__Field::__field21, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::angstrom)
                                    }
                                    (__Field::__field22, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::bohr_radius)
                                    }
                                    (__Field::__field23, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::atomic_unit_of_length)
                                    }
                                    (__Field::__field24, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::astronomical_unit)
                                    }
                                    (__Field::__field25, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::chain)
                                    }
                                    (__Field::__field26, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::fathom)
                                    }
                                    (__Field::__field27, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::fermi)
                                    }
                                    (__Field::__field28, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::foot)
                                    }
                                    (__Field::__field29, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::kilofoot)
                                    }
                                    (__Field::__field30, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::foot_survey)
                                    }
                                    (__Field::__field31, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::inch)
                                    }
                                    (__Field::__field32, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::light_year)
                                    }
                                    (__Field::__field33, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::microinch)
                                    }
                                    (__Field::__field34, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::micron)
                                    }
                                    (__Field::__field35, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::mil)
                                    }
                                    (__Field::__field36, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::mile)
                                    }
                                    (__Field::__field37, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::mile_survey)
                                    }
                                    (__Field::__field38, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::nautical_mile)
                                    }
                                    (__Field::__field39, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::parsec)
                                    }
                                    (__Field::__field40, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::pica_computer)
                                    }
                                    (__Field::__field41, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::pica_printers)
                                    }
                                    (__Field::__field42, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::point_computer)
                                    }
                                    (__Field::__field43, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::point_printers)
                                    }
                                    (__Field::__field44, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::rod)
                                    }
                                    (__Field::__field45, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LengthUnit::yard)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["yottameter", "zettameter", "exameter", "petameter",
                                        "terameter", "gigameter", "megameter", "kilometer",
                                        "hectometer", "decameter", "meter", "decimeter",
                                        "centimeter", "millimeter", "micrometer", "nanometer",
                                        "picometer", "femtometer", "attometer", "zeptometer",
                                        "yoctometer", "angstrom", "bohr_radius",
                                        "atomic_unit_of_length", "astronomical_unit", "chain",
                                        "fathom", "fermi", "foot", "kilofoot", "foot_survey",
                                        "inch", "light_year", "microinch", "micron", "mil", "mile",
                                        "mile_survey", "nautical_mile", "parsec", "pica_computer",
                                        "pica_printers", "point_computer", "point_printers", "rod",
                                        "yard"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "LengthUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LengthUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for LengthUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for LengthUnit {
            #[inline]
            fn clone(&self) -> LengthUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for LengthUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        LengthUnit::yottameter => "yottameter",
                        LengthUnit::zettameter => "zettameter",
                        LengthUnit::exameter => "exameter",
                        LengthUnit::petameter => "petameter",
                        LengthUnit::terameter => "terameter",
                        LengthUnit::gigameter => "gigameter",
                        LengthUnit::megameter => "megameter",
                        LengthUnit::kilometer => "kilometer",
                        LengthUnit::hectometer => "hectometer",
                        LengthUnit::decameter => "decameter",
                        LengthUnit::meter => "meter",
                        LengthUnit::decimeter => "decimeter",
                        LengthUnit::centimeter => "centimeter",
                        LengthUnit::millimeter => "millimeter",
                        LengthUnit::micrometer => "micrometer",
                        LengthUnit::nanometer => "nanometer",
                        LengthUnit::picometer => "picometer",
                        LengthUnit::femtometer => "femtometer",
                        LengthUnit::attometer => "attometer",
                        LengthUnit::zeptometer => "zeptometer",
                        LengthUnit::yoctometer => "yoctometer",
                        LengthUnit::angstrom => "angstrom",
                        LengthUnit::bohr_radius => "bohr_radius",
                        LengthUnit::atomic_unit_of_length =>
                            "atomic_unit_of_length",
                        LengthUnit::astronomical_unit => "astronomical_unit",
                        LengthUnit::chain => "chain",
                        LengthUnit::fathom => "fathom",
                        LengthUnit::fermi => "fermi",
                        LengthUnit::foot => "foot",
                        LengthUnit::kilofoot => "kilofoot",
                        LengthUnit::foot_survey => "foot_survey",
                        LengthUnit::inch => "inch",
                        LengthUnit::light_year => "light_year",
                        LengthUnit::microinch => "microinch",
                        LengthUnit::micron => "micron",
                        LengthUnit::mil => "mil",
                        LengthUnit::mile => "mile",
                        LengthUnit::mile_survey => "mile_survey",
                        LengthUnit::nautical_mile => "nautical_mile",
                        LengthUnit::parsec => "parsec",
                        LengthUnit::pica_computer => "pica_computer",
                        LengthUnit::pica_printers => "pica_printers",
                        LengthUnit::point_computer => "point_computer",
                        LengthUnit::point_printers => "point_printers",
                        LengthUnit::rod => "rod",
                        LengthUnit::yard => "yard",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for LengthUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for LengthUnit {
            #[inline]
            fn eq(&self, other: &LengthUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for LengthUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for LengthUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const LENGTH_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::P1,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const LENGTH_YOTTAMETER_CONVERSION: f64 = 1.0_E24;
        pub(crate) const LENGTH_ZETTAMETER_CONVERSION: f64 = 1.0_E21;
        pub(crate) const LENGTH_EXAMETER_CONVERSION: f64 = 1.0_E18;
        pub(crate) const LENGTH_PETAMETER_CONVERSION: f64 = 1.0_E15;
        pub(crate) const LENGTH_TERAMETER_CONVERSION: f64 = 1.0_E12;
        pub(crate) const LENGTH_GIGAMETER_CONVERSION: f64 = 1.0_E9;
        pub(crate) const LENGTH_MEGAMETER_CONVERSION: f64 = 1.0_E6;
        pub(crate) const LENGTH_KILOMETER_CONVERSION: f64 = 1.0_E3;
        pub(crate) const LENGTH_HECTOMETER_CONVERSION: f64 = 1.0_E2;
        pub(crate) const LENGTH_DECAMETER_CONVERSION: f64 = 1.0_E1;
        pub(crate) const LENGTH_METER_CONVERSION: f64 = 1.0_E0;
        pub(crate) const LENGTH_DECIMETER_CONVERSION: f64 = 1.0_E-1;
        pub(crate) const LENGTH_CENTIMETER_CONVERSION: f64 = 1.0_E-2;
        pub(crate) const LENGTH_MILLIMETER_CONVERSION: f64 = 1.0_E-3;
        pub(crate) const LENGTH_MICROMETER_CONVERSION: f64 = 1.0_E-6;
        pub(crate) const LENGTH_NANOMETER_CONVERSION: f64 = 1.0_E-9;
        pub(crate) const LENGTH_PICOMETER_CONVERSION: f64 = 1.0_E-12;
        pub(crate) const LENGTH_FEMTOMETER_CONVERSION: f64 = 1.0_E-15;
        pub(crate) const LENGTH_ATTOMETER_CONVERSION: f64 = 1.0_E-18;
        pub(crate) const LENGTH_ZEPTOMETER_CONVERSION: f64 = 1.0_E-21;
        pub(crate) const LENGTH_YOCTOMETER_CONVERSION: f64 = 1.0_E-24;
        pub(crate) const LENGTH_ANGSTROM_CONVERSION: f64 = 1.0_E-10;
        pub(crate) const LENGTH_BOHR_RADIUS_CONVERSION: f64 =
            5.291_772_109_03_E-11;
        pub(crate) const LENGTH_ATOMIC_UNIT_OF_LENGTH_CONVERSION: f64 =
            5.291_772_109_03_E-11;
        pub(crate) const LENGTH_ASTRONOMICAL_UNIT_CONVERSION: f64 =
            1.495_979_E11;
        pub(crate) const LENGTH_CHAIN_CONVERSION: f64 = 2.011_684_E1;
        pub(crate) const LENGTH_FATHOM_CONVERSION: f64 = 1.828_804_E0;
        pub(crate) const LENGTH_FERMI_CONVERSION: f64 = 1.0_E-15;
        pub(crate) const LENGTH_FOOT_CONVERSION: f64 = 3.048_E-1;
        pub(crate) const LENGTH_KILOFOOT_CONVERSION: f64 = 3.048_E-1 * 1.0_E3;
        pub(crate) const LENGTH_FOOT_SURVEY_CONVERSION: f64 = 3.048_006_E-1;
        pub(crate) const LENGTH_INCH_CONVERSION: f64 = 2.54_E-2;
        pub(crate) const LENGTH_LIGHT_YEAR_CONVERSION: f64 = 9.460_73_E15;
        pub(crate) const LENGTH_MICROINCH_CONVERSION: f64 = 2.54_E-8;
        pub(crate) const LENGTH_MICRON_CONVERSION: f64 = 1.0_E-6;
        pub(crate) const LENGTH_MIL_CONVERSION: f64 = 2.54_E-5;
        pub(crate) const LENGTH_MILE_CONVERSION: f64 = 1.609_344_E3;
        pub(crate) const LENGTH_MILE_SURVEY_CONVERSION: f64 = 1.609_347_E3;
        pub(crate) const LENGTH_NAUTICAL_MILE_CONVERSION: f64 = 1.852_E3;
        pub(crate) const LENGTH_PARSEC_CONVERSION: f64 = 3.085_678_E16;
        pub(crate) const LENGTH_PICA_COMPUTER_CONVERSION: f64 =
            4.233_333_333_333_333_E-3;
        pub(crate) const LENGTH_PICA_PRINTERS_CONVERSION: f64 = 4.217_518_E-3;
        pub(crate) const LENGTH_POINT_COMPUTER_CONVERSION: f64 =
            3.527_778_E-4;
        pub(crate) const LENGTH_POINT_PRINTERS_CONVERSION: f64 =
            3.514_598_E-4;
        pub(crate) const LENGTH_ROD_CONVERSION: f64 = 5.029_21_E0;
        pub(crate) const LENGTH_YARD_CONVERSION: f64 = 9.144_E-1;
        impl LengthUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_yottameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_YOTTAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zettameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_ZETTAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_exameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_EXAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_petameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_PETAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_terameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_TERAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gigameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_GIGAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_megameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MEGAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kilometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_KILOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hectometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_HECTOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decameter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_DECAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decimeter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_DECIMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_centimeter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_CENTIMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_millimeter() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MILLIMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_micrometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MICROMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nanometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_NANOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_picometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_PICOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_femtometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_FEMTOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_attometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_ATTOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zeptometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_ZEPTOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yoctometer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_YOCTOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_angstrom() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_ANGSTROM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_bohr_radius() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_BOHR_RADIUS_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_atomic_unit_of_length() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_ATOMIC_UNIT_OF_LENGTH_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_astronomical_unit() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_ASTRONOMICAL_UNIT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_chain() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_CHAIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_fathom() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_FATHOM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_fermi() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_FERMI_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_foot() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_FOOT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kilofoot() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_KILOFOOT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_foot_survey() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_FOOT_SURVEY_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_inch() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_INCH_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_light_year() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_LIGHT_YEAR_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_microinch() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MICROINCH_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_micron() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MICRON_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_mil() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MIL_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_mile() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MILE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_mile_survey() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_MILE_SURVEY_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nautical_mile() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_NAUTICAL_MILE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_parsec() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_PARSEC_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_pica_computer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_PICA_COMPUTER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_pica_printers() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_PICA_PRINTERS_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_point_computer() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_POINT_COMPUTER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_point_printers() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_POINT_PRINTERS_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_rod() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_ROD_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yard() -> UnitDefinition {
                UnitDefinition {
                    base: LENGTH_UNIT_BASE,
                    multiplier: LENGTH_YARD_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    LengthUnit::yottameter => LENGTH_YOTTAMETER_CONVERSION,
                    LengthUnit::zettameter => LENGTH_ZETTAMETER_CONVERSION,
                    LengthUnit::exameter => LENGTH_EXAMETER_CONVERSION,
                    LengthUnit::petameter => LENGTH_PETAMETER_CONVERSION,
                    LengthUnit::terameter => LENGTH_TERAMETER_CONVERSION,
                    LengthUnit::gigameter => LENGTH_GIGAMETER_CONVERSION,
                    LengthUnit::megameter => LENGTH_MEGAMETER_CONVERSION,
                    LengthUnit::kilometer => LENGTH_KILOMETER_CONVERSION,
                    LengthUnit::hectometer => LENGTH_HECTOMETER_CONVERSION,
                    LengthUnit::decameter => LENGTH_DECAMETER_CONVERSION,
                    LengthUnit::meter => LENGTH_METER_CONVERSION,
                    LengthUnit::decimeter => LENGTH_DECIMETER_CONVERSION,
                    LengthUnit::centimeter => LENGTH_CENTIMETER_CONVERSION,
                    LengthUnit::millimeter => LENGTH_MILLIMETER_CONVERSION,
                    LengthUnit::micrometer => LENGTH_MICROMETER_CONVERSION,
                    LengthUnit::nanometer => LENGTH_NANOMETER_CONVERSION,
                    LengthUnit::picometer => LENGTH_PICOMETER_CONVERSION,
                    LengthUnit::femtometer => LENGTH_FEMTOMETER_CONVERSION,
                    LengthUnit::attometer => LENGTH_ATTOMETER_CONVERSION,
                    LengthUnit::zeptometer => LENGTH_ZEPTOMETER_CONVERSION,
                    LengthUnit::yoctometer => LENGTH_YOCTOMETER_CONVERSION,
                    LengthUnit::angstrom => LENGTH_ANGSTROM_CONVERSION,
                    LengthUnit::bohr_radius => LENGTH_BOHR_RADIUS_CONVERSION,
                    LengthUnit::atomic_unit_of_length =>
                        LENGTH_ATOMIC_UNIT_OF_LENGTH_CONVERSION,
                    LengthUnit::astronomical_unit =>
                        LENGTH_ASTRONOMICAL_UNIT_CONVERSION,
                    LengthUnit::chain => LENGTH_CHAIN_CONVERSION,
                    LengthUnit::fathom => LENGTH_FATHOM_CONVERSION,
                    LengthUnit::fermi => LENGTH_FERMI_CONVERSION,
                    LengthUnit::foot => LENGTH_FOOT_CONVERSION,
                    LengthUnit::kilofoot => LENGTH_KILOFOOT_CONVERSION,
                    LengthUnit::foot_survey => LENGTH_FOOT_SURVEY_CONVERSION,
                    LengthUnit::inch => LENGTH_INCH_CONVERSION,
                    LengthUnit::light_year => LENGTH_LIGHT_YEAR_CONVERSION,
                    LengthUnit::microinch => LENGTH_MICROINCH_CONVERSION,
                    LengthUnit::micron => LENGTH_MICRON_CONVERSION,
                    LengthUnit::mil => LENGTH_MIL_CONVERSION,
                    LengthUnit::mile => LENGTH_MILE_CONVERSION,
                    LengthUnit::mile_survey => LENGTH_MILE_SURVEY_CONVERSION,
                    LengthUnit::nautical_mile =>
                        LENGTH_NAUTICAL_MILE_CONVERSION,
                    LengthUnit::parsec => LENGTH_PARSEC_CONVERSION,
                    LengthUnit::pica_computer =>
                        LENGTH_PICA_COMPUTER_CONVERSION,
                    LengthUnit::pica_printers =>
                        LENGTH_PICA_PRINTERS_CONVERSION,
                    LengthUnit::point_computer =>
                        LENGTH_POINT_COMPUTER_CONVERSION,
                    LengthUnit::point_printers =>
                        LENGTH_POINT_PRINTERS_CONVERSION,
                    LengthUnit::rod => LENGTH_ROD_CONVERSION,
                    LengthUnit::yard => LENGTH_YARD_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    LengthUnit::yottameter => "Ym",
                    LengthUnit::zettameter => "Zm",
                    LengthUnit::exameter => "Em",
                    LengthUnit::petameter => "Pm",
                    LengthUnit::terameter => "Tm",
                    LengthUnit::gigameter => "Gm",
                    LengthUnit::megameter => "Mm",
                    LengthUnit::kilometer => "km",
                    LengthUnit::hectometer => "hm",
                    LengthUnit::decameter => "dam",
                    LengthUnit::meter => "m",
                    LengthUnit::decimeter => "dm",
                    LengthUnit::centimeter => "cm",
                    LengthUnit::millimeter => "mm",
                    LengthUnit::micrometer => "m",
                    LengthUnit::nanometer => "nm",
                    LengthUnit::picometer => "pm",
                    LengthUnit::femtometer => "fm",
                    LengthUnit::attometer => "am",
                    LengthUnit::zeptometer => "zm",
                    LengthUnit::yoctometer => "ym",
                    LengthUnit::angstrom => "",
                    LengthUnit::bohr_radius => "a",
                    LengthUnit::atomic_unit_of_length => "a.u. of length",
                    LengthUnit::astronomical_unit => "ua",
                    LengthUnit::chain => "ch",
                    LengthUnit::fathom => "fathom",
                    LengthUnit::fermi => "fermi",
                    LengthUnit::foot => "ft",
                    LengthUnit::kilofoot => "kft",
                    LengthUnit::foot_survey => "ft (U.S. survey)",
                    LengthUnit::inch => "in",
                    LengthUnit::light_year => "l. y.",
                    LengthUnit::microinch => "in",
                    LengthUnit::micron => "",
                    LengthUnit::mil => "0.001 in",
                    LengthUnit::mile => "mi",
                    LengthUnit::mile_survey => "mi (U.S. survey)",
                    LengthUnit::nautical_mile => "NM",
                    LengthUnit::parsec => "pc",
                    LengthUnit::pica_computer => "1/6 in (computer)",
                    LengthUnit::pica_printers => "1/6 in",
                    LengthUnit::point_computer => "1/72 in (computer)",
                    LengthUnit::point_printers => "1/72 in",
                    LengthUnit::rod => "rd",
                    LengthUnit::yard => "yd",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    LengthUnit::yottameter => "yottameter",
                    LengthUnit::zettameter => "zettameter",
                    LengthUnit::exameter => "exameter",
                    LengthUnit::petameter => "petameter",
                    LengthUnit::terameter => "terameter",
                    LengthUnit::gigameter => "gigameter",
                    LengthUnit::megameter => "megameter",
                    LengthUnit::kilometer => "kilometer",
                    LengthUnit::hectometer => "hectometer",
                    LengthUnit::decameter => "decameter",
                    LengthUnit::meter => "meter",
                    LengthUnit::decimeter => "decimeter",
                    LengthUnit::centimeter => "centimeter",
                    LengthUnit::millimeter => "millimeter",
                    LengthUnit::micrometer => "micrometer",
                    LengthUnit::nanometer => "nanometer",
                    LengthUnit::picometer => "picometer",
                    LengthUnit::femtometer => "femtometer",
                    LengthUnit::attometer => "attometer",
                    LengthUnit::zeptometer => "zeptometer",
                    LengthUnit::yoctometer => "yoctometer",
                    LengthUnit::angstrom => "ngstrm",
                    LengthUnit::bohr_radius => "bohr radius",
                    LengthUnit::atomic_unit_of_length =>
                        "atomic UnitDefinition of length",
                    LengthUnit::astronomical_unit =>
                        "astronomical UnitDefinition",
                    LengthUnit::chain => "chain",
                    LengthUnit::fathom => "fathom",
                    LengthUnit::fermi => "fermi",
                    LengthUnit::foot => "foot",
                    LengthUnit::kilofoot => "kilofoot",
                    LengthUnit::foot_survey => "foot (U.S. survey)",
                    LengthUnit::inch => "inch",
                    LengthUnit::light_year => "light year",
                    LengthUnit::microinch => "microinch",
                    LengthUnit::micron => "micron",
                    LengthUnit::mil => "mil",
                    LengthUnit::mile => "mile",
                    LengthUnit::mile_survey => "mile (U.S. survey)",
                    LengthUnit::nautical_mile => "nautical mile",
                    LengthUnit::parsec => "parsec",
                    LengthUnit::pica_computer => "pica (computer)",
                    LengthUnit::pica_printers => "pica (printer's)",
                    LengthUnit::point_computer => "point (computer)",
                    LengthUnit::point_printers => "point (printer's)",
                    LengthUnit::rod => "rod",
                    LengthUnit::yard => "yard",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    LengthUnit::yottameter => "yottameters",
                    LengthUnit::zettameter => "zettameters",
                    LengthUnit::exameter => "exameters",
                    LengthUnit::petameter => "petameters",
                    LengthUnit::terameter => "terameters",
                    LengthUnit::gigameter => "gigameters",
                    LengthUnit::megameter => "megameters",
                    LengthUnit::kilometer => "kilometers",
                    LengthUnit::hectometer => "hectometers",
                    LengthUnit::decameter => "decameters",
                    LengthUnit::meter => "meters",
                    LengthUnit::decimeter => "decimeters",
                    LengthUnit::centimeter => "centimeters",
                    LengthUnit::millimeter => "millimeters",
                    LengthUnit::micrometer => "micrometers",
                    LengthUnit::nanometer => "nanometers",
                    LengthUnit::picometer => "picometers",
                    LengthUnit::femtometer => "femtometers",
                    LengthUnit::attometer => "attometers",
                    LengthUnit::zeptometer => "zeptometers",
                    LengthUnit::yoctometer => "yoctometers",
                    LengthUnit::angstrom => "ngstrms",
                    LengthUnit::bohr_radius => "bohr radiuses",
                    LengthUnit::atomic_unit_of_length =>
                        "atomic units of length",
                    LengthUnit::astronomical_unit => "astronomical units",
                    LengthUnit::chain => "chains",
                    LengthUnit::fathom => "fathoms",
                    LengthUnit::fermi => "fermis",
                    LengthUnit::foot => "feet",
                    LengthUnit::kilofoot => "kilofeet",
                    LengthUnit::foot_survey => "feet (U.S. survey)",
                    LengthUnit::inch => "inches",
                    LengthUnit::light_year => "light years",
                    LengthUnit::microinch => "microinches",
                    LengthUnit::micron => "microns",
                    LengthUnit::mil => "mils",
                    LengthUnit::mile => "miles",
                    LengthUnit::mile_survey => "miles (U.S. survey)",
                    LengthUnit::nautical_mile => "nautical miles",
                    LengthUnit::parsec => "parsecs",
                    LengthUnit::pica_computer => "picas (computer)",
                    LengthUnit::pica_printers => "picas (printer's)",
                    LengthUnit::point_computer => "points (computer)",
                    LengthUnit::point_printers => "points (printer's)",
                    LengthUnit::rod => "rods",
                    LengthUnit::yard => "yards",
                }
            }
            #[doc = "Available units for this `[LengthUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["yottameter", "zettameter", "exameter", "petameter",
                                "terameter", "gigameter", "megameter", "kilometer",
                                "hectometer", "decameter", "meter", "decimeter",
                                "centimeter", "millimeter", "micrometer", "nanometer",
                                "picometer", "femtometer", "attometer", "zeptometer",
                                "yoctometer", "ngstrm", "bohr radius",
                                "atomic UnitDefinition of length",
                                "astronomical UnitDefinition", "chain", "fathom", "fermi",
                                "foot", "kilofoot", "foot (U.S. survey)", "inch",
                                "light year", "microinch", "micron", "mil", "mile",
                                "mile (U.S. survey)", "nautical mile", "parsec",
                                "pica (computer)", "pica (printer's)", "point (computer)",
                                "point (printer's)", "rod", "yard"];
                UNITS
            }
        }
        impl crate::traits::Unit for LengthUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    LengthUnit::yottameter => LengthUnit::get_yottameter(),
                    LengthUnit::zettameter => LengthUnit::get_zettameter(),
                    LengthUnit::exameter => LengthUnit::get_exameter(),
                    LengthUnit::petameter => LengthUnit::get_petameter(),
                    LengthUnit::terameter => LengthUnit::get_terameter(),
                    LengthUnit::gigameter => LengthUnit::get_gigameter(),
                    LengthUnit::megameter => LengthUnit::get_megameter(),
                    LengthUnit::kilometer => LengthUnit::get_kilometer(),
                    LengthUnit::hectometer => LengthUnit::get_hectometer(),
                    LengthUnit::decameter => LengthUnit::get_decameter(),
                    LengthUnit::meter => LengthUnit::get_meter(),
                    LengthUnit::decimeter => LengthUnit::get_decimeter(),
                    LengthUnit::centimeter => LengthUnit::get_centimeter(),
                    LengthUnit::millimeter => LengthUnit::get_millimeter(),
                    LengthUnit::micrometer => LengthUnit::get_micrometer(),
                    LengthUnit::nanometer => LengthUnit::get_nanometer(),
                    LengthUnit::picometer => LengthUnit::get_picometer(),
                    LengthUnit::femtometer => LengthUnit::get_femtometer(),
                    LengthUnit::attometer => LengthUnit::get_attometer(),
                    LengthUnit::zeptometer => LengthUnit::get_zeptometer(),
                    LengthUnit::yoctometer => LengthUnit::get_yoctometer(),
                    LengthUnit::angstrom => LengthUnit::get_angstrom(),
                    LengthUnit::bohr_radius => LengthUnit::get_bohr_radius(),
                    LengthUnit::atomic_unit_of_length =>
                        LengthUnit::get_atomic_unit_of_length(),
                    LengthUnit::astronomical_unit =>
                        LengthUnit::get_astronomical_unit(),
                    LengthUnit::chain => LengthUnit::get_chain(),
                    LengthUnit::fathom => LengthUnit::get_fathom(),
                    LengthUnit::fermi => LengthUnit::get_fermi(),
                    LengthUnit::foot => LengthUnit::get_foot(),
                    LengthUnit::kilofoot => LengthUnit::get_kilofoot(),
                    LengthUnit::foot_survey => LengthUnit::get_foot_survey(),
                    LengthUnit::inch => LengthUnit::get_inch(),
                    LengthUnit::light_year => LengthUnit::get_light_year(),
                    LengthUnit::microinch => LengthUnit::get_microinch(),
                    LengthUnit::micron => LengthUnit::get_micron(),
                    LengthUnit::mil => LengthUnit::get_mil(),
                    LengthUnit::mile => LengthUnit::get_mile(),
                    LengthUnit::mile_survey => LengthUnit::get_mile_survey(),
                    LengthUnit::nautical_mile =>
                        LengthUnit::get_nautical_mile(),
                    LengthUnit::parsec => LengthUnit::get_parsec(),
                    LengthUnit::pica_computer =>
                        LengthUnit::get_pica_computer(),
                    LengthUnit::pica_printers =>
                        LengthUnit::get_pica_printers(),
                    LengthUnit::point_computer =>
                        LengthUnit::get_point_computer(),
                    LengthUnit::point_printers =>
                        LengthUnit::get_point_printers(),
                    LengthUnit::rod => LengthUnit::get_rod(),
                    LengthUnit::yard => LengthUnit::get_yard(),
                }
            }
            #[inline]
            fn base() -> UnitBase { LENGTH_UNIT_BASE }
        }
        impl From<LengthUnit> for crate::Units {
            fn from(value: LengthUnit) -> Self {
                match value {
                    LengthUnit::yottameter =>
                        crate::Units::Length(LengthUnit::yottameter),
                    LengthUnit::zettameter =>
                        crate::Units::Length(LengthUnit::zettameter),
                    LengthUnit::exameter =>
                        crate::Units::Length(LengthUnit::exameter),
                    LengthUnit::petameter =>
                        crate::Units::Length(LengthUnit::petameter),
                    LengthUnit::terameter =>
                        crate::Units::Length(LengthUnit::terameter),
                    LengthUnit::gigameter =>
                        crate::Units::Length(LengthUnit::gigameter),
                    LengthUnit::megameter =>
                        crate::Units::Length(LengthUnit::megameter),
                    LengthUnit::kilometer =>
                        crate::Units::Length(LengthUnit::kilometer),
                    LengthUnit::hectometer =>
                        crate::Units::Length(LengthUnit::hectometer),
                    LengthUnit::decameter =>
                        crate::Units::Length(LengthUnit::decameter),
                    LengthUnit::meter =>
                        crate::Units::Length(LengthUnit::meter),
                    LengthUnit::decimeter =>
                        crate::Units::Length(LengthUnit::decimeter),
                    LengthUnit::centimeter =>
                        crate::Units::Length(LengthUnit::centimeter),
                    LengthUnit::millimeter =>
                        crate::Units::Length(LengthUnit::millimeter),
                    LengthUnit::micrometer =>
                        crate::Units::Length(LengthUnit::micrometer),
                    LengthUnit::nanometer =>
                        crate::Units::Length(LengthUnit::nanometer),
                    LengthUnit::picometer =>
                        crate::Units::Length(LengthUnit::picometer),
                    LengthUnit::femtometer =>
                        crate::Units::Length(LengthUnit::femtometer),
                    LengthUnit::attometer =>
                        crate::Units::Length(LengthUnit::attometer),
                    LengthUnit::zeptometer =>
                        crate::Units::Length(LengthUnit::zeptometer),
                    LengthUnit::yoctometer =>
                        crate::Units::Length(LengthUnit::yoctometer),
                    LengthUnit::angstrom =>
                        crate::Units::Length(LengthUnit::angstrom),
                    LengthUnit::bohr_radius =>
                        crate::Units::Length(LengthUnit::bohr_radius),
                    LengthUnit::atomic_unit_of_length =>
                        crate::Units::Length(LengthUnit::atomic_unit_of_length),
                    LengthUnit::astronomical_unit =>
                        crate::Units::Length(LengthUnit::astronomical_unit),
                    LengthUnit::chain =>
                        crate::Units::Length(LengthUnit::chain),
                    LengthUnit::fathom =>
                        crate::Units::Length(LengthUnit::fathom),
                    LengthUnit::fermi =>
                        crate::Units::Length(LengthUnit::fermi),
                    LengthUnit::foot => crate::Units::Length(LengthUnit::foot),
                    LengthUnit::kilofoot =>
                        crate::Units::Length(LengthUnit::kilofoot),
                    LengthUnit::foot_survey =>
                        crate::Units::Length(LengthUnit::foot_survey),
                    LengthUnit::inch => crate::Units::Length(LengthUnit::inch),
                    LengthUnit::light_year =>
                        crate::Units::Length(LengthUnit::light_year),
                    LengthUnit::microinch =>
                        crate::Units::Length(LengthUnit::microinch),
                    LengthUnit::micron =>
                        crate::Units::Length(LengthUnit::micron),
                    LengthUnit::mil => crate::Units::Length(LengthUnit::mil),
                    LengthUnit::mile => crate::Units::Length(LengthUnit::mile),
                    LengthUnit::mile_survey =>
                        crate::Units::Length(LengthUnit::mile_survey),
                    LengthUnit::nautical_mile =>
                        crate::Units::Length(LengthUnit::nautical_mile),
                    LengthUnit::parsec =>
                        crate::Units::Length(LengthUnit::parsec),
                    LengthUnit::pica_computer =>
                        crate::Units::Length(LengthUnit::pica_computer),
                    LengthUnit::pica_printers =>
                        crate::Units::Length(LengthUnit::pica_printers),
                    LengthUnit::point_computer =>
                        crate::Units::Length(LengthUnit::point_computer),
                    LengthUnit::point_printers =>
                        crate::Units::Length(LengthUnit::point_printers),
                    LengthUnit::rod => crate::Units::Length(LengthUnit::rod),
                    LengthUnit::yard => crate::Units::Length(LengthUnit::yard),
                }
            }
        }
        impl TryFrom<UnitDefinition> for LengthUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_YOTTAMETER_CONVERSION } =>
                        Ok(LengthUnit::yottameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_ZETTAMETER_CONVERSION } =>
                        Ok(LengthUnit::zettameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_EXAMETER_CONVERSION } =>
                        Ok(LengthUnit::exameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_PETAMETER_CONVERSION } =>
                        Ok(LengthUnit::petameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_TERAMETER_CONVERSION } =>
                        Ok(LengthUnit::terameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_GIGAMETER_CONVERSION } =>
                        Ok(LengthUnit::gigameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_MEGAMETER_CONVERSION } =>
                        Ok(LengthUnit::megameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_KILOMETER_CONVERSION } =>
                        Ok(LengthUnit::kilometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_HECTOMETER_CONVERSION } =>
                        Ok(LengthUnit::hectometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_DECAMETER_CONVERSION } =>
                        Ok(LengthUnit::decameter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_METER_CONVERSION
                        } => Ok(LengthUnit::meter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_DECIMETER_CONVERSION } =>
                        Ok(LengthUnit::decimeter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_CENTIMETER_CONVERSION } =>
                        Ok(LengthUnit::centimeter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_MILLIMETER_CONVERSION } =>
                        Ok(LengthUnit::millimeter),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_MICROMETER_CONVERSION } =>
                        Ok(LengthUnit::micrometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_NANOMETER_CONVERSION } =>
                        Ok(LengthUnit::nanometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_PICOMETER_CONVERSION } =>
                        Ok(LengthUnit::picometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_FEMTOMETER_CONVERSION } =>
                        Ok(LengthUnit::femtometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_ATTOMETER_CONVERSION } =>
                        Ok(LengthUnit::attometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_ZEPTOMETER_CONVERSION } =>
                        Ok(LengthUnit::zeptometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_YOCTOMETER_CONVERSION } =>
                        Ok(LengthUnit::yoctometer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_ANGSTROM_CONVERSION } =>
                        Ok(LengthUnit::angstrom),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_BOHR_RADIUS_CONVERSION } =>
                        Ok(LengthUnit::bohr_radius),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_ATOMIC_UNIT_OF_LENGTH_CONVERSION } =>
                        Ok(LengthUnit::atomic_unit_of_length),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_ASTRONOMICAL_UNIT_CONVERSION } =>
                        Ok(LengthUnit::astronomical_unit),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_CHAIN_CONVERSION
                        } => Ok(LengthUnit::chain),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_FATHOM_CONVERSION
                        } => Ok(LengthUnit::fathom),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_FERMI_CONVERSION
                        } => Ok(LengthUnit::fermi),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_FOOT_CONVERSION }
                        => Ok(LengthUnit::foot),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_KILOFOOT_CONVERSION } =>
                        Ok(LengthUnit::kilofoot),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_FOOT_SURVEY_CONVERSION } =>
                        Ok(LengthUnit::foot_survey),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_INCH_CONVERSION }
                        => Ok(LengthUnit::inch),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_LIGHT_YEAR_CONVERSION } =>
                        Ok(LengthUnit::light_year),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_MICROINCH_CONVERSION } =>
                        Ok(LengthUnit::microinch),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_MICRON_CONVERSION
                        } => Ok(LengthUnit::micron),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_MIL_CONVERSION }
                        => Ok(LengthUnit::mil),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_MILE_CONVERSION }
                        => Ok(LengthUnit::mile),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_MILE_SURVEY_CONVERSION } =>
                        Ok(LengthUnit::mile_survey),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_NAUTICAL_MILE_CONVERSION } =>
                        Ok(LengthUnit::nautical_mile),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_PARSEC_CONVERSION
                        } => Ok(LengthUnit::parsec),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_PICA_COMPUTER_CONVERSION } =>
                        Ok(LengthUnit::pica_computer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_PICA_PRINTERS_CONVERSION } =>
                        Ok(LengthUnit::pica_printers),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_POINT_COMPUTER_CONVERSION } =>
                        Ok(LengthUnit::point_computer),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE,
                        multiplier: LENGTH_POINT_PRINTERS_CONVERSION } =>
                        Ok(LengthUnit::point_printers),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_ROD_CONVERSION }
                        => Ok(LengthUnit::rod),
                    UnitDefinition {
                        base: LENGTH_UNIT_BASE, multiplier: LENGTH_YARD_CONVERSION }
                        => Ok(LengthUnit::yard),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "Length"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for LengthUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::Length(LengthUnit::yottameter) =>
                        Ok(LengthUnit::yottameter),
                    crate::Units::Length(LengthUnit::zettameter) =>
                        Ok(LengthUnit::zettameter),
                    crate::Units::Length(LengthUnit::exameter) =>
                        Ok(LengthUnit::exameter),
                    crate::Units::Length(LengthUnit::petameter) =>
                        Ok(LengthUnit::petameter),
                    crate::Units::Length(LengthUnit::terameter) =>
                        Ok(LengthUnit::terameter),
                    crate::Units::Length(LengthUnit::gigameter) =>
                        Ok(LengthUnit::gigameter),
                    crate::Units::Length(LengthUnit::megameter) =>
                        Ok(LengthUnit::megameter),
                    crate::Units::Length(LengthUnit::kilometer) =>
                        Ok(LengthUnit::kilometer),
                    crate::Units::Length(LengthUnit::hectometer) =>
                        Ok(LengthUnit::hectometer),
                    crate::Units::Length(LengthUnit::decameter) =>
                        Ok(LengthUnit::decameter),
                    crate::Units::Length(LengthUnit::meter) =>
                        Ok(LengthUnit::meter),
                    crate::Units::Length(LengthUnit::decimeter) =>
                        Ok(LengthUnit::decimeter),
                    crate::Units::Length(LengthUnit::centimeter) =>
                        Ok(LengthUnit::centimeter),
                    crate::Units::Length(LengthUnit::millimeter) =>
                        Ok(LengthUnit::millimeter),
                    crate::Units::Length(LengthUnit::micrometer) =>
                        Ok(LengthUnit::micrometer),
                    crate::Units::Length(LengthUnit::nanometer) =>
                        Ok(LengthUnit::nanometer),
                    crate::Units::Length(LengthUnit::picometer) =>
                        Ok(LengthUnit::picometer),
                    crate::Units::Length(LengthUnit::femtometer) =>
                        Ok(LengthUnit::femtometer),
                    crate::Units::Length(LengthUnit::attometer) =>
                        Ok(LengthUnit::attometer),
                    crate::Units::Length(LengthUnit::zeptometer) =>
                        Ok(LengthUnit::zeptometer),
                    crate::Units::Length(LengthUnit::yoctometer) =>
                        Ok(LengthUnit::yoctometer),
                    crate::Units::Length(LengthUnit::angstrom) =>
                        Ok(LengthUnit::angstrom),
                    crate::Units::Length(LengthUnit::bohr_radius) =>
                        Ok(LengthUnit::bohr_radius),
                    crate::Units::Length(LengthUnit::atomic_unit_of_length) =>
                        Ok(LengthUnit::atomic_unit_of_length),
                    crate::Units::Length(LengthUnit::astronomical_unit) =>
                        Ok(LengthUnit::astronomical_unit),
                    crate::Units::Length(LengthUnit::chain) =>
                        Ok(LengthUnit::chain),
                    crate::Units::Length(LengthUnit::fathom) =>
                        Ok(LengthUnit::fathom),
                    crate::Units::Length(LengthUnit::fermi) =>
                        Ok(LengthUnit::fermi),
                    crate::Units::Length(LengthUnit::foot) =>
                        Ok(LengthUnit::foot),
                    crate::Units::Length(LengthUnit::kilofoot) =>
                        Ok(LengthUnit::kilofoot),
                    crate::Units::Length(LengthUnit::foot_survey) =>
                        Ok(LengthUnit::foot_survey),
                    crate::Units::Length(LengthUnit::inch) =>
                        Ok(LengthUnit::inch),
                    crate::Units::Length(LengthUnit::light_year) =>
                        Ok(LengthUnit::light_year),
                    crate::Units::Length(LengthUnit::microinch) =>
                        Ok(LengthUnit::microinch),
                    crate::Units::Length(LengthUnit::micron) =>
                        Ok(LengthUnit::micron),
                    crate::Units::Length(LengthUnit::mil) =>
                        Ok(LengthUnit::mil),
                    crate::Units::Length(LengthUnit::mile) =>
                        Ok(LengthUnit::mile),
                    crate::Units::Length(LengthUnit::mile_survey) =>
                        Ok(LengthUnit::mile_survey),
                    crate::Units::Length(LengthUnit::nautical_mile) =>
                        Ok(LengthUnit::nautical_mile),
                    crate::Units::Length(LengthUnit::parsec) =>
                        Ok(LengthUnit::parsec),
                    crate::Units::Length(LengthUnit::pica_computer) =>
                        Ok(LengthUnit::pica_computer),
                    crate::Units::Length(LengthUnit::pica_printers) =>
                        Ok(LengthUnit::pica_printers),
                    crate::Units::Length(LengthUnit::point_computer) =>
                        Ok(LengthUnit::point_computer),
                    crate::Units::Length(LengthUnit::point_printers) =>
                        Ok(LengthUnit::point_printers),
                    crate::Units::Length(LengthUnit::rod) =>
                        Ok(LengthUnit::rod),
                    crate::Units::Length(LengthUnit::yard) =>
                        Ok(LengthUnit::yard),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "Length"));
                                        res
                                    }))),
                }
            }
        }
        impl From<Length> for crate::Units {
            fn from(value: Length) -> Self {
                crate::Units::Length(value.unit)
            }
        }
        impl From<&Length> for crate::Units {
            fn from(value: &Length) -> Self {
                crate::Units::Length(value.unit)
            }
        }
        impl From<LengthVec> for crate::Units {
            fn from(value: LengthVec) -> Self {
                crate::Units::Length(value.unit)
            }
        }
        impl From<&LengthVec> for crate::Units {
            fn from(value: &LengthVec) -> Self {
                crate::Units::Length(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Length (base UnitDefinition meter, m)."]
        #[schema(title = "Length")]
        #[doc = "Scalar storage of a quantity (f64 and [`LengthUnit`])."]
        pub struct Length {
            pub(crate) value: f64,
            pub(crate) unit: LengthUnit,
        }
        impl utoipa::__dev::ComposeSchema for Length {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <LengthUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("Length")).description(Some(" Length (base UnitDefinition meter, m).\nScalar storage of a quantity (f64 and [`LengthUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for Length {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("Length")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <LengthUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <LengthUnit as utoipa::PartialSchema>::schema())]);
                <LengthUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Length {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer, "Length",
                                    false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Length {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Length>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Length;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct Length")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct Length with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<LengthUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct Length with 2 elements")),
                                    };
                                _serde::__private::Ok(Length {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<LengthUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<LengthUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(Length {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "Length", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Length>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for Length { }
        #[automatically_derived]
        impl ::core::clone::Clone for Length {
            #[inline]
            fn clone(&self) -> Length {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _: ::core::clone::AssertParamIsClone<LengthUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Length {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "Length", "value", &self.value, "unit", &&self.unit)
            }
        }
        impl Length {
            #[doc = "Create a new [`LengthUnit`]."]
            pub fn new(value: f64, unit: LengthUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::yottameter`]."]
            pub fn yottameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::yottameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::zettameter`]."]
            pub fn zettameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::zettameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::exameter`]."]
            pub fn exameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::exameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::petameter`]."]
            pub fn petameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::petameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::terameter`]."]
            pub fn terameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::terameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::gigameter`]."]
            pub fn gigameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::gigameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::megameter`]."]
            pub fn megameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::megameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::kilometer`]."]
            pub fn kilometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::kilometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::hectometer`]."]
            pub fn hectometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::hectometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::decameter`]."]
            pub fn decameter(value: f64) -> Self {
                Self { value, unit: LengthUnit::decameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::meter`]."]
            pub fn meter(value: f64) -> Self {
                Self { value, unit: LengthUnit::meter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::decimeter`]."]
            pub fn decimeter(value: f64) -> Self {
                Self { value, unit: LengthUnit::decimeter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::centimeter`]."]
            pub fn centimeter(value: f64) -> Self {
                Self { value, unit: LengthUnit::centimeter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::millimeter`]."]
            pub fn millimeter(value: f64) -> Self {
                Self { value, unit: LengthUnit::millimeter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::micrometer`]."]
            pub fn micrometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::micrometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::nanometer`]."]
            pub fn nanometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::nanometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::picometer`]."]
            pub fn picometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::picometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::femtometer`]."]
            pub fn femtometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::femtometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::attometer`]."]
            pub fn attometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::attometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::zeptometer`]."]
            pub fn zeptometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::zeptometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::yoctometer`]."]
            pub fn yoctometer(value: f64) -> Self {
                Self { value, unit: LengthUnit::yoctometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::angstrom`]."]
            pub fn angstrom(value: f64) -> Self {
                Self { value, unit: LengthUnit::angstrom.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::bohr_radius`]."]
            pub fn bohr_radius(value: f64) -> Self {
                Self { value, unit: LengthUnit::bohr_radius.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::atomic_unit_of_length`]."]
            pub fn atomic_unit_of_length(value: f64) -> Self {
                Self { value, unit: LengthUnit::atomic_unit_of_length.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::astronomical_unit`]."]
            pub fn astronomical_unit(value: f64) -> Self {
                Self { value, unit: LengthUnit::astronomical_unit.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::chain`]."]
            pub fn chain(value: f64) -> Self {
                Self { value, unit: LengthUnit::chain.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::fathom`]."]
            pub fn fathom(value: f64) -> Self {
                Self { value, unit: LengthUnit::fathom.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::fermi`]."]
            pub fn fermi(value: f64) -> Self {
                Self { value, unit: LengthUnit::fermi.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::foot`]."]
            pub fn foot(value: f64) -> Self {
                Self { value, unit: LengthUnit::foot.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::kilofoot`]."]
            pub fn kilofoot(value: f64) -> Self {
                Self { value, unit: LengthUnit::kilofoot.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::foot_survey`]."]
            pub fn foot_survey(value: f64) -> Self {
                Self { value, unit: LengthUnit::foot_survey.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::inch`]."]
            pub fn inch(value: f64) -> Self {
                Self { value, unit: LengthUnit::inch.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::light_year`]."]
            pub fn light_year(value: f64) -> Self {
                Self { value, unit: LengthUnit::light_year.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::microinch`]."]
            pub fn microinch(value: f64) -> Self {
                Self { value, unit: LengthUnit::microinch.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::micron`]."]
            pub fn micron(value: f64) -> Self {
                Self { value, unit: LengthUnit::micron.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::mil`]."]
            pub fn mil(value: f64) -> Self {
                Self { value, unit: LengthUnit::mil.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::mile`]."]
            pub fn mile(value: f64) -> Self {
                Self { value, unit: LengthUnit::mile.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::mile_survey`]."]
            pub fn mile_survey(value: f64) -> Self {
                Self { value, unit: LengthUnit::mile_survey.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::nautical_mile`]."]
            pub fn nautical_mile(value: f64) -> Self {
                Self { value, unit: LengthUnit::nautical_mile.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::parsec`]."]
            pub fn parsec(value: f64) -> Self {
                Self { value, unit: LengthUnit::parsec.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::pica_computer`]."]
            pub fn pica_computer(value: f64) -> Self {
                Self { value, unit: LengthUnit::pica_computer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::pica_printers`]."]
            pub fn pica_printers(value: f64) -> Self {
                Self { value, unit: LengthUnit::pica_printers.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::point_computer`]."]
            pub fn point_computer(value: f64) -> Self {
                Self { value, unit: LengthUnit::point_computer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::point_printers`]."]
            pub fn point_printers(value: f64) -> Self {
                Self { value, unit: LengthUnit::point_printers.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::rod`]."]
            pub fn rod(value: f64) -> Self {
                Self { value, unit: LengthUnit::rod.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::yard`]."]
            pub fn yard(value: f64) -> Self {
                Self { value, unit: LengthUnit::yard.into() }
            }
            #[doc = "Retrieve the value associated with this [`Length`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`Length`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`Length`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`LengthUnit::yottameter`]."]
            #[inline]
            pub fn to_yottameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_YOTTAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::yottameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::zettameter`]."]
            #[inline]
            pub fn to_zettameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_ZETTAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::zettameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::exameter`]."]
            #[inline]
            pub fn to_exameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_EXAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::exameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::petameter`]."]
            #[inline]
            pub fn to_petameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_PETAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::petameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::terameter`]."]
            #[inline]
            pub fn to_terameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_TERAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::terameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::gigameter`]."]
            #[inline]
            pub fn to_gigameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_GIGAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::gigameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::megameter`]."]
            #[inline]
            pub fn to_megameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_MEGAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::megameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::kilometer`]."]
            #[inline]
            pub fn to_kilometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_KILOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::kilometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::hectometer`]."]
            #[inline]
            pub fn to_hectometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_HECTOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::hectometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::decameter`]."]
            #[inline]
            pub fn to_decameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_DECAMETER_CONVERSION)) as f64,
                    unit: LengthUnit::decameter,
                }
            }
            #[doc = "Convert to [`LengthUnit::meter`]."]
            #[inline]
            pub fn to_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_METER_CONVERSION))
                            as f64,
                    unit: LengthUnit::meter,
                }
            }
            #[doc = "Convert to [`LengthUnit::decimeter`]."]
            #[inline]
            pub fn to_decimeter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_DECIMETER_CONVERSION)) as f64,
                    unit: LengthUnit::decimeter,
                }
            }
            #[doc = "Convert to [`LengthUnit::centimeter`]."]
            #[inline]
            pub fn to_centimeter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_CENTIMETER_CONVERSION)) as f64,
                    unit: LengthUnit::centimeter,
                }
            }
            #[doc = "Convert to [`LengthUnit::millimeter`]."]
            #[inline]
            pub fn to_millimeter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_MILLIMETER_CONVERSION)) as f64,
                    unit: LengthUnit::millimeter,
                }
            }
            #[doc = "Convert to [`LengthUnit::micrometer`]."]
            #[inline]
            pub fn to_micrometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_MICROMETER_CONVERSION)) as f64,
                    unit: LengthUnit::micrometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::nanometer`]."]
            #[inline]
            pub fn to_nanometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_NANOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::nanometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::picometer`]."]
            #[inline]
            pub fn to_picometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_PICOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::picometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::femtometer`]."]
            #[inline]
            pub fn to_femtometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_FEMTOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::femtometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::attometer`]."]
            #[inline]
            pub fn to_attometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_ATTOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::attometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::zeptometer`]."]
            #[inline]
            pub fn to_zeptometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_ZEPTOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::zeptometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::yoctometer`]."]
            #[inline]
            pub fn to_yoctometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_YOCTOMETER_CONVERSION)) as f64,
                    unit: LengthUnit::yoctometer,
                }
            }
            #[doc = "Convert to [`LengthUnit::angstrom`]."]
            #[inline]
            pub fn to_angstrom(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_ANGSTROM_CONVERSION)) as f64,
                    unit: LengthUnit::angstrom,
                }
            }
            #[doc = "Convert to [`LengthUnit::bohr_radius`]."]
            #[inline]
            pub fn to_bohr_radius(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_BOHR_RADIUS_CONVERSION)) as f64,
                    unit: LengthUnit::bohr_radius,
                }
            }
            #[doc = "Convert to [`LengthUnit::atomic_unit_of_length`]."]
            #[inline]
            pub fn to_atomic_unit_of_length(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_ATOMIC_UNIT_OF_LENGTH_CONVERSION)) as f64,
                    unit: LengthUnit::atomic_unit_of_length,
                }
            }
            #[doc = "Convert to [`LengthUnit::astronomical_unit`]."]
            #[inline]
            pub fn to_astronomical_unit(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_ASTRONOMICAL_UNIT_CONVERSION)) as f64,
                    unit: LengthUnit::astronomical_unit,
                }
            }
            #[doc = "Convert to [`LengthUnit::chain`]."]
            #[inline]
            pub fn to_chain(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_CHAIN_CONVERSION))
                            as f64,
                    unit: LengthUnit::chain,
                }
            }
            #[doc = "Convert to [`LengthUnit::fathom`]."]
            #[inline]
            pub fn to_fathom(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_FATHOM_CONVERSION))
                            as f64,
                    unit: LengthUnit::fathom,
                }
            }
            #[doc = "Convert to [`LengthUnit::fermi`]."]
            #[inline]
            pub fn to_fermi(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_FERMI_CONVERSION))
                            as f64,
                    unit: LengthUnit::fermi,
                }
            }
            #[doc = "Convert to [`LengthUnit::foot`]."]
            #[inline]
            pub fn to_foot(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_FOOT_CONVERSION)) as
                            f64,
                    unit: LengthUnit::foot,
                }
            }
            #[doc = "Convert to [`LengthUnit::kilofoot`]."]
            #[inline]
            pub fn to_kilofoot(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_KILOFOOT_CONVERSION)) as f64,
                    unit: LengthUnit::kilofoot,
                }
            }
            #[doc = "Convert to [`LengthUnit::foot_survey`]."]
            #[inline]
            pub fn to_foot_survey(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_FOOT_SURVEY_CONVERSION)) as f64,
                    unit: LengthUnit::foot_survey,
                }
            }
            #[doc = "Convert to [`LengthUnit::inch`]."]
            #[inline]
            pub fn to_inch(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_INCH_CONVERSION)) as
                            f64,
                    unit: LengthUnit::inch,
                }
            }
            #[doc = "Convert to [`LengthUnit::light_year`]."]
            #[inline]
            pub fn to_light_year(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_LIGHT_YEAR_CONVERSION)) as f64,
                    unit: LengthUnit::light_year,
                }
            }
            #[doc = "Convert to [`LengthUnit::microinch`]."]
            #[inline]
            pub fn to_microinch(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_MICROINCH_CONVERSION)) as f64,
                    unit: LengthUnit::microinch,
                }
            }
            #[doc = "Convert to [`LengthUnit::micron`]."]
            #[inline]
            pub fn to_micron(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_MICRON_CONVERSION))
                            as f64,
                    unit: LengthUnit::micron,
                }
            }
            #[doc = "Convert to [`LengthUnit::mil`]."]
            #[inline]
            pub fn to_mil(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_MIL_CONVERSION)) as
                            f64,
                    unit: LengthUnit::mil,
                }
            }
            #[doc = "Convert to [`LengthUnit::mile`]."]
            #[inline]
            pub fn to_mile(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_MILE_CONVERSION)) as
                            f64,
                    unit: LengthUnit::mile,
                }
            }
            #[doc = "Convert to [`LengthUnit::mile_survey`]."]
            #[inline]
            pub fn to_mile_survey(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_MILE_SURVEY_CONVERSION)) as f64,
                    unit: LengthUnit::mile_survey,
                }
            }
            #[doc = "Convert to [`LengthUnit::nautical_mile`]."]
            #[inline]
            pub fn to_nautical_mile(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_NAUTICAL_MILE_CONVERSION)) as f64,
                    unit: LengthUnit::nautical_mile,
                }
            }
            #[doc = "Convert to [`LengthUnit::parsec`]."]
            #[inline]
            pub fn to_parsec(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_PARSEC_CONVERSION))
                            as f64,
                    unit: LengthUnit::parsec,
                }
            }
            #[doc = "Convert to [`LengthUnit::pica_computer`]."]
            #[inline]
            pub fn to_pica_computer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_PICA_COMPUTER_CONVERSION)) as f64,
                    unit: LengthUnit::pica_computer,
                }
            }
            #[doc = "Convert to [`LengthUnit::pica_printers`]."]
            #[inline]
            pub fn to_pica_printers(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_PICA_PRINTERS_CONVERSION)) as f64,
                    unit: LengthUnit::pica_printers,
                }
            }
            #[doc = "Convert to [`LengthUnit::point_computer`]."]
            #[inline]
            pub fn to_point_computer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_POINT_COMPUTER_CONVERSION)) as f64,
                    unit: LengthUnit::point_computer,
                }
            }
            #[doc = "Convert to [`LengthUnit::point_printers`]."]
            #[inline]
            pub fn to_point_printers(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LENGTH_POINT_PRINTERS_CONVERSION)) as f64,
                    unit: LengthUnit::point_printers,
                }
            }
            #[doc = "Convert to [`LengthUnit::rod`]."]
            #[inline]
            pub fn to_rod(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_ROD_CONVERSION)) as
                            f64,
                    unit: LengthUnit::rod,
                }
            }
            #[doc = "Convert to [`LengthUnit::yard`]."]
            #[inline]
            pub fn to_yard(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (LENGTH_YARD_CONVERSION)) as
                            f64,
                    unit: LengthUnit::yard,
                }
            }
        }
        impl FixedQuantity<LengthUnit> for Length {
            #[inline]
            fn unit(&self) -> LengthUnit { self.unit }
            #[inline]
            fn convert(&self, unit: LengthUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: LengthUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut LengthUnit { &mut self.unit }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: LengthUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<Length> for UnitDefinition {
            #[inline]
            fn from(value: Length) -> Self {
                match value.unit {
                    LengthUnit::yottameter => LengthUnit::get_yottameter(),
                    LengthUnit::zettameter => LengthUnit::get_zettameter(),
                    LengthUnit::exameter => LengthUnit::get_exameter(),
                    LengthUnit::petameter => LengthUnit::get_petameter(),
                    LengthUnit::terameter => LengthUnit::get_terameter(),
                    LengthUnit::gigameter => LengthUnit::get_gigameter(),
                    LengthUnit::megameter => LengthUnit::get_megameter(),
                    LengthUnit::kilometer => LengthUnit::get_kilometer(),
                    LengthUnit::hectometer => LengthUnit::get_hectometer(),
                    LengthUnit::decameter => LengthUnit::get_decameter(),
                    LengthUnit::meter => LengthUnit::get_meter(),
                    LengthUnit::decimeter => LengthUnit::get_decimeter(),
                    LengthUnit::centimeter => LengthUnit::get_centimeter(),
                    LengthUnit::millimeter => LengthUnit::get_millimeter(),
                    LengthUnit::micrometer => LengthUnit::get_micrometer(),
                    LengthUnit::nanometer => LengthUnit::get_nanometer(),
                    LengthUnit::picometer => LengthUnit::get_picometer(),
                    LengthUnit::femtometer => LengthUnit::get_femtometer(),
                    LengthUnit::attometer => LengthUnit::get_attometer(),
                    LengthUnit::zeptometer => LengthUnit::get_zeptometer(),
                    LengthUnit::yoctometer => LengthUnit::get_yoctometer(),
                    LengthUnit::angstrom => LengthUnit::get_angstrom(),
                    LengthUnit::bohr_radius => LengthUnit::get_bohr_radius(),
                    LengthUnit::atomic_unit_of_length =>
                        LengthUnit::get_atomic_unit_of_length(),
                    LengthUnit::astronomical_unit =>
                        LengthUnit::get_astronomical_unit(),
                    LengthUnit::chain => LengthUnit::get_chain(),
                    LengthUnit::fathom => LengthUnit::get_fathom(),
                    LengthUnit::fermi => LengthUnit::get_fermi(),
                    LengthUnit::foot => LengthUnit::get_foot(),
                    LengthUnit::kilofoot => LengthUnit::get_kilofoot(),
                    LengthUnit::foot_survey => LengthUnit::get_foot_survey(),
                    LengthUnit::inch => LengthUnit::get_inch(),
                    LengthUnit::light_year => LengthUnit::get_light_year(),
                    LengthUnit::microinch => LengthUnit::get_microinch(),
                    LengthUnit::micron => LengthUnit::get_micron(),
                    LengthUnit::mil => LengthUnit::get_mil(),
                    LengthUnit::mile => LengthUnit::get_mile(),
                    LengthUnit::mile_survey => LengthUnit::get_mile_survey(),
                    LengthUnit::nautical_mile =>
                        LengthUnit::get_nautical_mile(),
                    LengthUnit::parsec => LengthUnit::get_parsec(),
                    LengthUnit::pica_computer =>
                        LengthUnit::get_pica_computer(),
                    LengthUnit::pica_printers =>
                        LengthUnit::get_pica_printers(),
                    LengthUnit::point_computer =>
                        LengthUnit::get_point_computer(),
                    LengthUnit::point_printers =>
                        LengthUnit::get_point_printers(),
                    LengthUnit::rod => LengthUnit::get_rod(),
                    LengthUnit::yard => LengthUnit::get_yard(),
                }
            }
        }
        impl From<Length> for Quantity {
            fn from(quantity: Length) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for Length {
            fn from(quantity: Quantity) -> Length {
                Length {
                    value: quantity.value,
                    unit: LengthUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for Length {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl LengthVec {
            #[doc = "Create a new vector of [`LengthUnit`]."]
            pub fn new(values: Vec<f64>, unit: LengthUnit) -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc = "Retrieve values associated with this [`LengthSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`LengthSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::yottameter`]."]
            pub fn yottameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::yottameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::zettameter`]."]
            pub fn zettameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::zettameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::exameter`]."]
            pub fn exameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::exameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::petameter`]."]
            pub fn petameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::petameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::terameter`]."]
            pub fn terameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::terameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::gigameter`]."]
            pub fn gigameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::gigameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::megameter`]."]
            pub fn megameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::megameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::kilometer`]."]
            pub fn kilometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::kilometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::hectometer`]."]
            pub fn hectometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::hectometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::decameter`]."]
            pub fn decameter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::decameter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::meter`]."]
            pub fn meter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::meter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::decimeter`]."]
            pub fn decimeter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::decimeter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::centimeter`]."]
            pub fn centimeter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::centimeter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::millimeter`]."]
            pub fn millimeter(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::millimeter.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::micrometer`]."]
            pub fn micrometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::micrometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::nanometer`]."]
            pub fn nanometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::nanometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::picometer`]."]
            pub fn picometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::picometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::femtometer`]."]
            pub fn femtometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::femtometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::attometer`]."]
            pub fn attometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::attometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::zeptometer`]."]
            pub fn zeptometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::zeptometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::yoctometer`]."]
            pub fn yoctometer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::yoctometer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::angstrom`]."]
            pub fn angstrom(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::angstrom.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::bohr_radius`]."]
            pub fn bohr_radius(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::bohr_radius.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::atomic_unit_of_length`]."]
            pub fn atomic_unit_of_length(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LengthUnit::atomic_unit_of_length.into(),
                }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::astronomical_unit`]."]
            pub fn astronomical_unit(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::astronomical_unit.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::chain`]."]
            pub fn chain(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::chain.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::fathom`]."]
            pub fn fathom(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::fathom.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::fermi`]."]
            pub fn fermi(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::fermi.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::foot`]."]
            pub fn foot(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::foot.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::kilofoot`]."]
            pub fn kilofoot(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::kilofoot.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::foot_survey`]."]
            pub fn foot_survey(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::foot_survey.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::inch`]."]
            pub fn inch(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::inch.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::light_year`]."]
            pub fn light_year(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::light_year.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::microinch`]."]
            pub fn microinch(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::microinch.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::micron`]."]
            pub fn micron(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::micron.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::mil`]."]
            pub fn mil(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::mil.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::mile`]."]
            pub fn mile(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::mile.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::mile_survey`]."]
            pub fn mile_survey(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::mile_survey.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::nautical_mile`]."]
            pub fn nautical_mile(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::nautical_mile.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::parsec`]."]
            pub fn parsec(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::parsec.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::pica_computer`]."]
            pub fn pica_computer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::pica_computer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::pica_printers`]."]
            pub fn pica_printers(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::pica_printers.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::point_computer`]."]
            pub fn point_computer(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::point_computer.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::point_printers`]."]
            pub fn point_printers(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::point_printers.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::rod`]."]
            pub fn rod(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::rod.into() }
            }
            #[doc =
            "Create a new [`Length`] with units of [`LengthUnit::yard`]."]
            pub fn yard(values: Vec<f64>) -> Self {
                Self { values, unit: LengthUnit::yard.into() }
            }
            #[doc = "Convert to [`LengthUnit::yottameter`]."]
            #[inline]
            pub fn to_yottameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::yottameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::zettameter`]."]
            #[inline]
            pub fn to_zettameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::zettameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::exameter`]."]
            #[inline]
            pub fn to_exameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::exameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::petameter`]."]
            #[inline]
            pub fn to_petameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::petameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::terameter`]."]
            #[inline]
            pub fn to_terameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::terameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::gigameter`]."]
            #[inline]
            pub fn to_gigameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::gigameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::megameter`]."]
            #[inline]
            pub fn to_megameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::megameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::kilometer`]."]
            #[inline]
            pub fn to_kilometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::kilometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::hectometer`]."]
            #[inline]
            pub fn to_hectometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::hectometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::decameter`]."]
            #[inline]
            pub fn to_decameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::decameter);
                r
            }
            #[doc = "Convert to [`LengthUnit::meter`]."]
            #[inline]
            pub fn to_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::meter);
                r
            }
            #[doc = "Convert to [`LengthUnit::decimeter`]."]
            #[inline]
            pub fn to_decimeter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::decimeter);
                r
            }
            #[doc = "Convert to [`LengthUnit::centimeter`]."]
            #[inline]
            pub fn to_centimeter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::centimeter);
                r
            }
            #[doc = "Convert to [`LengthUnit::millimeter`]."]
            #[inline]
            pub fn to_millimeter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::millimeter);
                r
            }
            #[doc = "Convert to [`LengthUnit::micrometer`]."]
            #[inline]
            pub fn to_micrometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::micrometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::nanometer`]."]
            #[inline]
            pub fn to_nanometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::nanometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::picometer`]."]
            #[inline]
            pub fn to_picometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::picometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::femtometer`]."]
            #[inline]
            pub fn to_femtometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::femtometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::attometer`]."]
            #[inline]
            pub fn to_attometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::attometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::zeptometer`]."]
            #[inline]
            pub fn to_zeptometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::zeptometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::yoctometer`]."]
            #[inline]
            pub fn to_yoctometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::yoctometer);
                r
            }
            #[doc = "Convert to [`LengthUnit::angstrom`]."]
            #[inline]
            pub fn to_angstrom(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::angstrom);
                r
            }
            #[doc = "Convert to [`LengthUnit::bohr_radius`]."]
            #[inline]
            pub fn to_bohr_radius(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::bohr_radius);
                r
            }
            #[doc = "Convert to [`LengthUnit::atomic_unit_of_length`]."]
            #[inline]
            pub fn to_atomic_unit_of_length(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::atomic_unit_of_length);
                r
            }
            #[doc = "Convert to [`LengthUnit::astronomical_unit`]."]
            #[inline]
            pub fn to_astronomical_unit(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::astronomical_unit);
                r
            }
            #[doc = "Convert to [`LengthUnit::chain`]."]
            #[inline]
            pub fn to_chain(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::chain);
                r
            }
            #[doc = "Convert to [`LengthUnit::fathom`]."]
            #[inline]
            pub fn to_fathom(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::fathom);
                r
            }
            #[doc = "Convert to [`LengthUnit::fermi`]."]
            #[inline]
            pub fn to_fermi(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::fermi);
                r
            }
            #[doc = "Convert to [`LengthUnit::foot`]."]
            #[inline]
            pub fn to_foot(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::foot);
                r
            }
            #[doc = "Convert to [`LengthUnit::kilofoot`]."]
            #[inline]
            pub fn to_kilofoot(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::kilofoot);
                r
            }
            #[doc = "Convert to [`LengthUnit::foot_survey`]."]
            #[inline]
            pub fn to_foot_survey(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::foot_survey);
                r
            }
            #[doc = "Convert to [`LengthUnit::inch`]."]
            #[inline]
            pub fn to_inch(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::inch);
                r
            }
            #[doc = "Convert to [`LengthUnit::light_year`]."]
            #[inline]
            pub fn to_light_year(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::light_year);
                r
            }
            #[doc = "Convert to [`LengthUnit::microinch`]."]
            #[inline]
            pub fn to_microinch(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::microinch);
                r
            }
            #[doc = "Convert to [`LengthUnit::micron`]."]
            #[inline]
            pub fn to_micron(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::micron);
                r
            }
            #[doc = "Convert to [`LengthUnit::mil`]."]
            #[inline]
            pub fn to_mil(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::mil);
                r
            }
            #[doc = "Convert to [`LengthUnit::mile`]."]
            #[inline]
            pub fn to_mile(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::mile);
                r
            }
            #[doc = "Convert to [`LengthUnit::mile_survey`]."]
            #[inline]
            pub fn to_mile_survey(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::mile_survey);
                r
            }
            #[doc = "Convert to [`LengthUnit::nautical_mile`]."]
            #[inline]
            pub fn to_nautical_mile(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::nautical_mile);
                r
            }
            #[doc = "Convert to [`LengthUnit::parsec`]."]
            #[inline]
            pub fn to_parsec(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::parsec);
                r
            }
            #[doc = "Convert to [`LengthUnit::pica_computer`]."]
            #[inline]
            pub fn to_pica_computer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::pica_computer);
                r
            }
            #[doc = "Convert to [`LengthUnit::pica_printers`]."]
            #[inline]
            pub fn to_pica_printers(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::pica_printers);
                r
            }
            #[doc = "Convert to [`LengthUnit::point_computer`]."]
            #[inline]
            pub fn to_point_computer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::point_computer);
                r
            }
            #[doc = "Convert to [`LengthUnit::point_printers`]."]
            #[inline]
            pub fn to_point_printers(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::point_printers);
                r
            }
            #[doc = "Convert to [`LengthUnit::rod`]."]
            #[inline]
            pub fn to_rod(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::rod);
                r
            }
            #[doc = "Convert to [`LengthUnit::yard`]."]
            #[inline]
            pub fn to_yard(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LengthUnit::yard);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for Length {
            type Output = Length;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for Length {
            type Output = Length;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for Length {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for Length {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for Length {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<Length> for Quantity {
            fn eq(&self, other: &Length) -> bool { *other == *self }
        }
        impl PartialEq<Length> for Length {
            fn eq(&self, other: &Length) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for Length {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for Length {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<Length> for Length {
            type Output = Self;
            fn add(self, rhs: Length) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Length> for Length {
            type Output = Self;
            fn sub(self, rhs: Length) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for Length {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for Length {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for Length {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for Length {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for Length {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for Length {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc = "Array storage for a series of values and [`LengthUnit`]."]
        pub struct LengthArray<const N : usize> {
            pub(crate) unit: LengthUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for LengthArray<N>
            {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <LengthUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`LengthUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for LengthArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("LengthArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <LengthUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <LengthUnit as utoipa::PartialSchema>::schema())]);
                <LengthUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for LengthArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "LengthArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<LengthArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<LengthArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    LengthArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<LengthArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = LengthArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct LengthArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<LengthUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct LengthArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<LengthArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct LengthArray with 2 elements")),
                                    };
                                _serde::__private::Ok(LengthArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<LengthUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<LengthUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<LengthArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(LengthArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "LengthArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LengthArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for LengthArray<N> { }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for LengthArray<N> {
            #[inline]
            fn clone(&self) -> LengthArray<N> {
                let _: ::core::clone::AssertParamIsClone<LengthUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for LengthArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "LengthArray", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            LengthArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for LengthArray<N> {
            #[inline]
            fn eq(&self, other: &LengthArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for LengthArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for LengthArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc = "Vector storage for a series of values and [`LengthUnit`]."]
        pub struct LengthVec {
            pub(crate) unit: LengthUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for LengthVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <LengthUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`LengthUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for LengthVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("LengthVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <LengthUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <LengthUnit as utoipa::PartialSchema>::schema())]);
                <LengthUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LengthVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "LengthVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LengthVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LengthVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LengthVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct LengthVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<LengthUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct LengthVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct LengthVec with 2 elements")),
                                    };
                                _serde::__private::Ok(LengthVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<LengthUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<LengthUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(LengthVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "LengthVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LengthVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for LengthVec {
            #[inline]
            fn clone(&self) -> LengthVec {
                LengthVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LengthVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "LengthVec", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LengthVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LengthVec {
            #[inline]
            fn eq(&self, other: &LengthVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for LengthVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for LengthVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<LengthUnit, f64> for LengthVec
            {
            fn unit(&self) -> LengthUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: LengthUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: LengthUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: LengthUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize>
            crate::traits::FixedSliceQuantity<LengthUnit, f64> for
            LengthArray<N> {
            fn unit(&self) -> LengthUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: LengthUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: LengthUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: LengthUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for LengthVec {
            type Output = LengthVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for LengthVec {
            type Output = LengthVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for LengthVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for LengthVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<LengthVec> for LengthVec {
            fn add_assign(&mut self, rhs: LengthVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<LengthVec> for LengthVec {
            fn sub_assign(&mut self, rhs: LengthVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for LengthArray<N> {
            type Output = LengthArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for LengthArray<N> {
            type Output = LengthArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for LengthArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for LengthArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<LengthArray<N>> for LengthArray<N> {
            fn add_assign(&mut self, rhs: LengthArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<LengthArray<N>> for LengthArray<N> {
            fn sub_assign(&mut self, rhs: LengthArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<LengthVec> for VecQuantity {
            fn from(input: LengthVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<LengthUnit> for UnitDefinition {
            #[inline]
            fn from(value: LengthUnit) -> Self {
                match value {
                    LengthUnit::yottameter => LengthUnit::get_yottameter(),
                    LengthUnit::zettameter => LengthUnit::get_zettameter(),
                    LengthUnit::exameter => LengthUnit::get_exameter(),
                    LengthUnit::petameter => LengthUnit::get_petameter(),
                    LengthUnit::terameter => LengthUnit::get_terameter(),
                    LengthUnit::gigameter => LengthUnit::get_gigameter(),
                    LengthUnit::megameter => LengthUnit::get_megameter(),
                    LengthUnit::kilometer => LengthUnit::get_kilometer(),
                    LengthUnit::hectometer => LengthUnit::get_hectometer(),
                    LengthUnit::decameter => LengthUnit::get_decameter(),
                    LengthUnit::meter => LengthUnit::get_meter(),
                    LengthUnit::decimeter => LengthUnit::get_decimeter(),
                    LengthUnit::centimeter => LengthUnit::get_centimeter(),
                    LengthUnit::millimeter => LengthUnit::get_millimeter(),
                    LengthUnit::micrometer => LengthUnit::get_micrometer(),
                    LengthUnit::nanometer => LengthUnit::get_nanometer(),
                    LengthUnit::picometer => LengthUnit::get_picometer(),
                    LengthUnit::femtometer => LengthUnit::get_femtometer(),
                    LengthUnit::attometer => LengthUnit::get_attometer(),
                    LengthUnit::zeptometer => LengthUnit::get_zeptometer(),
                    LengthUnit::yoctometer => LengthUnit::get_yoctometer(),
                    LengthUnit::angstrom => LengthUnit::get_angstrom(),
                    LengthUnit::bohr_radius => LengthUnit::get_bohr_radius(),
                    LengthUnit::atomic_unit_of_length =>
                        LengthUnit::get_atomic_unit_of_length(),
                    LengthUnit::astronomical_unit =>
                        LengthUnit::get_astronomical_unit(),
                    LengthUnit::chain => LengthUnit::get_chain(),
                    LengthUnit::fathom => LengthUnit::get_fathom(),
                    LengthUnit::fermi => LengthUnit::get_fermi(),
                    LengthUnit::foot => LengthUnit::get_foot(),
                    LengthUnit::kilofoot => LengthUnit::get_kilofoot(),
                    LengthUnit::foot_survey => LengthUnit::get_foot_survey(),
                    LengthUnit::inch => LengthUnit::get_inch(),
                    LengthUnit::light_year => LengthUnit::get_light_year(),
                    LengthUnit::microinch => LengthUnit::get_microinch(),
                    LengthUnit::micron => LengthUnit::get_micron(),
                    LengthUnit::mil => LengthUnit::get_mil(),
                    LengthUnit::mile => LengthUnit::get_mile(),
                    LengthUnit::mile_survey => LengthUnit::get_mile_survey(),
                    LengthUnit::nautical_mile =>
                        LengthUnit::get_nautical_mile(),
                    LengthUnit::parsec => LengthUnit::get_parsec(),
                    LengthUnit::pica_computer =>
                        LengthUnit::get_pica_computer(),
                    LengthUnit::pica_printers =>
                        LengthUnit::get_pica_printers(),
                    LengthUnit::point_computer =>
                        LengthUnit::get_point_computer(),
                    LengthUnit::point_printers =>
                        LengthUnit::get_point_printers(),
                    LengthUnit::rod => LengthUnit::get_rod(),
                    LengthUnit::yard => LengthUnit::get_yard(),
                }
            }
        }
        impl TryFrom<&str> for LengthUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<LengthUnit> =
                    match value {
                        "Ym" => Some(LengthUnit::yottameter),
                        "Zm" => Some(LengthUnit::zettameter),
                        "Em" => Some(LengthUnit::exameter),
                        "Pm" => Some(LengthUnit::petameter),
                        "Tm" => Some(LengthUnit::terameter),
                        "Gm" => Some(LengthUnit::gigameter),
                        "Mm" => Some(LengthUnit::megameter),
                        "km" => Some(LengthUnit::kilometer),
                        "hm" => Some(LengthUnit::hectometer),
                        "dam" => Some(LengthUnit::decameter),
                        "m" => Some(LengthUnit::meter),
                        "dm" => Some(LengthUnit::decimeter),
                        "cm" => Some(LengthUnit::centimeter),
                        "mm" => Some(LengthUnit::millimeter),
                        "m" => Some(LengthUnit::micrometer),
                        "nm" => Some(LengthUnit::nanometer),
                        "pm" => Some(LengthUnit::picometer),
                        "fm" => Some(LengthUnit::femtometer),
                        "am" => Some(LengthUnit::attometer),
                        "zm" => Some(LengthUnit::zeptometer),
                        "ym" => Some(LengthUnit::yoctometer),
                        "" => Some(LengthUnit::angstrom),
                        "a" => Some(LengthUnit::bohr_radius),
                        "a.u. of length" => Some(LengthUnit::atomic_unit_of_length),
                        "ua" => Some(LengthUnit::astronomical_unit),
                        "ch" => Some(LengthUnit::chain),
                        "fathom" => Some(LengthUnit::fathom),
                        "fermi" => Some(LengthUnit::fermi),
                        "ft" => Some(LengthUnit::foot),
                        "kft" => Some(LengthUnit::kilofoot),
                        "ft (U.S. survey)" => Some(LengthUnit::foot_survey),
                        "in" => Some(LengthUnit::inch),
                        "l. y." => Some(LengthUnit::light_year),
                        "in" => Some(LengthUnit::microinch),
                        "" => Some(LengthUnit::micron),
                        "0.001 in" => Some(LengthUnit::mil),
                        "mi" => Some(LengthUnit::mile),
                        "mi (U.S. survey)" => Some(LengthUnit::mile_survey),
                        "NM" => Some(LengthUnit::nautical_mile),
                        "pc" => Some(LengthUnit::parsec),
                        "1/6 in (computer)" => Some(LengthUnit::pica_computer),
                        "1/6 in" => Some(LengthUnit::pica_printers),
                        "1/72 in (computer)" => Some(LengthUnit::point_computer),
                        "1/72 in" => Some(LengthUnit::point_printers),
                        "rd" => Some(LengthUnit::rod),
                        "yd" => Some(LengthUnit::yard),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<LengthUnit> =
                    match value {
                        "yottameter" => Some(LengthUnit::yottameter),
                        "zettameter" => Some(LengthUnit::zettameter),
                        "exameter" => Some(LengthUnit::exameter),
                        "petameter" => Some(LengthUnit::petameter),
                        "terameter" => Some(LengthUnit::terameter),
                        "gigameter" => Some(LengthUnit::gigameter),
                        "megameter" => Some(LengthUnit::megameter),
                        "kilometer" => Some(LengthUnit::kilometer),
                        "hectometer" => Some(LengthUnit::hectometer),
                        "decameter" => Some(LengthUnit::decameter),
                        "meter" => Some(LengthUnit::meter),
                        "decimeter" => Some(LengthUnit::decimeter),
                        "centimeter" => Some(LengthUnit::centimeter),
                        "millimeter" => Some(LengthUnit::millimeter),
                        "micrometer" => Some(LengthUnit::micrometer),
                        "nanometer" => Some(LengthUnit::nanometer),
                        "picometer" => Some(LengthUnit::picometer),
                        "femtometer" => Some(LengthUnit::femtometer),
                        "attometer" => Some(LengthUnit::attometer),
                        "zeptometer" => Some(LengthUnit::zeptometer),
                        "yoctometer" => Some(LengthUnit::yoctometer),
                        "ngstrm" => Some(LengthUnit::angstrom),
                        "bohr radius" => Some(LengthUnit::bohr_radius),
                        "atomic UnitDefinition of length" =>
                            Some(LengthUnit::atomic_unit_of_length),
                        "astronomical UnitDefinition" =>
                            Some(LengthUnit::astronomical_unit),
                        "chain" => Some(LengthUnit::chain),
                        "fathom" => Some(LengthUnit::fathom),
                        "fermi" => Some(LengthUnit::fermi),
                        "foot" => Some(LengthUnit::foot),
                        "kilofoot" => Some(LengthUnit::kilofoot),
                        "foot (U.S. survey)" => Some(LengthUnit::foot_survey),
                        "inch" => Some(LengthUnit::inch),
                        "light year" => Some(LengthUnit::light_year),
                        "microinch" => Some(LengthUnit::microinch),
                        "micron" => Some(LengthUnit::micron),
                        "mil" => Some(LengthUnit::mil),
                        "mile" => Some(LengthUnit::mile),
                        "mile (U.S. survey)" => Some(LengthUnit::mile_survey),
                        "nautical mile" => Some(LengthUnit::nautical_mile),
                        "parsec" => Some(LengthUnit::parsec),
                        "pica (computer)" => Some(LengthUnit::pica_computer),
                        "pica (printer's)" => Some(LengthUnit::pica_printers),
                        "point (computer)" => Some(LengthUnit::point_computer),
                        "point (printer's)" => Some(LengthUnit::point_printers),
                        "rod" => Some(LengthUnit::rod),
                        "yard" => Some(LengthUnit::yard),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<LengthUnit> =
                    match value {
                        "yottameters" => Some(LengthUnit::yottameter),
                        "zettameters" => Some(LengthUnit::zettameter),
                        "exameters" => Some(LengthUnit::exameter),
                        "petameters" => Some(LengthUnit::petameter),
                        "terameters" => Some(LengthUnit::terameter),
                        "gigameters" => Some(LengthUnit::gigameter),
                        "megameters" => Some(LengthUnit::megameter),
                        "kilometers" => Some(LengthUnit::kilometer),
                        "hectometers" => Some(LengthUnit::hectometer),
                        "decameters" => Some(LengthUnit::decameter),
                        "meters" => Some(LengthUnit::meter),
                        "decimeters" => Some(LengthUnit::decimeter),
                        "centimeters" => Some(LengthUnit::centimeter),
                        "millimeters" => Some(LengthUnit::millimeter),
                        "micrometers" => Some(LengthUnit::micrometer),
                        "nanometers" => Some(LengthUnit::nanometer),
                        "picometers" => Some(LengthUnit::picometer),
                        "femtometers" => Some(LengthUnit::femtometer),
                        "attometers" => Some(LengthUnit::attometer),
                        "zeptometers" => Some(LengthUnit::zeptometer),
                        "yoctometers" => Some(LengthUnit::yoctometer),
                        "ngstrms" => Some(LengthUnit::angstrom),
                        "bohr radiuses" => Some(LengthUnit::bohr_radius),
                        "atomic units of length" =>
                            Some(LengthUnit::atomic_unit_of_length),
                        "astronomical units" => Some(LengthUnit::astronomical_unit),
                        "chains" => Some(LengthUnit::chain),
                        "fathoms" => Some(LengthUnit::fathom),
                        "fermis" => Some(LengthUnit::fermi),
                        "feet" => Some(LengthUnit::foot),
                        "kilofeet" => Some(LengthUnit::kilofoot),
                        "feet (U.S. survey)" => Some(LengthUnit::foot_survey),
                        "inches" => Some(LengthUnit::inch),
                        "light years" => Some(LengthUnit::light_year),
                        "microinches" => Some(LengthUnit::microinch),
                        "microns" => Some(LengthUnit::micron),
                        "mils" => Some(LengthUnit::mil),
                        "miles" => Some(LengthUnit::mile),
                        "miles (U.S. survey)" => Some(LengthUnit::mile_survey),
                        "nautical miles" => Some(LengthUnit::nautical_mile),
                        "parsecs" => Some(LengthUnit::parsec),
                        "picas (computer)" => Some(LengthUnit::pica_computer),
                        "picas (printer's)" => Some(LengthUnit::pica_printers),
                        "points (computer)" => Some(LengthUnit::point_computer),
                        "points (printer's)" => Some(LengthUnit::point_printers),
                        "rods" => Some(LengthUnit::rod),
                        "yards" => Some(LengthUnit::yard),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"Length\"")
                   }
            }
        }
        impl core::fmt::Display for LengthUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    LengthUnit::yottameter =>
                        f.write_fmt(format_args!("{0}", "yottameter")),
                    LengthUnit::zettameter =>
                        f.write_fmt(format_args!("{0}", "zettameter")),
                    LengthUnit::exameter =>
                        f.write_fmt(format_args!("{0}", "exameter")),
                    LengthUnit::petameter =>
                        f.write_fmt(format_args!("{0}", "petameter")),
                    LengthUnit::terameter =>
                        f.write_fmt(format_args!("{0}", "terameter")),
                    LengthUnit::gigameter =>
                        f.write_fmt(format_args!("{0}", "gigameter")),
                    LengthUnit::megameter =>
                        f.write_fmt(format_args!("{0}", "megameter")),
                    LengthUnit::kilometer =>
                        f.write_fmt(format_args!("{0}", "kilometer")),
                    LengthUnit::hectometer =>
                        f.write_fmt(format_args!("{0}", "hectometer")),
                    LengthUnit::decameter =>
                        f.write_fmt(format_args!("{0}", "decameter")),
                    LengthUnit::meter =>
                        f.write_fmt(format_args!("{0}", "meter")),
                    LengthUnit::decimeter =>
                        f.write_fmt(format_args!("{0}", "decimeter")),
                    LengthUnit::centimeter =>
                        f.write_fmt(format_args!("{0}", "centimeter")),
                    LengthUnit::millimeter =>
                        f.write_fmt(format_args!("{0}", "millimeter")),
                    LengthUnit::micrometer =>
                        f.write_fmt(format_args!("{0}", "micrometer")),
                    LengthUnit::nanometer =>
                        f.write_fmt(format_args!("{0}", "nanometer")),
                    LengthUnit::picometer =>
                        f.write_fmt(format_args!("{0}", "picometer")),
                    LengthUnit::femtometer =>
                        f.write_fmt(format_args!("{0}", "femtometer")),
                    LengthUnit::attometer =>
                        f.write_fmt(format_args!("{0}", "attometer")),
                    LengthUnit::zeptometer =>
                        f.write_fmt(format_args!("{0}", "zeptometer")),
                    LengthUnit::yoctometer =>
                        f.write_fmt(format_args!("{0}", "yoctometer")),
                    LengthUnit::angstrom =>
                        f.write_fmt(format_args!("{0}", "ngstrm")),
                    LengthUnit::bohr_radius =>
                        f.write_fmt(format_args!("{0}", "bohr radius")),
                    LengthUnit::atomic_unit_of_length =>
                        f.write_fmt(format_args!("{0}",
                                "atomic UnitDefinition of length")),
                    LengthUnit::astronomical_unit =>
                        f.write_fmt(format_args!("{0}",
                                "astronomical UnitDefinition")),
                    LengthUnit::chain =>
                        f.write_fmt(format_args!("{0}", "chain")),
                    LengthUnit::fathom =>
                        f.write_fmt(format_args!("{0}", "fathom")),
                    LengthUnit::fermi =>
                        f.write_fmt(format_args!("{0}", "fermi")),
                    LengthUnit::foot =>
                        f.write_fmt(format_args!("{0}", "foot")),
                    LengthUnit::kilofoot =>
                        f.write_fmt(format_args!("{0}", "kilofoot")),
                    LengthUnit::foot_survey =>
                        f.write_fmt(format_args!("{0}", "foot (U.S. survey)")),
                    LengthUnit::inch =>
                        f.write_fmt(format_args!("{0}", "inch")),
                    LengthUnit::light_year =>
                        f.write_fmt(format_args!("{0}", "light year")),
                    LengthUnit::microinch =>
                        f.write_fmt(format_args!("{0}", "microinch")),
                    LengthUnit::micron =>
                        f.write_fmt(format_args!("{0}", "micron")),
                    LengthUnit::mil => f.write_fmt(format_args!("{0}", "mil")),
                    LengthUnit::mile =>
                        f.write_fmt(format_args!("{0}", "mile")),
                    LengthUnit::mile_survey =>
                        f.write_fmt(format_args!("{0}", "mile (U.S. survey)")),
                    LengthUnit::nautical_mile =>
                        f.write_fmt(format_args!("{0}", "nautical mile")),
                    LengthUnit::parsec =>
                        f.write_fmt(format_args!("{0}", "parsec")),
                    LengthUnit::pica_computer =>
                        f.write_fmt(format_args!("{0}", "pica (computer)")),
                    LengthUnit::pica_printers =>
                        f.write_fmt(format_args!("{0}", "pica (printer's)")),
                    LengthUnit::point_computer =>
                        f.write_fmt(format_args!("{0}", "point (computer)")),
                    LengthUnit::point_printers =>
                        f.write_fmt(format_args!("{0}", "point (printer's)")),
                    LengthUnit::rod => f.write_fmt(format_args!("{0}", "rod")),
                    LengthUnit::yard =>
                        f.write_fmt(format_args!("{0}", "yard")),
                }
            }
        }
    }
    #[cfg(any(feature = "Length", feature = "All"))]
    pub use crate::unit_definitions::length::LengthArray;
    #[cfg(any(feature = "Length", feature = "All"))]
    pub use crate::unit_definitions::length::Length;
    #[cfg(any(feature = "Length", feature = "All"))]
    pub use crate::unit_definitions::length::LengthVec;
    #[cfg(any(feature = "Luminance", feature = "All"))]
    mod luminance {
        //! Luminance (base UnitDefinition candela per square meter, cd  m).
        use crate::{prefix, quantity};
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc =
        r" Luminance (base UnitDefinition candela per square meter, cd  m)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "LuminanceUnit")]
        pub enum LuminanceUnit {
            yottacandela_per_square_meter,
            zettacandela_per_square_meter,
            exacandela_per_square_meter,
            petacandela_per_square_meter,
            teracandela_per_square_meter,
            gigacandela_per_square_meter,
            megacandela_per_square_meter,
            kilocandela_per_square_meter,
            hectocandela_per_square_meter,
            decacandela_per_square_meter,
            candela_per_square_meter,
            decicandela_per_square_meter,
            centicandela_per_square_meter,
            millicandela_per_square_meter,
            microcandela_per_square_meter,
            nanocandela_per_square_meter,
            picocandela_per_square_meter,
            femtocandela_per_square_meter,
            attocandela_per_square_meter,
            zeptocandela_per_square_meter,
            yoctocandela_per_square_meter,
            candela_per_square_picometer,
            candela_per_square_nanometer,
            candela_per_square_micrometer,
            candela_per_square_millimeter,
            candela_per_square_centimeter,
            candela_per_square_kilometer,
            candela_per_square_megameter,
            candela_per_square_gigameter,
            candela_per_square_terameter,
            candela_per_square_inch,
            candela_per_square_foot,
            footlambert,
            lambert,
            stilb,
        }
        impl utoipa::__dev::ComposeSchema for LuminanceUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 35usize],
                                &str>(Some(["yottacandela_per_square_meter",
                                            "zettacandela_per_square_meter",
                                            "exacandela_per_square_meter",
                                            "petacandela_per_square_meter",
                                            "teracandela_per_square_meter",
                                            "gigacandela_per_square_meter",
                                            "megacandela_per_square_meter",
                                            "kilocandela_per_square_meter",
                                            "hectocandela_per_square_meter",
                                            "decacandela_per_square_meter", "candela_per_square_meter",
                                            "decicandela_per_square_meter",
                                            "centicandela_per_square_meter",
                                            "millicandela_per_square_meter",
                                            "microcandela_per_square_meter",
                                            "nanocandela_per_square_meter",
                                            "picocandela_per_square_meter",
                                            "femtocandela_per_square_meter",
                                            "attocandela_per_square_meter",
                                            "zeptocandela_per_square_meter",
                                            "yoctocandela_per_square_meter",
                                            "candela_per_square_picometer",
                                            "candela_per_square_nanometer",
                                            "candela_per_square_micrometer",
                                            "candela_per_square_millimeter",
                                            "candela_per_square_centimeter",
                                            "candela_per_square_kilometer",
                                            "candela_per_square_megameter",
                                            "candela_per_square_gigameter",
                                            "candela_per_square_terameter", "candela_per_square_inch",
                                            "candela_per_square_foot", "footlambert", "lambert",
                                            "stilb"])).title(Some("LuminanceUnit")).description(Some("Luminance (base UnitDefinition candela per square meter, cd  m).")).into()
            }
        }
        impl utoipa::ToSchema for LuminanceUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("LuminanceUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LuminanceUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            LuminanceUnit::yottacandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 0u32, "yottacandela_per_square_meter"),
                            LuminanceUnit::zettacandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 1u32, "zettacandela_per_square_meter"),
                            LuminanceUnit::exacandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 2u32, "exacandela_per_square_meter"),
                            LuminanceUnit::petacandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 3u32, "petacandela_per_square_meter"),
                            LuminanceUnit::teracandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 4u32, "teracandela_per_square_meter"),
                            LuminanceUnit::gigacandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 5u32, "gigacandela_per_square_meter"),
                            LuminanceUnit::megacandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 6u32, "megacandela_per_square_meter"),
                            LuminanceUnit::kilocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 7u32, "kilocandela_per_square_meter"),
                            LuminanceUnit::hectocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 8u32, "hectocandela_per_square_meter"),
                            LuminanceUnit::decacandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 9u32, "decacandela_per_square_meter"),
                            LuminanceUnit::candela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 10u32, "candela_per_square_meter"),
                            LuminanceUnit::decicandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 11u32, "decicandela_per_square_meter"),
                            LuminanceUnit::centicandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 12u32, "centicandela_per_square_meter"),
                            LuminanceUnit::millicandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 13u32, "millicandela_per_square_meter"),
                            LuminanceUnit::microcandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 14u32, "microcandela_per_square_meter"),
                            LuminanceUnit::nanocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 15u32, "nanocandela_per_square_meter"),
                            LuminanceUnit::picocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 16u32, "picocandela_per_square_meter"),
                            LuminanceUnit::femtocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 17u32, "femtocandela_per_square_meter"),
                            LuminanceUnit::attocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 18u32, "attocandela_per_square_meter"),
                            LuminanceUnit::zeptocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 19u32, "zeptocandela_per_square_meter"),
                            LuminanceUnit::yoctocandela_per_square_meter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 20u32, "yoctocandela_per_square_meter"),
                            LuminanceUnit::candela_per_square_picometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 21u32, "candela_per_square_picometer"),
                            LuminanceUnit::candela_per_square_nanometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 22u32, "candela_per_square_nanometer"),
                            LuminanceUnit::candela_per_square_micrometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 23u32, "candela_per_square_micrometer"),
                            LuminanceUnit::candela_per_square_millimeter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 24u32, "candela_per_square_millimeter"),
                            LuminanceUnit::candela_per_square_centimeter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 25u32, "candela_per_square_centimeter"),
                            LuminanceUnit::candela_per_square_kilometer =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 26u32, "candela_per_square_kilometer"),
                            LuminanceUnit::candela_per_square_megameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 27u32, "candela_per_square_megameter"),
                            LuminanceUnit::candela_per_square_gigameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 28u32, "candela_per_square_gigameter"),
                            LuminanceUnit::candela_per_square_terameter =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 29u32, "candela_per_square_terameter"),
                            LuminanceUnit::candela_per_square_inch =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 30u32, "candela_per_square_inch"),
                            LuminanceUnit::candela_per_square_foot =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 31u32, "candela_per_square_foot"),
                            LuminanceUnit::footlambert =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 32u32, "footlambert"),
                            LuminanceUnit::lambert =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 33u32, "lambert"),
                            LuminanceUnit::stilb =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "LuminanceUnit", 34u32, "stilb"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LuminanceUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                            __field24,
                            __field25,
                            __field26,
                            __field27,
                            __field28,
                            __field29,
                            __field30,
                            __field31,
                            __field32,
                            __field33,
                            __field34,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    17u64 => _serde::__private::Ok(__Field::__field17),
                                    18u64 => _serde::__private::Ok(__Field::__field18),
                                    19u64 => _serde::__private::Ok(__Field::__field19),
                                    20u64 => _serde::__private::Ok(__Field::__field20),
                                    21u64 => _serde::__private::Ok(__Field::__field21),
                                    22u64 => _serde::__private::Ok(__Field::__field22),
                                    23u64 => _serde::__private::Ok(__Field::__field23),
                                    24u64 => _serde::__private::Ok(__Field::__field24),
                                    25u64 => _serde::__private::Ok(__Field::__field25),
                                    26u64 => _serde::__private::Ok(__Field::__field26),
                                    27u64 => _serde::__private::Ok(__Field::__field27),
                                    28u64 => _serde::__private::Ok(__Field::__field28),
                                    29u64 => _serde::__private::Ok(__Field::__field29),
                                    30u64 => _serde::__private::Ok(__Field::__field30),
                                    31u64 => _serde::__private::Ok(__Field::__field31),
                                    32u64 => _serde::__private::Ok(__Field::__field32),
                                    33u64 => _serde::__private::Ok(__Field::__field33),
                                    34u64 => _serde::__private::Ok(__Field::__field34),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 35")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "yottacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field0),
                                    "zettacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field1),
                                    "exacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field2),
                                    "petacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field3),
                                    "teracandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field4),
                                    "gigacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field5),
                                    "megacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field6),
                                    "kilocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field7),
                                    "hectocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field8),
                                    "decacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field9),
                                    "candela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field10),
                                    "decicandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field11),
                                    "centicandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field12),
                                    "millicandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field13),
                                    "microcandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field14),
                                    "nanocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field15),
                                    "picocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field16),
                                    "femtocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field17),
                                    "attocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field18),
                                    "zeptocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field19),
                                    "yoctocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field20),
                                    "candela_per_square_picometer" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    "candela_per_square_nanometer" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    "candela_per_square_micrometer" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    "candela_per_square_millimeter" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    "candela_per_square_centimeter" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    "candela_per_square_kilometer" =>
                                        _serde::__private::Ok(__Field::__field26),
                                    "candela_per_square_megameter" =>
                                        _serde::__private::Ok(__Field::__field27),
                                    "candela_per_square_gigameter" =>
                                        _serde::__private::Ok(__Field::__field28),
                                    "candela_per_square_terameter" =>
                                        _serde::__private::Ok(__Field::__field29),
                                    "candela_per_square_inch" =>
                                        _serde::__private::Ok(__Field::__field30),
                                    "candela_per_square_foot" =>
                                        _serde::__private::Ok(__Field::__field31),
                                    "footlambert" => _serde::__private::Ok(__Field::__field32),
                                    "lambert" => _serde::__private::Ok(__Field::__field33),
                                    "stilb" => _serde::__private::Ok(__Field::__field34),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"yottacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field0),
                                    b"zettacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field1),
                                    b"exacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field2),
                                    b"petacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field3),
                                    b"teracandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field4),
                                    b"gigacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field5),
                                    b"megacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field6),
                                    b"kilocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field7),
                                    b"hectocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field8),
                                    b"decacandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field9),
                                    b"candela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field10),
                                    b"decicandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field11),
                                    b"centicandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field12),
                                    b"millicandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field13),
                                    b"microcandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field14),
                                    b"nanocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field15),
                                    b"picocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field16),
                                    b"femtocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field17),
                                    b"attocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field18),
                                    b"zeptocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field19),
                                    b"yoctocandela_per_square_meter" =>
                                        _serde::__private::Ok(__Field::__field20),
                                    b"candela_per_square_picometer" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    b"candela_per_square_nanometer" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    b"candela_per_square_micrometer" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    b"candela_per_square_millimeter" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    b"candela_per_square_centimeter" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    b"candela_per_square_kilometer" =>
                                        _serde::__private::Ok(__Field::__field26),
                                    b"candela_per_square_megameter" =>
                                        _serde::__private::Ok(__Field::__field27),
                                    b"candela_per_square_gigameter" =>
                                        _serde::__private::Ok(__Field::__field28),
                                    b"candela_per_square_terameter" =>
                                        _serde::__private::Ok(__Field::__field29),
                                    b"candela_per_square_inch" =>
                                        _serde::__private::Ok(__Field::__field30),
                                    b"candela_per_square_foot" =>
                                        _serde::__private::Ok(__Field::__field31),
                                    b"footlambert" => _serde::__private::Ok(__Field::__field32),
                                    b"lambert" => _serde::__private::Ok(__Field::__field33),
                                    b"stilb" => _serde::__private::Ok(__Field::__field34),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LuminanceUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LuminanceUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum LuminanceUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::yottacandela_per_square_meter)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::zettacandela_per_square_meter)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::exacandela_per_square_meter)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::petacandela_per_square_meter)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::teracandela_per_square_meter)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::gigacandela_per_square_meter)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::megacandela_per_square_meter)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::kilocandela_per_square_meter)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::hectocandela_per_square_meter)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::decacandela_per_square_meter)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_meter)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::decicandela_per_square_meter)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::centicandela_per_square_meter)
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::millicandela_per_square_meter)
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::microcandela_per_square_meter)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::nanocandela_per_square_meter)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::picocandela_per_square_meter)
                                    }
                                    (__Field::__field17, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::femtocandela_per_square_meter)
                                    }
                                    (__Field::__field18, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::attocandela_per_square_meter)
                                    }
                                    (__Field::__field19, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::zeptocandela_per_square_meter)
                                    }
                                    (__Field::__field20, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::yoctocandela_per_square_meter)
                                    }
                                    (__Field::__field21, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_picometer)
                                    }
                                    (__Field::__field22, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_nanometer)
                                    }
                                    (__Field::__field23, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_micrometer)
                                    }
                                    (__Field::__field24, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_millimeter)
                                    }
                                    (__Field::__field25, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_centimeter)
                                    }
                                    (__Field::__field26, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_kilometer)
                                    }
                                    (__Field::__field27, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_megameter)
                                    }
                                    (__Field::__field28, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_gigameter)
                                    }
                                    (__Field::__field29, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_terameter)
                                    }
                                    (__Field::__field30, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_inch)
                                    }
                                    (__Field::__field31, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::candela_per_square_foot)
                                    }
                                    (__Field::__field32, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::footlambert)
                                    }
                                    (__Field::__field33, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::lambert)
                                    }
                                    (__Field::__field34, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(LuminanceUnit::stilb)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["yottacandela_per_square_meter",
                                        "zettacandela_per_square_meter",
                                        "exacandela_per_square_meter",
                                        "petacandela_per_square_meter",
                                        "teracandela_per_square_meter",
                                        "gigacandela_per_square_meter",
                                        "megacandela_per_square_meter",
                                        "kilocandela_per_square_meter",
                                        "hectocandela_per_square_meter",
                                        "decacandela_per_square_meter", "candela_per_square_meter",
                                        "decicandela_per_square_meter",
                                        "centicandela_per_square_meter",
                                        "millicandela_per_square_meter",
                                        "microcandela_per_square_meter",
                                        "nanocandela_per_square_meter",
                                        "picocandela_per_square_meter",
                                        "femtocandela_per_square_meter",
                                        "attocandela_per_square_meter",
                                        "zeptocandela_per_square_meter",
                                        "yoctocandela_per_square_meter",
                                        "candela_per_square_picometer",
                                        "candela_per_square_nanometer",
                                        "candela_per_square_micrometer",
                                        "candela_per_square_millimeter",
                                        "candela_per_square_centimeter",
                                        "candela_per_square_kilometer",
                                        "candela_per_square_megameter",
                                        "candela_per_square_gigameter",
                                        "candela_per_square_terameter", "candela_per_square_inch",
                                        "candela_per_square_foot", "footlambert", "lambert",
                                        "stilb"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "LuminanceUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LuminanceUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for LuminanceUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for LuminanceUnit {
            #[inline]
            fn clone(&self) -> LuminanceUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for LuminanceUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        LuminanceUnit::yottacandela_per_square_meter =>
                            "yottacandela_per_square_meter",
                        LuminanceUnit::zettacandela_per_square_meter =>
                            "zettacandela_per_square_meter",
                        LuminanceUnit::exacandela_per_square_meter =>
                            "exacandela_per_square_meter",
                        LuminanceUnit::petacandela_per_square_meter =>
                            "petacandela_per_square_meter",
                        LuminanceUnit::teracandela_per_square_meter =>
                            "teracandela_per_square_meter",
                        LuminanceUnit::gigacandela_per_square_meter =>
                            "gigacandela_per_square_meter",
                        LuminanceUnit::megacandela_per_square_meter =>
                            "megacandela_per_square_meter",
                        LuminanceUnit::kilocandela_per_square_meter =>
                            "kilocandela_per_square_meter",
                        LuminanceUnit::hectocandela_per_square_meter =>
                            "hectocandela_per_square_meter",
                        LuminanceUnit::decacandela_per_square_meter =>
                            "decacandela_per_square_meter",
                        LuminanceUnit::candela_per_square_meter =>
                            "candela_per_square_meter",
                        LuminanceUnit::decicandela_per_square_meter =>
                            "decicandela_per_square_meter",
                        LuminanceUnit::centicandela_per_square_meter =>
                            "centicandela_per_square_meter",
                        LuminanceUnit::millicandela_per_square_meter =>
                            "millicandela_per_square_meter",
                        LuminanceUnit::microcandela_per_square_meter =>
                            "microcandela_per_square_meter",
                        LuminanceUnit::nanocandela_per_square_meter =>
                            "nanocandela_per_square_meter",
                        LuminanceUnit::picocandela_per_square_meter =>
                            "picocandela_per_square_meter",
                        LuminanceUnit::femtocandela_per_square_meter =>
                            "femtocandela_per_square_meter",
                        LuminanceUnit::attocandela_per_square_meter =>
                            "attocandela_per_square_meter",
                        LuminanceUnit::zeptocandela_per_square_meter =>
                            "zeptocandela_per_square_meter",
                        LuminanceUnit::yoctocandela_per_square_meter =>
                            "yoctocandela_per_square_meter",
                        LuminanceUnit::candela_per_square_picometer =>
                            "candela_per_square_picometer",
                        LuminanceUnit::candela_per_square_nanometer =>
                            "candela_per_square_nanometer",
                        LuminanceUnit::candela_per_square_micrometer =>
                            "candela_per_square_micrometer",
                        LuminanceUnit::candela_per_square_millimeter =>
                            "candela_per_square_millimeter",
                        LuminanceUnit::candela_per_square_centimeter =>
                            "candela_per_square_centimeter",
                        LuminanceUnit::candela_per_square_kilometer =>
                            "candela_per_square_kilometer",
                        LuminanceUnit::candela_per_square_megameter =>
                            "candela_per_square_megameter",
                        LuminanceUnit::candela_per_square_gigameter =>
                            "candela_per_square_gigameter",
                        LuminanceUnit::candela_per_square_terameter =>
                            "candela_per_square_terameter",
                        LuminanceUnit::candela_per_square_inch =>
                            "candela_per_square_inch",
                        LuminanceUnit::candela_per_square_foot =>
                            "candela_per_square_foot",
                        LuminanceUnit::footlambert => "footlambert",
                        LuminanceUnit::lambert => "lambert",
                        LuminanceUnit::stilb => "stilb",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for LuminanceUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for LuminanceUnit {
            #[inline]
            fn eq(&self, other: &LuminanceUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for LuminanceUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for LuminanceUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const LUMINANCE_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::N2,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::P1));
        pub(crate) const LUMINANCE_YOTTACANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E24;
        pub(crate) const LUMINANCE_ZETTACANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E21;
        pub(crate) const LUMINANCE_EXACANDELA_PER_SQUARE_METER_CONVERSION: f64
            =
            1.0_E18;
        pub(crate) const LUMINANCE_PETACANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E15;
        pub(crate) const LUMINANCE_TERACANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E12;
        pub(crate) const LUMINANCE_GIGACANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E9;
        pub(crate) const LUMINANCE_MEGACANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E6;
        pub(crate) const LUMINANCE_KILOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E3;
        pub(crate) const LUMINANCE_HECTOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E2;
        pub(crate) const LUMINANCE_DECACANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E1;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_METER_CONVERSION: f64 =
            1.0_E0;
        pub(crate) const LUMINANCE_DECICANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-1;
        pub(crate) const LUMINANCE_CENTICANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-2;
        pub(crate) const LUMINANCE_MILLICANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-3;
        pub(crate) const LUMINANCE_MICROCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-6;
        pub(crate) const LUMINANCE_NANOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-9;
        pub(crate) const LUMINANCE_PICOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-12;
        pub(crate) const LUMINANCE_FEMTOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-15;
        pub(crate) const LUMINANCE_ATTOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-18;
        pub(crate) const LUMINANCE_ZEPTOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-21;
        pub(crate) const LUMINANCE_YOCTOCANDELA_PER_SQUARE_METER_CONVERSION:
            f64 =
            1.0_E-24;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_PICOMETER_CONVERSION:
            f64 =
            1.0_E24;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_NANOMETER_CONVERSION:
            f64 =
            1.0_E18;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_MICROMETER_CONVERSION:
            f64 =
            1.0_E12;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_MILLIMETER_CONVERSION:
            f64 =
            1.0_E6;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_CENTIMETER_CONVERSION:
            f64 =
            1.0_E4;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_KILOMETER_CONVERSION:
            f64 =
            1.0_E-6;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_MEGAMETER_CONVERSION:
            f64 =
            1.0_E-12;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_GIGAMETER_CONVERSION:
            f64 =
            1.0_E-18;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_TERAMETER_CONVERSION:
            f64 =
            1.0_E-24;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_INCH_CONVERSION: f64 =
            1.550_003_100_006_200_2_E3;
        pub(crate) const LUMINANCE_CANDELA_PER_SQUARE_FOOT_CONVERSION: f64 =
            1.076_391_041_670_972_2_E1;
        pub(crate) const LUMINANCE_FOOTLAMBERT_CONVERSION: f64 =
            3.426_259_099_635_390_5_E0;
        pub(crate) const LUMINANCE_LAMBERT_CONVERSION: f64 =
            3.183_098_861_837_906_7_E3;
        pub(crate) const LUMINANCE_STILB_CONVERSION: f64 = 1.0_E4;
        impl LuminanceUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_yottacandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_YOTTACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zettacandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_ZETTACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_exacandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_EXACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_petacandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_PETACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_teracandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_TERACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gigacandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_GIGACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_megacandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_MEGACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kilocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_KILOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hectocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_HECTOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decacandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_DECACANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decicandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_DECICANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_centicandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CENTICANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_millicandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_MILLICANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_microcandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_MICROCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nanocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_NANOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_picocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_PICOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_femtocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_FEMTOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_attocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_ATTOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zeptocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_ZEPTOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yoctocandela_per_square_meter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_YOCTOCANDELA_PER_SQUARE_METER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_picometer() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_PICOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_nanometer() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_NANOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_micrometer() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_MICROMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_millimeter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_MILLIMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_centimeter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_CENTIMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_kilometer() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_KILOMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_megameter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_MEGAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_gigameter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_GIGAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_terameter() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_TERAMETER_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_inch() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_INCH_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_candela_per_square_foot() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_CANDELA_PER_SQUARE_FOOT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_footlambert() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_FOOTLAMBERT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_lambert() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_LAMBERT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_stilb() -> UnitDefinition {
                UnitDefinition {
                    base: LUMINANCE_UNIT_BASE,
                    multiplier: LUMINANCE_STILB_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        LUMINANCE_YOTTACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::zettacandela_per_square_meter =>
                        LUMINANCE_ZETTACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::exacandela_per_square_meter =>
                        LUMINANCE_EXACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::petacandela_per_square_meter =>
                        LUMINANCE_PETACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::teracandela_per_square_meter =>
                        LUMINANCE_TERACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::gigacandela_per_square_meter =>
                        LUMINANCE_GIGACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::megacandela_per_square_meter =>
                        LUMINANCE_MEGACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::kilocandela_per_square_meter =>
                        LUMINANCE_KILOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::hectocandela_per_square_meter =>
                        LUMINANCE_HECTOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::decacandela_per_square_meter =>
                        LUMINANCE_DECACANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::candela_per_square_meter =>
                        LUMINANCE_CANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::decicandela_per_square_meter =>
                        LUMINANCE_DECICANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::centicandela_per_square_meter =>
                        LUMINANCE_CENTICANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::millicandela_per_square_meter =>
                        LUMINANCE_MILLICANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::microcandela_per_square_meter =>
                        LUMINANCE_MICROCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::nanocandela_per_square_meter =>
                        LUMINANCE_NANOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::picocandela_per_square_meter =>
                        LUMINANCE_PICOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::femtocandela_per_square_meter =>
                        LUMINANCE_FEMTOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::attocandela_per_square_meter =>
                        LUMINANCE_ATTOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        LUMINANCE_ZEPTOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        LUMINANCE_YOCTOCANDELA_PER_SQUARE_METER_CONVERSION,
                    LuminanceUnit::candela_per_square_picometer =>
                        LUMINANCE_CANDELA_PER_SQUARE_PICOMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_nanometer =>
                        LUMINANCE_CANDELA_PER_SQUARE_NANOMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_micrometer =>
                        LUMINANCE_CANDELA_PER_SQUARE_MICROMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_millimeter =>
                        LUMINANCE_CANDELA_PER_SQUARE_MILLIMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_centimeter =>
                        LUMINANCE_CANDELA_PER_SQUARE_CENTIMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_kilometer =>
                        LUMINANCE_CANDELA_PER_SQUARE_KILOMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_megameter =>
                        LUMINANCE_CANDELA_PER_SQUARE_MEGAMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_gigameter =>
                        LUMINANCE_CANDELA_PER_SQUARE_GIGAMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_terameter =>
                        LUMINANCE_CANDELA_PER_SQUARE_TERAMETER_CONVERSION,
                    LuminanceUnit::candela_per_square_inch =>
                        LUMINANCE_CANDELA_PER_SQUARE_INCH_CONVERSION,
                    LuminanceUnit::candela_per_square_foot =>
                        LUMINANCE_CANDELA_PER_SQUARE_FOOT_CONVERSION,
                    LuminanceUnit::footlambert =>
                        LUMINANCE_FOOTLAMBERT_CONVERSION,
                    LuminanceUnit::lambert => LUMINANCE_LAMBERT_CONVERSION,
                    LuminanceUnit::stilb => LUMINANCE_STILB_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    LuminanceUnit::yottacandela_per_square_meter => "Ycd/m",
                    LuminanceUnit::zettacandela_per_square_meter => "Zcd/m",
                    LuminanceUnit::exacandela_per_square_meter => "Ecd/m",
                    LuminanceUnit::petacandela_per_square_meter => "Pcd/m",
                    LuminanceUnit::teracandela_per_square_meter => "Tcd/m",
                    LuminanceUnit::gigacandela_per_square_meter => "Gcd/m",
                    LuminanceUnit::megacandela_per_square_meter => "Mcd/m",
                    LuminanceUnit::kilocandela_per_square_meter => "kcd/m",
                    LuminanceUnit::hectocandela_per_square_meter => "hcd/m",
                    LuminanceUnit::decacandela_per_square_meter => "dacd/m",
                    LuminanceUnit::candela_per_square_meter => "cd/m",
                    LuminanceUnit::decicandela_per_square_meter => "dcd/m",
                    LuminanceUnit::centicandela_per_square_meter => "ccd/m",
                    LuminanceUnit::millicandela_per_square_meter => "mcd/m",
                    LuminanceUnit::microcandela_per_square_meter => "cd/m",
                    LuminanceUnit::nanocandela_per_square_meter => "ncd/m",
                    LuminanceUnit::picocandela_per_square_meter => "pcd/m",
                    LuminanceUnit::femtocandela_per_square_meter => "fcd/m",
                    LuminanceUnit::attocandela_per_square_meter => "acd/m",
                    LuminanceUnit::zeptocandela_per_square_meter => "zcd/m",
                    LuminanceUnit::yoctocandela_per_square_meter => "ycd/m",
                    LuminanceUnit::candela_per_square_picometer => "cd/pm",
                    LuminanceUnit::candela_per_square_nanometer => "cd/nm",
                    LuminanceUnit::candela_per_square_micrometer => "cd/m",
                    LuminanceUnit::candela_per_square_millimeter => "cd/mm",
                    LuminanceUnit::candela_per_square_centimeter => "cd/cm",
                    LuminanceUnit::candela_per_square_kilometer => "cd/km",
                    LuminanceUnit::candela_per_square_megameter => "cd/Mm",
                    LuminanceUnit::candela_per_square_gigameter => "cd/Gm",
                    LuminanceUnit::candela_per_square_terameter => "cd/Tm",
                    LuminanceUnit::candela_per_square_inch => "cd/in",
                    LuminanceUnit::candela_per_square_foot => "cd/ft",
                    LuminanceUnit::footlambert => "fl",
                    LuminanceUnit::lambert => "la",
                    LuminanceUnit::stilb => "sb",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        "yottacandela per square meter",
                    LuminanceUnit::zettacandela_per_square_meter =>
                        "zettacandela per square meter",
                    LuminanceUnit::exacandela_per_square_meter =>
                        "exacandela per square meter",
                    LuminanceUnit::petacandela_per_square_meter =>
                        "petacandela per square meter",
                    LuminanceUnit::teracandela_per_square_meter =>
                        "teracandela per square meter",
                    LuminanceUnit::gigacandela_per_square_meter =>
                        "gigacandela per square meter",
                    LuminanceUnit::megacandela_per_square_meter =>
                        "megacandela per square meter",
                    LuminanceUnit::kilocandela_per_square_meter =>
                        "kilocandela per square meter",
                    LuminanceUnit::hectocandela_per_square_meter =>
                        "hectocandela per square meter",
                    LuminanceUnit::decacandela_per_square_meter =>
                        "decacandela per square meter",
                    LuminanceUnit::candela_per_square_meter =>
                        "candela per square meter",
                    LuminanceUnit::decicandela_per_square_meter =>
                        "decicandela per square meter",
                    LuminanceUnit::centicandela_per_square_meter =>
                        "centicandela per square meter",
                    LuminanceUnit::millicandela_per_square_meter =>
                        "millicandela per square meter",
                    LuminanceUnit::microcandela_per_square_meter =>
                        "microcandela per square meter",
                    LuminanceUnit::nanocandela_per_square_meter =>
                        "nanocandela per square meter",
                    LuminanceUnit::picocandela_per_square_meter =>
                        "picocandela per square meter",
                    LuminanceUnit::femtocandela_per_square_meter =>
                        "femtocandela per square meter",
                    LuminanceUnit::attocandela_per_square_meter =>
                        "attocandela per square meter",
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        "zeptocandela per square meter",
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        "yoctocandela per square meter",
                    LuminanceUnit::candela_per_square_picometer =>
                        "candela per square picometer",
                    LuminanceUnit::candela_per_square_nanometer =>
                        "candela per square nanometer",
                    LuminanceUnit::candela_per_square_micrometer =>
                        "candela per square micrometer",
                    LuminanceUnit::candela_per_square_millimeter =>
                        "candela per square millimeter",
                    LuminanceUnit::candela_per_square_centimeter =>
                        "candela per square centimeter",
                    LuminanceUnit::candela_per_square_kilometer =>
                        "candela per square kilometer",
                    LuminanceUnit::candela_per_square_megameter =>
                        "candela per square megameter",
                    LuminanceUnit::candela_per_square_gigameter =>
                        "candela per square gigameter",
                    LuminanceUnit::candela_per_square_terameter =>
                        "candela per square terameter",
                    LuminanceUnit::candela_per_square_inch =>
                        "candela per square inch",
                    LuminanceUnit::candela_per_square_foot =>
                        "candela per square foot",
                    LuminanceUnit::footlambert => "footlambert",
                    LuminanceUnit::lambert => "lambert",
                    LuminanceUnit::stilb => "stilb",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        "yottacandelas per square meter",
                    LuminanceUnit::zettacandela_per_square_meter =>
                        "zettacandelas per square meter",
                    LuminanceUnit::exacandela_per_square_meter =>
                        "exacandelas per square meter",
                    LuminanceUnit::petacandela_per_square_meter =>
                        "petacandelas per square meter",
                    LuminanceUnit::teracandela_per_square_meter =>
                        "teracandelas per square meter",
                    LuminanceUnit::gigacandela_per_square_meter =>
                        "gigacandelas per square meter",
                    LuminanceUnit::megacandela_per_square_meter =>
                        "megacandelas per square meter",
                    LuminanceUnit::kilocandela_per_square_meter =>
                        "kilocandelas per square meter",
                    LuminanceUnit::hectocandela_per_square_meter =>
                        "hectocandelas per square meter",
                    LuminanceUnit::decacandela_per_square_meter =>
                        "decacandelas per square meter",
                    LuminanceUnit::candela_per_square_meter =>
                        "candelas per square meter",
                    LuminanceUnit::decicandela_per_square_meter =>
                        "decicandelas per square meter",
                    LuminanceUnit::centicandela_per_square_meter =>
                        "centicandelas per square meter",
                    LuminanceUnit::millicandela_per_square_meter =>
                        "millicandelas per square meter",
                    LuminanceUnit::microcandela_per_square_meter =>
                        "microcandelas per square meter",
                    LuminanceUnit::nanocandela_per_square_meter =>
                        "nanocandelas per square meter",
                    LuminanceUnit::picocandela_per_square_meter =>
                        "picocandelas per square meter",
                    LuminanceUnit::femtocandela_per_square_meter =>
                        "femtocandelas per square meter",
                    LuminanceUnit::attocandela_per_square_meter =>
                        "attocandelas per square meter",
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        "zeptocandelas per square meter",
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        "yoctocandelas per square meter",
                    LuminanceUnit::candela_per_square_picometer =>
                        "candelas per square picometer",
                    LuminanceUnit::candela_per_square_nanometer =>
                        "candelas per square nanometer",
                    LuminanceUnit::candela_per_square_micrometer =>
                        "candelas per square micrometer",
                    LuminanceUnit::candela_per_square_millimeter =>
                        "candelas per square millimeter",
                    LuminanceUnit::candela_per_square_centimeter =>
                        "candelas per square centimeter",
                    LuminanceUnit::candela_per_square_kilometer =>
                        "candelas per square kilometer",
                    LuminanceUnit::candela_per_square_megameter =>
                        "candelas per square megameter",
                    LuminanceUnit::candela_per_square_gigameter =>
                        "candelas per square gigameter",
                    LuminanceUnit::candela_per_square_terameter =>
                        "candelas per square terameter",
                    LuminanceUnit::candela_per_square_inch =>
                        "candelas per square inch",
                    LuminanceUnit::candela_per_square_foot =>
                        "candelas per square foot",
                    LuminanceUnit::footlambert => "footlamberts",
                    LuminanceUnit::lambert => "lamberts",
                    LuminanceUnit::stilb => "stilbs",
                }
            }
            #[doc = "Available units for this `[LuminanceUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["yottacandela per square meter",
                                "zettacandela per square meter",
                                "exacandela per square meter",
                                "petacandela per square meter",
                                "teracandela per square meter",
                                "gigacandela per square meter",
                                "megacandela per square meter",
                                "kilocandela per square meter",
                                "hectocandela per square meter",
                                "decacandela per square meter", "candela per square meter",
                                "decicandela per square meter",
                                "centicandela per square meter",
                                "millicandela per square meter",
                                "microcandela per square meter",
                                "nanocandela per square meter",
                                "picocandela per square meter",
                                "femtocandela per square meter",
                                "attocandela per square meter",
                                "zeptocandela per square meter",
                                "yoctocandela per square meter",
                                "candela per square picometer",
                                "candela per square nanometer",
                                "candela per square micrometer",
                                "candela per square millimeter",
                                "candela per square centimeter",
                                "candela per square kilometer",
                                "candela per square megameter",
                                "candela per square gigameter",
                                "candela per square terameter", "candela per square inch",
                                "candela per square foot", "footlambert", "lambert",
                                "stilb"];
                UNITS
            }
        }
        impl crate::traits::Unit for LuminanceUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        LuminanceUnit::get_yottacandela_per_square_meter(),
                    LuminanceUnit::zettacandela_per_square_meter =>
                        LuminanceUnit::get_zettacandela_per_square_meter(),
                    LuminanceUnit::exacandela_per_square_meter =>
                        LuminanceUnit::get_exacandela_per_square_meter(),
                    LuminanceUnit::petacandela_per_square_meter =>
                        LuminanceUnit::get_petacandela_per_square_meter(),
                    LuminanceUnit::teracandela_per_square_meter =>
                        LuminanceUnit::get_teracandela_per_square_meter(),
                    LuminanceUnit::gigacandela_per_square_meter =>
                        LuminanceUnit::get_gigacandela_per_square_meter(),
                    LuminanceUnit::megacandela_per_square_meter =>
                        LuminanceUnit::get_megacandela_per_square_meter(),
                    LuminanceUnit::kilocandela_per_square_meter =>
                        LuminanceUnit::get_kilocandela_per_square_meter(),
                    LuminanceUnit::hectocandela_per_square_meter =>
                        LuminanceUnit::get_hectocandela_per_square_meter(),
                    LuminanceUnit::decacandela_per_square_meter =>
                        LuminanceUnit::get_decacandela_per_square_meter(),
                    LuminanceUnit::candela_per_square_meter =>
                        LuminanceUnit::get_candela_per_square_meter(),
                    LuminanceUnit::decicandela_per_square_meter =>
                        LuminanceUnit::get_decicandela_per_square_meter(),
                    LuminanceUnit::centicandela_per_square_meter =>
                        LuminanceUnit::get_centicandela_per_square_meter(),
                    LuminanceUnit::millicandela_per_square_meter =>
                        LuminanceUnit::get_millicandela_per_square_meter(),
                    LuminanceUnit::microcandela_per_square_meter =>
                        LuminanceUnit::get_microcandela_per_square_meter(),
                    LuminanceUnit::nanocandela_per_square_meter =>
                        LuminanceUnit::get_nanocandela_per_square_meter(),
                    LuminanceUnit::picocandela_per_square_meter =>
                        LuminanceUnit::get_picocandela_per_square_meter(),
                    LuminanceUnit::femtocandela_per_square_meter =>
                        LuminanceUnit::get_femtocandela_per_square_meter(),
                    LuminanceUnit::attocandela_per_square_meter =>
                        LuminanceUnit::get_attocandela_per_square_meter(),
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        LuminanceUnit::get_zeptocandela_per_square_meter(),
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        LuminanceUnit::get_yoctocandela_per_square_meter(),
                    LuminanceUnit::candela_per_square_picometer =>
                        LuminanceUnit::get_candela_per_square_picometer(),
                    LuminanceUnit::candela_per_square_nanometer =>
                        LuminanceUnit::get_candela_per_square_nanometer(),
                    LuminanceUnit::candela_per_square_micrometer =>
                        LuminanceUnit::get_candela_per_square_micrometer(),
                    LuminanceUnit::candela_per_square_millimeter =>
                        LuminanceUnit::get_candela_per_square_millimeter(),
                    LuminanceUnit::candela_per_square_centimeter =>
                        LuminanceUnit::get_candela_per_square_centimeter(),
                    LuminanceUnit::candela_per_square_kilometer =>
                        LuminanceUnit::get_candela_per_square_kilometer(),
                    LuminanceUnit::candela_per_square_megameter =>
                        LuminanceUnit::get_candela_per_square_megameter(),
                    LuminanceUnit::candela_per_square_gigameter =>
                        LuminanceUnit::get_candela_per_square_gigameter(),
                    LuminanceUnit::candela_per_square_terameter =>
                        LuminanceUnit::get_candela_per_square_terameter(),
                    LuminanceUnit::candela_per_square_inch =>
                        LuminanceUnit::get_candela_per_square_inch(),
                    LuminanceUnit::candela_per_square_foot =>
                        LuminanceUnit::get_candela_per_square_foot(),
                    LuminanceUnit::footlambert =>
                        LuminanceUnit::get_footlambert(),
                    LuminanceUnit::lambert => LuminanceUnit::get_lambert(),
                    LuminanceUnit::stilb => LuminanceUnit::get_stilb(),
                }
            }
            #[inline]
            fn base() -> UnitBase { LUMINANCE_UNIT_BASE }
        }
        impl From<LuminanceUnit> for crate::Units {
            fn from(value: LuminanceUnit) -> Self {
                match value {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::yottacandela_per_square_meter),
                    LuminanceUnit::zettacandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::zettacandela_per_square_meter),
                    LuminanceUnit::exacandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::exacandela_per_square_meter),
                    LuminanceUnit::petacandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::petacandela_per_square_meter),
                    LuminanceUnit::teracandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::teracandela_per_square_meter),
                    LuminanceUnit::gigacandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::gigacandela_per_square_meter),
                    LuminanceUnit::megacandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::megacandela_per_square_meter),
                    LuminanceUnit::kilocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::kilocandela_per_square_meter),
                    LuminanceUnit::hectocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::hectocandela_per_square_meter),
                    LuminanceUnit::decacandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::decacandela_per_square_meter),
                    LuminanceUnit::candela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_meter),
                    LuminanceUnit::decicandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::decicandela_per_square_meter),
                    LuminanceUnit::centicandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::centicandela_per_square_meter),
                    LuminanceUnit::millicandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::millicandela_per_square_meter),
                    LuminanceUnit::microcandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::microcandela_per_square_meter),
                    LuminanceUnit::nanocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::nanocandela_per_square_meter),
                    LuminanceUnit::picocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::picocandela_per_square_meter),
                    LuminanceUnit::femtocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::femtocandela_per_square_meter),
                    LuminanceUnit::attocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::attocandela_per_square_meter),
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::zeptocandela_per_square_meter),
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        crate::Units::Luminance(LuminanceUnit::yoctocandela_per_square_meter),
                    LuminanceUnit::candela_per_square_picometer =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_picometer),
                    LuminanceUnit::candela_per_square_nanometer =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_nanometer),
                    LuminanceUnit::candela_per_square_micrometer =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_micrometer),
                    LuminanceUnit::candela_per_square_millimeter =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_millimeter),
                    LuminanceUnit::candela_per_square_centimeter =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_centimeter),
                    LuminanceUnit::candela_per_square_kilometer =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_kilometer),
                    LuminanceUnit::candela_per_square_megameter =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_megameter),
                    LuminanceUnit::candela_per_square_gigameter =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_gigameter),
                    LuminanceUnit::candela_per_square_terameter =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_terameter),
                    LuminanceUnit::candela_per_square_inch =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_inch),
                    LuminanceUnit::candela_per_square_foot =>
                        crate::Units::Luminance(LuminanceUnit::candela_per_square_foot),
                    LuminanceUnit::footlambert =>
                        crate::Units::Luminance(LuminanceUnit::footlambert),
                    LuminanceUnit::lambert =>
                        crate::Units::Luminance(LuminanceUnit::lambert),
                    LuminanceUnit::stilb =>
                        crate::Units::Luminance(LuminanceUnit::stilb),
                }
            }
        }
        impl TryFrom<UnitDefinition> for LuminanceUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_YOTTACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::yottacandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_ZETTACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::zettacandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_EXACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::exacandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_PETACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::petacandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_TERACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::teracandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_GIGACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::gigacandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_MEGACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::megacandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_KILOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::kilocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_HECTOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::hectocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_DECACANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::decacandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_METER_CONVERSION }
                        => Ok(LuminanceUnit::candela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_DECICANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::decicandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CENTICANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::centicandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_MILLICANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::millicandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_MICROCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::microcandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_NANOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::nanocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_PICOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::picocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_FEMTOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::femtocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_ATTOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::attocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_ZEPTOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::zeptocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_YOCTOCANDELA_PER_SQUARE_METER_CONVERSION
                        } => Ok(LuminanceUnit::yoctocandela_per_square_meter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_PICOMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_picometer),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_NANOMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_nanometer),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_MICROMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_micrometer),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_MILLIMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_millimeter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_CENTIMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_centimeter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_KILOMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_kilometer),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_MEGAMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_megameter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_GIGAMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_gigameter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_TERAMETER_CONVERSION
                        } => Ok(LuminanceUnit::candela_per_square_terameter),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_INCH_CONVERSION }
                        => Ok(LuminanceUnit::candela_per_square_inch),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_CANDELA_PER_SQUARE_FOOT_CONVERSION }
                        => Ok(LuminanceUnit::candela_per_square_foot),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_FOOTLAMBERT_CONVERSION } =>
                        Ok(LuminanceUnit::footlambert),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_LAMBERT_CONVERSION } =>
                        Ok(LuminanceUnit::lambert),
                    UnitDefinition {
                        base: LUMINANCE_UNIT_BASE,
                        multiplier: LUMINANCE_STILB_CONVERSION } =>
                        Ok(LuminanceUnit::stilb),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "Luminance"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for LuminanceUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::Luminance(LuminanceUnit::yottacandela_per_square_meter)
                        => Ok(LuminanceUnit::yottacandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::zettacandela_per_square_meter)
                        => Ok(LuminanceUnit::zettacandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::exacandela_per_square_meter)
                        => Ok(LuminanceUnit::exacandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::petacandela_per_square_meter)
                        => Ok(LuminanceUnit::petacandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::teracandela_per_square_meter)
                        => Ok(LuminanceUnit::teracandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::gigacandela_per_square_meter)
                        => Ok(LuminanceUnit::gigacandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::megacandela_per_square_meter)
                        => Ok(LuminanceUnit::megacandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::kilocandela_per_square_meter)
                        => Ok(LuminanceUnit::kilocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::hectocandela_per_square_meter)
                        => Ok(LuminanceUnit::hectocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::decacandela_per_square_meter)
                        => Ok(LuminanceUnit::decacandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_meter)
                        => Ok(LuminanceUnit::candela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::decicandela_per_square_meter)
                        => Ok(LuminanceUnit::decicandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::centicandela_per_square_meter)
                        => Ok(LuminanceUnit::centicandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::millicandela_per_square_meter)
                        => Ok(LuminanceUnit::millicandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::microcandela_per_square_meter)
                        => Ok(LuminanceUnit::microcandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::nanocandela_per_square_meter)
                        => Ok(LuminanceUnit::nanocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::picocandela_per_square_meter)
                        => Ok(LuminanceUnit::picocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::femtocandela_per_square_meter)
                        => Ok(LuminanceUnit::femtocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::attocandela_per_square_meter)
                        => Ok(LuminanceUnit::attocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::zeptocandela_per_square_meter)
                        => Ok(LuminanceUnit::zeptocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::yoctocandela_per_square_meter)
                        => Ok(LuminanceUnit::yoctocandela_per_square_meter),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_picometer)
                        => Ok(LuminanceUnit::candela_per_square_picometer),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_nanometer)
                        => Ok(LuminanceUnit::candela_per_square_nanometer),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_micrometer)
                        => Ok(LuminanceUnit::candela_per_square_micrometer),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_millimeter)
                        => Ok(LuminanceUnit::candela_per_square_millimeter),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_centimeter)
                        => Ok(LuminanceUnit::candela_per_square_centimeter),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_kilometer)
                        => Ok(LuminanceUnit::candela_per_square_kilometer),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_megameter)
                        => Ok(LuminanceUnit::candela_per_square_megameter),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_gigameter)
                        => Ok(LuminanceUnit::candela_per_square_gigameter),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_terameter)
                        => Ok(LuminanceUnit::candela_per_square_terameter),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_inch)
                        => Ok(LuminanceUnit::candela_per_square_inch),
                    crate::Units::Luminance(LuminanceUnit::candela_per_square_foot)
                        => Ok(LuminanceUnit::candela_per_square_foot),
                    crate::Units::Luminance(LuminanceUnit::footlambert) =>
                        Ok(LuminanceUnit::footlambert),
                    crate::Units::Luminance(LuminanceUnit::lambert) =>
                        Ok(LuminanceUnit::lambert),
                    crate::Units::Luminance(LuminanceUnit::stilb) =>
                        Ok(LuminanceUnit::stilb),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "Luminance"));
                                        res
                                    }))),
                }
            }
        }
        impl From<Luminance> for crate::Units {
            fn from(value: Luminance) -> Self {
                crate::Units::Luminance(value.unit)
            }
        }
        impl From<&Luminance> for crate::Units {
            fn from(value: &Luminance) -> Self {
                crate::Units::Luminance(value.unit)
            }
        }
        impl From<LuminanceVec> for crate::Units {
            fn from(value: LuminanceVec) -> Self {
                crate::Units::Luminance(value.unit)
            }
        }
        impl From<&LuminanceVec> for crate::Units {
            fn from(value: &LuminanceVec) -> Self {
                crate::Units::Luminance(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc =
        r" Luminance (base UnitDefinition candela per square meter, cd  m)."]
        #[schema(title = "Luminance")]
        #[doc = "Scalar storage of a quantity (f64 and [`LuminanceUnit`])."]
        pub struct Luminance {
            pub(crate) value: f64,
            pub(crate) unit: LuminanceUnit,
        }
        impl utoipa::__dev::ComposeSchema for Luminance {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <LuminanceUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("Luminance")).description(Some(" Luminance (base UnitDefinition candela per square meter, cd  m).\nScalar storage of a quantity (f64 and [`LuminanceUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for Luminance {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("Luminance")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <LuminanceUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <LuminanceUnit as utoipa::PartialSchema>::schema())]);
                <LuminanceUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Luminance {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "Luminance", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Luminance {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Luminance>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Luminance;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct Luminance")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct Luminance with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<LuminanceUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct Luminance with 2 elements")),
                                    };
                                _serde::__private::Ok(Luminance {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<LuminanceUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<LuminanceUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(Luminance {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "Luminance", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Luminance>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for Luminance { }
        #[automatically_derived]
        impl ::core::clone::Clone for Luminance {
            #[inline]
            fn clone(&self) -> Luminance {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _: ::core::clone::AssertParamIsClone<LuminanceUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Luminance {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "Luminance", "value", &self.value, "unit", &&self.unit)
            }
        }
        impl Luminance {
            #[doc = "Create a new [`LuminanceUnit`]."]
            pub fn new(value: f64, unit: LuminanceUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::yottacandela_per_square_meter`]."]
            pub fn yottacandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::yottacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::zettacandela_per_square_meter`]."]
            pub fn zettacandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::zettacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::exacandela_per_square_meter`]."]
            pub fn exacandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::exacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::petacandela_per_square_meter`]."]
            pub fn petacandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::petacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::teracandela_per_square_meter`]."]
            pub fn teracandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::teracandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::gigacandela_per_square_meter`]."]
            pub fn gigacandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::gigacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::megacandela_per_square_meter`]."]
            pub fn megacandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::megacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::kilocandela_per_square_meter`]."]
            pub fn kilocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::kilocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::hectocandela_per_square_meter`]."]
            pub fn hectocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::hectocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::decacandela_per_square_meter`]."]
            pub fn decacandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::decacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_meter`]."]
            pub fn candela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::decicandela_per_square_meter`]."]
            pub fn decicandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::decicandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::centicandela_per_square_meter`]."]
            pub fn centicandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::centicandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::millicandela_per_square_meter`]."]
            pub fn millicandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::millicandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::microcandela_per_square_meter`]."]
            pub fn microcandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::microcandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::nanocandela_per_square_meter`]."]
            pub fn nanocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::nanocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::picocandela_per_square_meter`]."]
            pub fn picocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::picocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::femtocandela_per_square_meter`]."]
            pub fn femtocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::femtocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::attocandela_per_square_meter`]."]
            pub fn attocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::attocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::zeptocandela_per_square_meter`]."]
            pub fn zeptocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::zeptocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::yoctocandela_per_square_meter`]."]
            pub fn yoctocandela_per_square_meter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::yoctocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_picometer`]."]
            pub fn candela_per_square_picometer(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_picometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_nanometer`]."]
            pub fn candela_per_square_nanometer(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_nanometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_micrometer`]."]
            pub fn candela_per_square_micrometer(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_micrometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_millimeter`]."]
            pub fn candela_per_square_millimeter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_millimeter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_centimeter`]."]
            pub fn candela_per_square_centimeter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_centimeter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_kilometer`]."]
            pub fn candela_per_square_kilometer(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_kilometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_megameter`]."]
            pub fn candela_per_square_megameter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_megameter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_gigameter`]."]
            pub fn candela_per_square_gigameter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_gigameter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_terameter`]."]
            pub fn candela_per_square_terameter(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_terameter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_inch`]."]
            pub fn candela_per_square_inch(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_inch.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_foot`]."]
            pub fn candela_per_square_foot(value: f64) -> Self {
                Self {
                    value,
                    unit: LuminanceUnit::candela_per_square_foot.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::footlambert`]."]
            pub fn footlambert(value: f64) -> Self {
                Self { value, unit: LuminanceUnit::footlambert.into() }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::lambert`]."]
            pub fn lambert(value: f64) -> Self {
                Self { value, unit: LuminanceUnit::lambert.into() }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::stilb`]."]
            pub fn stilb(value: f64) -> Self {
                Self { value, unit: LuminanceUnit::stilb.into() }
            }
            #[doc = "Retrieve the value associated with this [`Luminance`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`Luminance`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`Luminance`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc =
            "Convert to [`LuminanceUnit::yottacandela_per_square_meter`]."]
            #[inline]
            pub fn to_yottacandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_YOTTACANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::yottacandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::zettacandela_per_square_meter`]."]
            #[inline]
            pub fn to_zettacandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_ZETTACANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::zettacandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::exacandela_per_square_meter`]."]
            #[inline]
            pub fn to_exacandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_EXACANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::exacandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::petacandela_per_square_meter`]."]
            #[inline]
            pub fn to_petacandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_PETACANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::petacandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::teracandela_per_square_meter`]."]
            #[inline]
            pub fn to_teracandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_TERACANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::teracandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::gigacandela_per_square_meter`]."]
            #[inline]
            pub fn to_gigacandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_GIGACANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::gigacandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::megacandela_per_square_meter`]."]
            #[inline]
            pub fn to_megacandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_MEGACANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::megacandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::kilocandela_per_square_meter`]."]
            #[inline]
            pub fn to_kilocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_KILOCANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::kilocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::hectocandela_per_square_meter`]."]
            #[inline]
            pub fn to_hectocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_HECTOCANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::hectocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::decacandela_per_square_meter`]."]
            #[inline]
            pub fn to_decacandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_DECACANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::decacandela_per_square_meter,
                }
            }
            #[doc = "Convert to [`LuminanceUnit::candela_per_square_meter`]."]
            #[inline]
            pub fn to_candela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::decicandela_per_square_meter`]."]
            #[inline]
            pub fn to_decicandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_DECICANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::decicandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::centicandela_per_square_meter`]."]
            #[inline]
            pub fn to_centicandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CENTICANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::centicandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::millicandela_per_square_meter`]."]
            #[inline]
            pub fn to_millicandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_MILLICANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::millicandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::microcandela_per_square_meter`]."]
            #[inline]
            pub fn to_microcandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_MICROCANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::microcandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::nanocandela_per_square_meter`]."]
            #[inline]
            pub fn to_nanocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_NANOCANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::nanocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::picocandela_per_square_meter`]."]
            #[inline]
            pub fn to_picocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_PICOCANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::picocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::femtocandela_per_square_meter`]."]
            #[inline]
            pub fn to_femtocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_FEMTOCANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::femtocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::attocandela_per_square_meter`]."]
            #[inline]
            pub fn to_attocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_ATTOCANDELA_PER_SQUARE_METER_CONVERSION)) as f64,
                    unit: LuminanceUnit::attocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::zeptocandela_per_square_meter`]."]
            #[inline]
            pub fn to_zeptocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_ZEPTOCANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::zeptocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::yoctocandela_per_square_meter`]."]
            #[inline]
            pub fn to_yoctocandela_per_square_meter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_YOCTOCANDELA_PER_SQUARE_METER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::yoctocandela_per_square_meter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_picometer`]."]
            #[inline]
            pub fn to_candela_per_square_picometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_PICOMETER_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_picometer,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_nanometer`]."]
            #[inline]
            pub fn to_candela_per_square_nanometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_NANOMETER_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_nanometer,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_micrometer`]."]
            #[inline]
            pub fn to_candela_per_square_micrometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_MICROMETER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::candela_per_square_micrometer,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_millimeter`]."]
            #[inline]
            pub fn to_candela_per_square_millimeter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_MILLIMETER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::candela_per_square_millimeter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_centimeter`]."]
            #[inline]
            pub fn to_candela_per_square_centimeter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_CENTIMETER_CONVERSION)) as
                            f64,
                    unit: LuminanceUnit::candela_per_square_centimeter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_kilometer`]."]
            #[inline]
            pub fn to_candela_per_square_kilometer(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_KILOMETER_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_kilometer,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_megameter`]."]
            #[inline]
            pub fn to_candela_per_square_megameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_MEGAMETER_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_megameter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_gigameter`]."]
            #[inline]
            pub fn to_candela_per_square_gigameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_GIGAMETER_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_gigameter,
                }
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_terameter`]."]
            #[inline]
            pub fn to_candela_per_square_terameter(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_TERAMETER_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_terameter,
                }
            }
            #[doc = "Convert to [`LuminanceUnit::candela_per_square_inch`]."]
            #[inline]
            pub fn to_candela_per_square_inch(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_INCH_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_inch,
                }
            }
            #[doc = "Convert to [`LuminanceUnit::candela_per_square_foot`]."]
            #[inline]
            pub fn to_candela_per_square_foot(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_CANDELA_PER_SQUARE_FOOT_CONVERSION)) as f64,
                    unit: LuminanceUnit::candela_per_square_foot,
                }
            }
            #[doc = "Convert to [`LuminanceUnit::footlambert`]."]
            #[inline]
            pub fn to_footlambert(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_FOOTLAMBERT_CONVERSION)) as f64,
                    unit: LuminanceUnit::footlambert,
                }
            }
            #[doc = "Convert to [`LuminanceUnit::lambert`]."]
            #[inline]
            pub fn to_lambert(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_LAMBERT_CONVERSION)) as f64,
                    unit: LuminanceUnit::lambert,
                }
            }
            #[doc = "Convert to [`LuminanceUnit::stilb`]."]
            #[inline]
            pub fn to_stilb(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (LUMINANCE_STILB_CONVERSION)) as f64,
                    unit: LuminanceUnit::stilb,
                }
            }
        }
        impl FixedQuantity<LuminanceUnit> for Luminance {
            #[inline]
            fn unit(&self) -> LuminanceUnit { self.unit }
            #[inline]
            fn convert(&self, unit: LuminanceUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: LuminanceUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut LuminanceUnit { &mut self.unit }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: LuminanceUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<Luminance> for UnitDefinition {
            #[inline]
            fn from(value: Luminance) -> Self {
                match value.unit {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        LuminanceUnit::get_yottacandela_per_square_meter(),
                    LuminanceUnit::zettacandela_per_square_meter =>
                        LuminanceUnit::get_zettacandela_per_square_meter(),
                    LuminanceUnit::exacandela_per_square_meter =>
                        LuminanceUnit::get_exacandela_per_square_meter(),
                    LuminanceUnit::petacandela_per_square_meter =>
                        LuminanceUnit::get_petacandela_per_square_meter(),
                    LuminanceUnit::teracandela_per_square_meter =>
                        LuminanceUnit::get_teracandela_per_square_meter(),
                    LuminanceUnit::gigacandela_per_square_meter =>
                        LuminanceUnit::get_gigacandela_per_square_meter(),
                    LuminanceUnit::megacandela_per_square_meter =>
                        LuminanceUnit::get_megacandela_per_square_meter(),
                    LuminanceUnit::kilocandela_per_square_meter =>
                        LuminanceUnit::get_kilocandela_per_square_meter(),
                    LuminanceUnit::hectocandela_per_square_meter =>
                        LuminanceUnit::get_hectocandela_per_square_meter(),
                    LuminanceUnit::decacandela_per_square_meter =>
                        LuminanceUnit::get_decacandela_per_square_meter(),
                    LuminanceUnit::candela_per_square_meter =>
                        LuminanceUnit::get_candela_per_square_meter(),
                    LuminanceUnit::decicandela_per_square_meter =>
                        LuminanceUnit::get_decicandela_per_square_meter(),
                    LuminanceUnit::centicandela_per_square_meter =>
                        LuminanceUnit::get_centicandela_per_square_meter(),
                    LuminanceUnit::millicandela_per_square_meter =>
                        LuminanceUnit::get_millicandela_per_square_meter(),
                    LuminanceUnit::microcandela_per_square_meter =>
                        LuminanceUnit::get_microcandela_per_square_meter(),
                    LuminanceUnit::nanocandela_per_square_meter =>
                        LuminanceUnit::get_nanocandela_per_square_meter(),
                    LuminanceUnit::picocandela_per_square_meter =>
                        LuminanceUnit::get_picocandela_per_square_meter(),
                    LuminanceUnit::femtocandela_per_square_meter =>
                        LuminanceUnit::get_femtocandela_per_square_meter(),
                    LuminanceUnit::attocandela_per_square_meter =>
                        LuminanceUnit::get_attocandela_per_square_meter(),
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        LuminanceUnit::get_zeptocandela_per_square_meter(),
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        LuminanceUnit::get_yoctocandela_per_square_meter(),
                    LuminanceUnit::candela_per_square_picometer =>
                        LuminanceUnit::get_candela_per_square_picometer(),
                    LuminanceUnit::candela_per_square_nanometer =>
                        LuminanceUnit::get_candela_per_square_nanometer(),
                    LuminanceUnit::candela_per_square_micrometer =>
                        LuminanceUnit::get_candela_per_square_micrometer(),
                    LuminanceUnit::candela_per_square_millimeter =>
                        LuminanceUnit::get_candela_per_square_millimeter(),
                    LuminanceUnit::candela_per_square_centimeter =>
                        LuminanceUnit::get_candela_per_square_centimeter(),
                    LuminanceUnit::candela_per_square_kilometer =>
                        LuminanceUnit::get_candela_per_square_kilometer(),
                    LuminanceUnit::candela_per_square_megameter =>
                        LuminanceUnit::get_candela_per_square_megameter(),
                    LuminanceUnit::candela_per_square_gigameter =>
                        LuminanceUnit::get_candela_per_square_gigameter(),
                    LuminanceUnit::candela_per_square_terameter =>
                        LuminanceUnit::get_candela_per_square_terameter(),
                    LuminanceUnit::candela_per_square_inch =>
                        LuminanceUnit::get_candela_per_square_inch(),
                    LuminanceUnit::candela_per_square_foot =>
                        LuminanceUnit::get_candela_per_square_foot(),
                    LuminanceUnit::footlambert =>
                        LuminanceUnit::get_footlambert(),
                    LuminanceUnit::lambert => LuminanceUnit::get_lambert(),
                    LuminanceUnit::stilb => LuminanceUnit::get_stilb(),
                }
            }
        }
        impl From<Luminance> for Quantity {
            fn from(quantity: Luminance) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for Luminance {
            fn from(quantity: Quantity) -> Luminance {
                Luminance {
                    value: quantity.value,
                    unit: LuminanceUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for Luminance {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl LuminanceVec {
            #[doc = "Create a new vector of [`LuminanceUnit`]."]
            pub fn new(values: Vec<f64>, unit: LuminanceUnit) -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc =
            "Retrieve values associated with this [`LuminanceSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`LuminanceSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::yottacandela_per_square_meter`]."]
            pub fn yottacandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::yottacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::zettacandela_per_square_meter`]."]
            pub fn zettacandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::zettacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::exacandela_per_square_meter`]."]
            pub fn exacandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::exacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::petacandela_per_square_meter`]."]
            pub fn petacandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::petacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::teracandela_per_square_meter`]."]
            pub fn teracandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::teracandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::gigacandela_per_square_meter`]."]
            pub fn gigacandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::gigacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::megacandela_per_square_meter`]."]
            pub fn megacandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::megacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::kilocandela_per_square_meter`]."]
            pub fn kilocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::kilocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::hectocandela_per_square_meter`]."]
            pub fn hectocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::hectocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::decacandela_per_square_meter`]."]
            pub fn decacandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::decacandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_meter`]."]
            pub fn candela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::decicandela_per_square_meter`]."]
            pub fn decicandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::decicandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::centicandela_per_square_meter`]."]
            pub fn centicandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::centicandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::millicandela_per_square_meter`]."]
            pub fn millicandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::millicandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::microcandela_per_square_meter`]."]
            pub fn microcandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::microcandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::nanocandela_per_square_meter`]."]
            pub fn nanocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::nanocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::picocandela_per_square_meter`]."]
            pub fn picocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::picocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::femtocandela_per_square_meter`]."]
            pub fn femtocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::femtocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::attocandela_per_square_meter`]."]
            pub fn attocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::attocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::zeptocandela_per_square_meter`]."]
            pub fn zeptocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::zeptocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::yoctocandela_per_square_meter`]."]
            pub fn yoctocandela_per_square_meter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::yoctocandela_per_square_meter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_picometer`]."]
            pub fn candela_per_square_picometer(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_picometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_nanometer`]."]
            pub fn candela_per_square_nanometer(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_nanometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_micrometer`]."]
            pub fn candela_per_square_micrometer(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_micrometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_millimeter`]."]
            pub fn candela_per_square_millimeter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_millimeter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_centimeter`]."]
            pub fn candela_per_square_centimeter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_centimeter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_kilometer`]."]
            pub fn candela_per_square_kilometer(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_kilometer.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_megameter`]."]
            pub fn candela_per_square_megameter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_megameter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_gigameter`]."]
            pub fn candela_per_square_gigameter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_gigameter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_terameter`]."]
            pub fn candela_per_square_terameter(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_terameter.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_inch`]."]
            pub fn candela_per_square_inch(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_inch.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::candela_per_square_foot`]."]
            pub fn candela_per_square_foot(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: LuminanceUnit::candela_per_square_foot.into(),
                }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::footlambert`]."]
            pub fn footlambert(values: Vec<f64>) -> Self {
                Self { values, unit: LuminanceUnit::footlambert.into() }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::lambert`]."]
            pub fn lambert(values: Vec<f64>) -> Self {
                Self { values, unit: LuminanceUnit::lambert.into() }
            }
            #[doc =
            "Create a new [`Luminance`] with units of [`LuminanceUnit::stilb`]."]
            pub fn stilb(values: Vec<f64>) -> Self {
                Self { values, unit: LuminanceUnit::stilb.into() }
            }
            #[doc =
            "Convert to [`LuminanceUnit::yottacandela_per_square_meter`]."]
            #[inline]
            pub fn to_yottacandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::yottacandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::zettacandela_per_square_meter`]."]
            #[inline]
            pub fn to_zettacandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::zettacandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::exacandela_per_square_meter`]."]
            #[inline]
            pub fn to_exacandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::exacandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::petacandela_per_square_meter`]."]
            #[inline]
            pub fn to_petacandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::petacandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::teracandela_per_square_meter`]."]
            #[inline]
            pub fn to_teracandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::teracandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::gigacandela_per_square_meter`]."]
            #[inline]
            pub fn to_gigacandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::gigacandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::megacandela_per_square_meter`]."]
            #[inline]
            pub fn to_megacandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::megacandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::kilocandela_per_square_meter`]."]
            #[inline]
            pub fn to_kilocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::kilocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::hectocandela_per_square_meter`]."]
            #[inline]
            pub fn to_hectocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::hectocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::decacandela_per_square_meter`]."]
            #[inline]
            pub fn to_decacandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::decacandela_per_square_meter);
                r
            }
            #[doc = "Convert to [`LuminanceUnit::candela_per_square_meter`]."]
            #[inline]
            pub fn to_candela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::decicandela_per_square_meter`]."]
            #[inline]
            pub fn to_decicandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::decicandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::centicandela_per_square_meter`]."]
            #[inline]
            pub fn to_centicandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::centicandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::millicandela_per_square_meter`]."]
            #[inline]
            pub fn to_millicandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::millicandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::microcandela_per_square_meter`]."]
            #[inline]
            pub fn to_microcandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::microcandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::nanocandela_per_square_meter`]."]
            #[inline]
            pub fn to_nanocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::nanocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::picocandela_per_square_meter`]."]
            #[inline]
            pub fn to_picocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::picocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::femtocandela_per_square_meter`]."]
            #[inline]
            pub fn to_femtocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::femtocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::attocandela_per_square_meter`]."]
            #[inline]
            pub fn to_attocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::attocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::zeptocandela_per_square_meter`]."]
            #[inline]
            pub fn to_zeptocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::zeptocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::yoctocandela_per_square_meter`]."]
            #[inline]
            pub fn to_yoctocandela_per_square_meter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::yoctocandela_per_square_meter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_picometer`]."]
            #[inline]
            pub fn to_candela_per_square_picometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_picometer);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_nanometer`]."]
            #[inline]
            pub fn to_candela_per_square_nanometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_nanometer);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_micrometer`]."]
            #[inline]
            pub fn to_candela_per_square_micrometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_micrometer);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_millimeter`]."]
            #[inline]
            pub fn to_candela_per_square_millimeter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_millimeter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_centimeter`]."]
            #[inline]
            pub fn to_candela_per_square_centimeter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_centimeter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_kilometer`]."]
            #[inline]
            pub fn to_candela_per_square_kilometer(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_kilometer);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_megameter`]."]
            #[inline]
            pub fn to_candela_per_square_megameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_megameter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_gigameter`]."]
            #[inline]
            pub fn to_candela_per_square_gigameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_gigameter);
                r
            }
            #[doc =
            "Convert to [`LuminanceUnit::candela_per_square_terameter`]."]
            #[inline]
            pub fn to_candela_per_square_terameter(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_terameter);
                r
            }
            #[doc = "Convert to [`LuminanceUnit::candela_per_square_inch`]."]
            #[inline]
            pub fn to_candela_per_square_inch(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_inch);
                r
            }
            #[doc = "Convert to [`LuminanceUnit::candela_per_square_foot`]."]
            #[inline]
            pub fn to_candela_per_square_foot(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::candela_per_square_foot);
                r
            }
            #[doc = "Convert to [`LuminanceUnit::footlambert`]."]
            #[inline]
            pub fn to_footlambert(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::footlambert);
                r
            }
            #[doc = "Convert to [`LuminanceUnit::lambert`]."]
            #[inline]
            pub fn to_lambert(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::lambert);
                r
            }
            #[doc = "Convert to [`LuminanceUnit::stilb`]."]
            #[inline]
            pub fn to_stilb(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(LuminanceUnit::stilb);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for Luminance {
            type Output = Luminance;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for Luminance {
            type Output = Luminance;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for Luminance {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for Luminance {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for Luminance {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<Luminance> for Quantity {
            fn eq(&self, other: &Luminance) -> bool { *other == *self }
        }
        impl PartialEq<Luminance> for Luminance {
            fn eq(&self, other: &Luminance) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for Luminance {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for Luminance {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<Luminance> for Luminance {
            type Output = Self;
            fn add(self, rhs: Luminance) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Luminance> for Luminance {
            type Output = Self;
            fn sub(self, rhs: Luminance) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for Luminance {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for Luminance {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for Luminance {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for Luminance {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for Luminance {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for Luminance {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc = "Array storage for a series of values and [`LuminanceUnit`]."]
        pub struct LuminanceArray<const N : usize> {
            pub(crate) unit: LuminanceUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for
            LuminanceArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <LuminanceUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`LuminanceUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for LuminanceArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("LuminanceArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <LuminanceUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <LuminanceUnit as utoipa::PartialSchema>::schema())]);
                <LuminanceUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for LuminanceArray<N>
                    {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "LuminanceArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<LuminanceArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<LuminanceArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    LuminanceArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<LuminanceArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = LuminanceArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct LuminanceArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<LuminanceUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct LuminanceArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<LuminanceArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct LuminanceArray with 2 elements")),
                                    };
                                _serde::__private::Ok(LuminanceArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<LuminanceUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<LuminanceUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<LuminanceArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(LuminanceArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "LuminanceArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LuminanceArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for LuminanceArray<N> { }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for LuminanceArray<N> {
            #[inline]
            fn clone(&self) -> LuminanceArray<N> {
                let _: ::core::clone::AssertParamIsClone<LuminanceUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for LuminanceArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "LuminanceArray", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            LuminanceArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for LuminanceArray<N> {
            #[inline]
            fn eq(&self, other: &LuminanceArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for LuminanceArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for LuminanceArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc =
        "Vector storage for a series of values and [`LuminanceUnit`]."]
        pub struct LuminanceVec {
            pub(crate) unit: LuminanceUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for LuminanceVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <LuminanceUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`LuminanceUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for LuminanceVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("LuminanceVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <LuminanceUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <LuminanceUnit as utoipa::PartialSchema>::schema())]);
                <LuminanceUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LuminanceVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "LuminanceVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LuminanceVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LuminanceVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LuminanceVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct LuminanceVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<LuminanceUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct LuminanceVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct LuminanceVec with 2 elements")),
                                    };
                                _serde::__private::Ok(LuminanceVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<LuminanceUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<LuminanceUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(LuminanceVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "LuminanceVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LuminanceVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for LuminanceVec {
            #[inline]
            fn clone(&self) -> LuminanceVec {
                LuminanceVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LuminanceVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "LuminanceVec", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LuminanceVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LuminanceVec {
            #[inline]
            fn eq(&self, other: &LuminanceVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for LuminanceVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for LuminanceVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<LuminanceUnit, f64> for
            LuminanceVec {
            fn unit(&self) -> LuminanceUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: LuminanceUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: LuminanceUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: LuminanceUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize>
            crate::traits::FixedSliceQuantity<LuminanceUnit, f64> for
            LuminanceArray<N> {
            fn unit(&self) -> LuminanceUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: LuminanceUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: LuminanceUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: LuminanceUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for LuminanceVec {
            type Output = LuminanceVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for LuminanceVec {
            type Output = LuminanceVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for LuminanceVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for LuminanceVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<LuminanceVec> for LuminanceVec {
            fn add_assign(&mut self, rhs: LuminanceVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<LuminanceVec> for LuminanceVec {
            fn sub_assign(&mut self, rhs: LuminanceVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for LuminanceArray<N> {
            type Output = LuminanceArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for LuminanceArray<N> {
            type Output = LuminanceArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for LuminanceArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for LuminanceArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<LuminanceArray<N>> for
            LuminanceArray<N> {
            fn add_assign(&mut self, rhs: LuminanceArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<LuminanceArray<N>> for
            LuminanceArray<N> {
            fn sub_assign(&mut self, rhs: LuminanceArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<LuminanceVec> for VecQuantity {
            fn from(input: LuminanceVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<LuminanceUnit> for UnitDefinition {
            #[inline]
            fn from(value: LuminanceUnit) -> Self {
                match value {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        LuminanceUnit::get_yottacandela_per_square_meter(),
                    LuminanceUnit::zettacandela_per_square_meter =>
                        LuminanceUnit::get_zettacandela_per_square_meter(),
                    LuminanceUnit::exacandela_per_square_meter =>
                        LuminanceUnit::get_exacandela_per_square_meter(),
                    LuminanceUnit::petacandela_per_square_meter =>
                        LuminanceUnit::get_petacandela_per_square_meter(),
                    LuminanceUnit::teracandela_per_square_meter =>
                        LuminanceUnit::get_teracandela_per_square_meter(),
                    LuminanceUnit::gigacandela_per_square_meter =>
                        LuminanceUnit::get_gigacandela_per_square_meter(),
                    LuminanceUnit::megacandela_per_square_meter =>
                        LuminanceUnit::get_megacandela_per_square_meter(),
                    LuminanceUnit::kilocandela_per_square_meter =>
                        LuminanceUnit::get_kilocandela_per_square_meter(),
                    LuminanceUnit::hectocandela_per_square_meter =>
                        LuminanceUnit::get_hectocandela_per_square_meter(),
                    LuminanceUnit::decacandela_per_square_meter =>
                        LuminanceUnit::get_decacandela_per_square_meter(),
                    LuminanceUnit::candela_per_square_meter =>
                        LuminanceUnit::get_candela_per_square_meter(),
                    LuminanceUnit::decicandela_per_square_meter =>
                        LuminanceUnit::get_decicandela_per_square_meter(),
                    LuminanceUnit::centicandela_per_square_meter =>
                        LuminanceUnit::get_centicandela_per_square_meter(),
                    LuminanceUnit::millicandela_per_square_meter =>
                        LuminanceUnit::get_millicandela_per_square_meter(),
                    LuminanceUnit::microcandela_per_square_meter =>
                        LuminanceUnit::get_microcandela_per_square_meter(),
                    LuminanceUnit::nanocandela_per_square_meter =>
                        LuminanceUnit::get_nanocandela_per_square_meter(),
                    LuminanceUnit::picocandela_per_square_meter =>
                        LuminanceUnit::get_picocandela_per_square_meter(),
                    LuminanceUnit::femtocandela_per_square_meter =>
                        LuminanceUnit::get_femtocandela_per_square_meter(),
                    LuminanceUnit::attocandela_per_square_meter =>
                        LuminanceUnit::get_attocandela_per_square_meter(),
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        LuminanceUnit::get_zeptocandela_per_square_meter(),
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        LuminanceUnit::get_yoctocandela_per_square_meter(),
                    LuminanceUnit::candela_per_square_picometer =>
                        LuminanceUnit::get_candela_per_square_picometer(),
                    LuminanceUnit::candela_per_square_nanometer =>
                        LuminanceUnit::get_candela_per_square_nanometer(),
                    LuminanceUnit::candela_per_square_micrometer =>
                        LuminanceUnit::get_candela_per_square_micrometer(),
                    LuminanceUnit::candela_per_square_millimeter =>
                        LuminanceUnit::get_candela_per_square_millimeter(),
                    LuminanceUnit::candela_per_square_centimeter =>
                        LuminanceUnit::get_candela_per_square_centimeter(),
                    LuminanceUnit::candela_per_square_kilometer =>
                        LuminanceUnit::get_candela_per_square_kilometer(),
                    LuminanceUnit::candela_per_square_megameter =>
                        LuminanceUnit::get_candela_per_square_megameter(),
                    LuminanceUnit::candela_per_square_gigameter =>
                        LuminanceUnit::get_candela_per_square_gigameter(),
                    LuminanceUnit::candela_per_square_terameter =>
                        LuminanceUnit::get_candela_per_square_terameter(),
                    LuminanceUnit::candela_per_square_inch =>
                        LuminanceUnit::get_candela_per_square_inch(),
                    LuminanceUnit::candela_per_square_foot =>
                        LuminanceUnit::get_candela_per_square_foot(),
                    LuminanceUnit::footlambert =>
                        LuminanceUnit::get_footlambert(),
                    LuminanceUnit::lambert => LuminanceUnit::get_lambert(),
                    LuminanceUnit::stilb => LuminanceUnit::get_stilb(),
                }
            }
        }
        impl TryFrom<&str> for LuminanceUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<LuminanceUnit> =
                    match value {
                        "Ycd/m" =>
                            Some(LuminanceUnit::yottacandela_per_square_meter),
                        "Zcd/m" =>
                            Some(LuminanceUnit::zettacandela_per_square_meter),
                        "Ecd/m" =>
                            Some(LuminanceUnit::exacandela_per_square_meter),
                        "Pcd/m" =>
                            Some(LuminanceUnit::petacandela_per_square_meter),
                        "Tcd/m" =>
                            Some(LuminanceUnit::teracandela_per_square_meter),
                        "Gcd/m" =>
                            Some(LuminanceUnit::gigacandela_per_square_meter),
                        "Mcd/m" =>
                            Some(LuminanceUnit::megacandela_per_square_meter),
                        "kcd/m" =>
                            Some(LuminanceUnit::kilocandela_per_square_meter),
                        "hcd/m" =>
                            Some(LuminanceUnit::hectocandela_per_square_meter),
                        "dacd/m" =>
                            Some(LuminanceUnit::decacandela_per_square_meter),
                        "cd/m" => Some(LuminanceUnit::candela_per_square_meter),
                        "dcd/m" =>
                            Some(LuminanceUnit::decicandela_per_square_meter),
                        "ccd/m" =>
                            Some(LuminanceUnit::centicandela_per_square_meter),
                        "mcd/m" =>
                            Some(LuminanceUnit::millicandela_per_square_meter),
                        "cd/m" =>
                            Some(LuminanceUnit::microcandela_per_square_meter),
                        "ncd/m" =>
                            Some(LuminanceUnit::nanocandela_per_square_meter),
                        "pcd/m" =>
                            Some(LuminanceUnit::picocandela_per_square_meter),
                        "fcd/m" =>
                            Some(LuminanceUnit::femtocandela_per_square_meter),
                        "acd/m" =>
                            Some(LuminanceUnit::attocandela_per_square_meter),
                        "zcd/m" =>
                            Some(LuminanceUnit::zeptocandela_per_square_meter),
                        "ycd/m" =>
                            Some(LuminanceUnit::yoctocandela_per_square_meter),
                        "cd/pm" =>
                            Some(LuminanceUnit::candela_per_square_picometer),
                        "cd/nm" =>
                            Some(LuminanceUnit::candela_per_square_nanometer),
                        "cd/m" =>
                            Some(LuminanceUnit::candela_per_square_micrometer),
                        "cd/mm" =>
                            Some(LuminanceUnit::candela_per_square_millimeter),
                        "cd/cm" =>
                            Some(LuminanceUnit::candela_per_square_centimeter),
                        "cd/km" =>
                            Some(LuminanceUnit::candela_per_square_kilometer),
                        "cd/Mm" =>
                            Some(LuminanceUnit::candela_per_square_megameter),
                        "cd/Gm" =>
                            Some(LuminanceUnit::candela_per_square_gigameter),
                        "cd/Tm" =>
                            Some(LuminanceUnit::candela_per_square_terameter),
                        "cd/in" => Some(LuminanceUnit::candela_per_square_inch),
                        "cd/ft" => Some(LuminanceUnit::candela_per_square_foot),
                        "fl" => Some(LuminanceUnit::footlambert),
                        "la" => Some(LuminanceUnit::lambert),
                        "sb" => Some(LuminanceUnit::stilb),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<LuminanceUnit> =
                    match value {
                        "yottacandela per square meter" =>
                            Some(LuminanceUnit::yottacandela_per_square_meter),
                        "zettacandela per square meter" =>
                            Some(LuminanceUnit::zettacandela_per_square_meter),
                        "exacandela per square meter" =>
                            Some(LuminanceUnit::exacandela_per_square_meter),
                        "petacandela per square meter" =>
                            Some(LuminanceUnit::petacandela_per_square_meter),
                        "teracandela per square meter" =>
                            Some(LuminanceUnit::teracandela_per_square_meter),
                        "gigacandela per square meter" =>
                            Some(LuminanceUnit::gigacandela_per_square_meter),
                        "megacandela per square meter" =>
                            Some(LuminanceUnit::megacandela_per_square_meter),
                        "kilocandela per square meter" =>
                            Some(LuminanceUnit::kilocandela_per_square_meter),
                        "hectocandela per square meter" =>
                            Some(LuminanceUnit::hectocandela_per_square_meter),
                        "decacandela per square meter" =>
                            Some(LuminanceUnit::decacandela_per_square_meter),
                        "candela per square meter" =>
                            Some(LuminanceUnit::candela_per_square_meter),
                        "decicandela per square meter" =>
                            Some(LuminanceUnit::decicandela_per_square_meter),
                        "centicandela per square meter" =>
                            Some(LuminanceUnit::centicandela_per_square_meter),
                        "millicandela per square meter" =>
                            Some(LuminanceUnit::millicandela_per_square_meter),
                        "microcandela per square meter" =>
                            Some(LuminanceUnit::microcandela_per_square_meter),
                        "nanocandela per square meter" =>
                            Some(LuminanceUnit::nanocandela_per_square_meter),
                        "picocandela per square meter" =>
                            Some(LuminanceUnit::picocandela_per_square_meter),
                        "femtocandela per square meter" =>
                            Some(LuminanceUnit::femtocandela_per_square_meter),
                        "attocandela per square meter" =>
                            Some(LuminanceUnit::attocandela_per_square_meter),
                        "zeptocandela per square meter" =>
                            Some(LuminanceUnit::zeptocandela_per_square_meter),
                        "yoctocandela per square meter" =>
                            Some(LuminanceUnit::yoctocandela_per_square_meter),
                        "candela per square picometer" =>
                            Some(LuminanceUnit::candela_per_square_picometer),
                        "candela per square nanometer" =>
                            Some(LuminanceUnit::candela_per_square_nanometer),
                        "candela per square micrometer" =>
                            Some(LuminanceUnit::candela_per_square_micrometer),
                        "candela per square millimeter" =>
                            Some(LuminanceUnit::candela_per_square_millimeter),
                        "candela per square centimeter" =>
                            Some(LuminanceUnit::candela_per_square_centimeter),
                        "candela per square kilometer" =>
                            Some(LuminanceUnit::candela_per_square_kilometer),
                        "candela per square megameter" =>
                            Some(LuminanceUnit::candela_per_square_megameter),
                        "candela per square gigameter" =>
                            Some(LuminanceUnit::candela_per_square_gigameter),
                        "candela per square terameter" =>
                            Some(LuminanceUnit::candela_per_square_terameter),
                        "candela per square inch" =>
                            Some(LuminanceUnit::candela_per_square_inch),
                        "candela per square foot" =>
                            Some(LuminanceUnit::candela_per_square_foot),
                        "footlambert" => Some(LuminanceUnit::footlambert),
                        "lambert" => Some(LuminanceUnit::lambert),
                        "stilb" => Some(LuminanceUnit::stilb),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<LuminanceUnit> =
                    match value {
                        "yottacandelas per square meter" =>
                            Some(LuminanceUnit::yottacandela_per_square_meter),
                        "zettacandelas per square meter" =>
                            Some(LuminanceUnit::zettacandela_per_square_meter),
                        "exacandelas per square meter" =>
                            Some(LuminanceUnit::exacandela_per_square_meter),
                        "petacandelas per square meter" =>
                            Some(LuminanceUnit::petacandela_per_square_meter),
                        "teracandelas per square meter" =>
                            Some(LuminanceUnit::teracandela_per_square_meter),
                        "gigacandelas per square meter" =>
                            Some(LuminanceUnit::gigacandela_per_square_meter),
                        "megacandelas per square meter" =>
                            Some(LuminanceUnit::megacandela_per_square_meter),
                        "kilocandelas per square meter" =>
                            Some(LuminanceUnit::kilocandela_per_square_meter),
                        "hectocandelas per square meter" =>
                            Some(LuminanceUnit::hectocandela_per_square_meter),
                        "decacandelas per square meter" =>
                            Some(LuminanceUnit::decacandela_per_square_meter),
                        "candelas per square meter" =>
                            Some(LuminanceUnit::candela_per_square_meter),
                        "decicandelas per square meter" =>
                            Some(LuminanceUnit::decicandela_per_square_meter),
                        "centicandelas per square meter" =>
                            Some(LuminanceUnit::centicandela_per_square_meter),
                        "millicandelas per square meter" =>
                            Some(LuminanceUnit::millicandela_per_square_meter),
                        "microcandelas per square meter" =>
                            Some(LuminanceUnit::microcandela_per_square_meter),
                        "nanocandelas per square meter" =>
                            Some(LuminanceUnit::nanocandela_per_square_meter),
                        "picocandelas per square meter" =>
                            Some(LuminanceUnit::picocandela_per_square_meter),
                        "femtocandelas per square meter" =>
                            Some(LuminanceUnit::femtocandela_per_square_meter),
                        "attocandelas per square meter" =>
                            Some(LuminanceUnit::attocandela_per_square_meter),
                        "zeptocandelas per square meter" =>
                            Some(LuminanceUnit::zeptocandela_per_square_meter),
                        "yoctocandelas per square meter" =>
                            Some(LuminanceUnit::yoctocandela_per_square_meter),
                        "candelas per square picometer" =>
                            Some(LuminanceUnit::candela_per_square_picometer),
                        "candelas per square nanometer" =>
                            Some(LuminanceUnit::candela_per_square_nanometer),
                        "candelas per square micrometer" =>
                            Some(LuminanceUnit::candela_per_square_micrometer),
                        "candelas per square millimeter" =>
                            Some(LuminanceUnit::candela_per_square_millimeter),
                        "candelas per square centimeter" =>
                            Some(LuminanceUnit::candela_per_square_centimeter),
                        "candelas per square kilometer" =>
                            Some(LuminanceUnit::candela_per_square_kilometer),
                        "candelas per square megameter" =>
                            Some(LuminanceUnit::candela_per_square_megameter),
                        "candelas per square gigameter" =>
                            Some(LuminanceUnit::candela_per_square_gigameter),
                        "candelas per square terameter" =>
                            Some(LuminanceUnit::candela_per_square_terameter),
                        "candelas per square inch" =>
                            Some(LuminanceUnit::candela_per_square_inch),
                        "candelas per square foot" =>
                            Some(LuminanceUnit::candela_per_square_foot),
                        "footlamberts" => Some(LuminanceUnit::footlambert),
                        "lamberts" => Some(LuminanceUnit::lambert),
                        "stilbs" => Some(LuminanceUnit::stilb),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"Luminance\"")
                   }
            }
        }
        impl core::fmt::Display for LuminanceUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    LuminanceUnit::yottacandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "yottacandela per square meter")),
                    LuminanceUnit::zettacandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "zettacandela per square meter")),
                    LuminanceUnit::exacandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "exacandela per square meter")),
                    LuminanceUnit::petacandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "petacandela per square meter")),
                    LuminanceUnit::teracandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "teracandela per square meter")),
                    LuminanceUnit::gigacandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "gigacandela per square meter")),
                    LuminanceUnit::megacandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "megacandela per square meter")),
                    LuminanceUnit::kilocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "kilocandela per square meter")),
                    LuminanceUnit::hectocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "hectocandela per square meter")),
                    LuminanceUnit::decacandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "decacandela per square meter")),
                    LuminanceUnit::candela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square meter")),
                    LuminanceUnit::decicandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "decicandela per square meter")),
                    LuminanceUnit::centicandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "centicandela per square meter")),
                    LuminanceUnit::millicandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "millicandela per square meter")),
                    LuminanceUnit::microcandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "microcandela per square meter")),
                    LuminanceUnit::nanocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "nanocandela per square meter")),
                    LuminanceUnit::picocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "picocandela per square meter")),
                    LuminanceUnit::femtocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "femtocandela per square meter")),
                    LuminanceUnit::attocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "attocandela per square meter")),
                    LuminanceUnit::zeptocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "zeptocandela per square meter")),
                    LuminanceUnit::yoctocandela_per_square_meter =>
                        f.write_fmt(format_args!("{0}",
                                "yoctocandela per square meter")),
                    LuminanceUnit::candela_per_square_picometer =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square picometer")),
                    LuminanceUnit::candela_per_square_nanometer =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square nanometer")),
                    LuminanceUnit::candela_per_square_micrometer =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square micrometer")),
                    LuminanceUnit::candela_per_square_millimeter =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square millimeter")),
                    LuminanceUnit::candela_per_square_centimeter =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square centimeter")),
                    LuminanceUnit::candela_per_square_kilometer =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square kilometer")),
                    LuminanceUnit::candela_per_square_megameter =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square megameter")),
                    LuminanceUnit::candela_per_square_gigameter =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square gigameter")),
                    LuminanceUnit::candela_per_square_terameter =>
                        f.write_fmt(format_args!("{0}",
                                "candela per square terameter")),
                    LuminanceUnit::candela_per_square_inch =>
                        f.write_fmt(format_args!("{0}", "candela per square inch")),
                    LuminanceUnit::candela_per_square_foot =>
                        f.write_fmt(format_args!("{0}", "candela per square foot")),
                    LuminanceUnit::footlambert =>
                        f.write_fmt(format_args!("{0}", "footlambert")),
                    LuminanceUnit::lambert =>
                        f.write_fmt(format_args!("{0}", "lambert")),
                    LuminanceUnit::stilb =>
                        f.write_fmt(format_args!("{0}", "stilb")),
                }
            }
        }
    }
    #[cfg(any(feature = "Luminance", feature = "All"))]
    pub use crate::unit_definitions::luminance::LuminanceArray;
    #[cfg(any(feature = "Luminance", feature = "All"))]
    pub use crate::unit_definitions::luminance::Luminance;
    #[cfg(any(feature = "Luminance", feature = "All"))]
    pub use crate::unit_definitions::luminance::LuminanceVec;
    #[cfg(any(feature = "Mass", feature = "All"))]
    mod mass {
        //! Mass (base UnitDefinition kilogram, kg).
        use crate::{prefix, quantity};
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Mass (base UnitDefinition kilogram, kg)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "MassUnit")]
        pub enum MassUnit {
            yottagram,
            zettagram,
            exagram,
            petagram,
            teragram,
            gigagram,
            megagram,
            kilogram,
            hectogram,
            decagram,
            gram,
            decigram,
            centigram,
            milligram,
            microgram,
            nanogram,
            picogram,
            femtogram,
            attogram,
            zeptogram,
            yoctogram,
            carat,
            dalton,
            grain,
            hundredweight_long,
            hundredweight_short,
            ounce,
            ounce_troy,
            pennyweight,
            pound,
            pound_troy,
            slug,
            ton_assay,
            ton_long,
            ton_short,
            ton,
        }
        impl utoipa::__dev::ComposeSchema for MassUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 36usize],
                                &str>(Some(["yottagram", "zettagram", "exagram", "petagram",
                                            "teragram", "gigagram", "megagram", "kilogram", "hectogram",
                                            "decagram", "gram", "decigram", "centigram", "milligram",
                                            "microgram", "nanogram", "picogram", "femtogram",
                                            "attogram", "zeptogram", "yoctogram", "carat", "dalton",
                                            "grain", "hundredweight_long", "hundredweight_short",
                                            "ounce", "ounce_troy", "pennyweight", "pound", "pound_troy",
                                            "slug", "ton_assay", "ton_long", "ton_short",
                                            "ton"])).title(Some("MassUnit")).description(Some("Mass (base UnitDefinition kilogram, kg).")).into()
            }
        }
        impl utoipa::ToSchema for MassUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("MassUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for MassUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            MassUnit::yottagram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 0u32, "yottagram"),
                            MassUnit::zettagram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 1u32, "zettagram"),
                            MassUnit::exagram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 2u32, "exagram"),
                            MassUnit::petagram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 3u32, "petagram"),
                            MassUnit::teragram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 4u32, "teragram"),
                            MassUnit::gigagram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 5u32, "gigagram"),
                            MassUnit::megagram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 6u32, "megagram"),
                            MassUnit::kilogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 7u32, "kilogram"),
                            MassUnit::hectogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 8u32, "hectogram"),
                            MassUnit::decagram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 9u32, "decagram"),
                            MassUnit::gram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 10u32, "gram"),
                            MassUnit::decigram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 11u32, "decigram"),
                            MassUnit::centigram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 12u32, "centigram"),
                            MassUnit::milligram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 13u32, "milligram"),
                            MassUnit::microgram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 14u32, "microgram"),
                            MassUnit::nanogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 15u32, "nanogram"),
                            MassUnit::picogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 16u32, "picogram"),
                            MassUnit::femtogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 17u32, "femtogram"),
                            MassUnit::attogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 18u32, "attogram"),
                            MassUnit::zeptogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 19u32, "zeptogram"),
                            MassUnit::yoctogram =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 20u32, "yoctogram"),
                            MassUnit::carat =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 21u32, "carat"),
                            MassUnit::dalton =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 22u32, "dalton"),
                            MassUnit::grain =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 23u32, "grain"),
                            MassUnit::hundredweight_long =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 24u32, "hundredweight_long"),
                            MassUnit::hundredweight_short =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 25u32, "hundredweight_short"),
                            MassUnit::ounce =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 26u32, "ounce"),
                            MassUnit::ounce_troy =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 27u32, "ounce_troy"),
                            MassUnit::pennyweight =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 28u32, "pennyweight"),
                            MassUnit::pound =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 29u32, "pound"),
                            MassUnit::pound_troy =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 30u32, "pound_troy"),
                            MassUnit::slug =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 31u32, "slug"),
                            MassUnit::ton_assay =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 32u32, "ton_assay"),
                            MassUnit::ton_long =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 33u32, "ton_long"),
                            MassUnit::ton_short =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 34u32, "ton_short"),
                            MassUnit::ton =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "MassUnit", 35u32, "ton"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for MassUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                            __field24,
                            __field25,
                            __field26,
                            __field27,
                            __field28,
                            __field29,
                            __field30,
                            __field31,
                            __field32,
                            __field33,
                            __field34,
                            __field35,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    17u64 => _serde::__private::Ok(__Field::__field17),
                                    18u64 => _serde::__private::Ok(__Field::__field18),
                                    19u64 => _serde::__private::Ok(__Field::__field19),
                                    20u64 => _serde::__private::Ok(__Field::__field20),
                                    21u64 => _serde::__private::Ok(__Field::__field21),
                                    22u64 => _serde::__private::Ok(__Field::__field22),
                                    23u64 => _serde::__private::Ok(__Field::__field23),
                                    24u64 => _serde::__private::Ok(__Field::__field24),
                                    25u64 => _serde::__private::Ok(__Field::__field25),
                                    26u64 => _serde::__private::Ok(__Field::__field26),
                                    27u64 => _serde::__private::Ok(__Field::__field27),
                                    28u64 => _serde::__private::Ok(__Field::__field28),
                                    29u64 => _serde::__private::Ok(__Field::__field29),
                                    30u64 => _serde::__private::Ok(__Field::__field30),
                                    31u64 => _serde::__private::Ok(__Field::__field31),
                                    32u64 => _serde::__private::Ok(__Field::__field32),
                                    33u64 => _serde::__private::Ok(__Field::__field33),
                                    34u64 => _serde::__private::Ok(__Field::__field34),
                                    35u64 => _serde::__private::Ok(__Field::__field35),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 36")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "yottagram" => _serde::__private::Ok(__Field::__field0),
                                    "zettagram" => _serde::__private::Ok(__Field::__field1),
                                    "exagram" => _serde::__private::Ok(__Field::__field2),
                                    "petagram" => _serde::__private::Ok(__Field::__field3),
                                    "teragram" => _serde::__private::Ok(__Field::__field4),
                                    "gigagram" => _serde::__private::Ok(__Field::__field5),
                                    "megagram" => _serde::__private::Ok(__Field::__field6),
                                    "kilogram" => _serde::__private::Ok(__Field::__field7),
                                    "hectogram" => _serde::__private::Ok(__Field::__field8),
                                    "decagram" => _serde::__private::Ok(__Field::__field9),
                                    "gram" => _serde::__private::Ok(__Field::__field10),
                                    "decigram" => _serde::__private::Ok(__Field::__field11),
                                    "centigram" => _serde::__private::Ok(__Field::__field12),
                                    "milligram" => _serde::__private::Ok(__Field::__field13),
                                    "microgram" => _serde::__private::Ok(__Field::__field14),
                                    "nanogram" => _serde::__private::Ok(__Field::__field15),
                                    "picogram" => _serde::__private::Ok(__Field::__field16),
                                    "femtogram" => _serde::__private::Ok(__Field::__field17),
                                    "attogram" => _serde::__private::Ok(__Field::__field18),
                                    "zeptogram" => _serde::__private::Ok(__Field::__field19),
                                    "yoctogram" => _serde::__private::Ok(__Field::__field20),
                                    "carat" => _serde::__private::Ok(__Field::__field21),
                                    "dalton" => _serde::__private::Ok(__Field::__field22),
                                    "grain" => _serde::__private::Ok(__Field::__field23),
                                    "hundredweight_long" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    "hundredweight_short" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    "ounce" => _serde::__private::Ok(__Field::__field26),
                                    "ounce_troy" => _serde::__private::Ok(__Field::__field27),
                                    "pennyweight" => _serde::__private::Ok(__Field::__field28),
                                    "pound" => _serde::__private::Ok(__Field::__field29),
                                    "pound_troy" => _serde::__private::Ok(__Field::__field30),
                                    "slug" => _serde::__private::Ok(__Field::__field31),
                                    "ton_assay" => _serde::__private::Ok(__Field::__field32),
                                    "ton_long" => _serde::__private::Ok(__Field::__field33),
                                    "ton_short" => _serde::__private::Ok(__Field::__field34),
                                    "ton" => _serde::__private::Ok(__Field::__field35),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"yottagram" => _serde::__private::Ok(__Field::__field0),
                                    b"zettagram" => _serde::__private::Ok(__Field::__field1),
                                    b"exagram" => _serde::__private::Ok(__Field::__field2),
                                    b"petagram" => _serde::__private::Ok(__Field::__field3),
                                    b"teragram" => _serde::__private::Ok(__Field::__field4),
                                    b"gigagram" => _serde::__private::Ok(__Field::__field5),
                                    b"megagram" => _serde::__private::Ok(__Field::__field6),
                                    b"kilogram" => _serde::__private::Ok(__Field::__field7),
                                    b"hectogram" => _serde::__private::Ok(__Field::__field8),
                                    b"decagram" => _serde::__private::Ok(__Field::__field9),
                                    b"gram" => _serde::__private::Ok(__Field::__field10),
                                    b"decigram" => _serde::__private::Ok(__Field::__field11),
                                    b"centigram" => _serde::__private::Ok(__Field::__field12),
                                    b"milligram" => _serde::__private::Ok(__Field::__field13),
                                    b"microgram" => _serde::__private::Ok(__Field::__field14),
                                    b"nanogram" => _serde::__private::Ok(__Field::__field15),
                                    b"picogram" => _serde::__private::Ok(__Field::__field16),
                                    b"femtogram" => _serde::__private::Ok(__Field::__field17),
                                    b"attogram" => _serde::__private::Ok(__Field::__field18),
                                    b"zeptogram" => _serde::__private::Ok(__Field::__field19),
                                    b"yoctogram" => _serde::__private::Ok(__Field::__field20),
                                    b"carat" => _serde::__private::Ok(__Field::__field21),
                                    b"dalton" => _serde::__private::Ok(__Field::__field22),
                                    b"grain" => _serde::__private::Ok(__Field::__field23),
                                    b"hundredweight_long" =>
                                        _serde::__private::Ok(__Field::__field24),
                                    b"hundredweight_short" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    b"ounce" => _serde::__private::Ok(__Field::__field26),
                                    b"ounce_troy" => _serde::__private::Ok(__Field::__field27),
                                    b"pennyweight" => _serde::__private::Ok(__Field::__field28),
                                    b"pound" => _serde::__private::Ok(__Field::__field29),
                                    b"pound_troy" => _serde::__private::Ok(__Field::__field30),
                                    b"slug" => _serde::__private::Ok(__Field::__field31),
                                    b"ton_assay" => _serde::__private::Ok(__Field::__field32),
                                    b"ton_long" => _serde::__private::Ok(__Field::__field33),
                                    b"ton_short" => _serde::__private::Ok(__Field::__field34),
                                    b"ton" => _serde::__private::Ok(__Field::__field35),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<MassUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = MassUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum MassUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::yottagram)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::zettagram)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::exagram)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::petagram)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::teragram)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::gigagram)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::megagram)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::kilogram)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::hectogram)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::decagram)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::gram)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::decigram)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::centigram)
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::milligram)
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::microgram)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::nanogram)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::picogram)
                                    }
                                    (__Field::__field17, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::femtogram)
                                    }
                                    (__Field::__field18, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::attogram)
                                    }
                                    (__Field::__field19, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::zeptogram)
                                    }
                                    (__Field::__field20, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::yoctogram)
                                    }
                                    (__Field::__field21, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::carat)
                                    }
                                    (__Field::__field22, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::dalton)
                                    }
                                    (__Field::__field23, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::grain)
                                    }
                                    (__Field::__field24, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::hundredweight_long)
                                    }
                                    (__Field::__field25, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::hundredweight_short)
                                    }
                                    (__Field::__field26, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::ounce)
                                    }
                                    (__Field::__field27, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::ounce_troy)
                                    }
                                    (__Field::__field28, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::pennyweight)
                                    }
                                    (__Field::__field29, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::pound)
                                    }
                                    (__Field::__field30, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::pound_troy)
                                    }
                                    (__Field::__field31, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::slug)
                                    }
                                    (__Field::__field32, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::ton_assay)
                                    }
                                    (__Field::__field33, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::ton_long)
                                    }
                                    (__Field::__field34, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::ton_short)
                                    }
                                    (__Field::__field35, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(MassUnit::ton)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["yottagram", "zettagram", "exagram", "petagram",
                                        "teragram", "gigagram", "megagram", "kilogram", "hectogram",
                                        "decagram", "gram", "decigram", "centigram", "milligram",
                                        "microgram", "nanogram", "picogram", "femtogram",
                                        "attogram", "zeptogram", "yoctogram", "carat", "dalton",
                                        "grain", "hundredweight_long", "hundredweight_short",
                                        "ounce", "ounce_troy", "pennyweight", "pound", "pound_troy",
                                        "slug", "ton_assay", "ton_long", "ton_short", "ton"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "MassUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<MassUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for MassUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for MassUnit {
            #[inline]
            fn clone(&self) -> MassUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for MassUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        MassUnit::yottagram => "yottagram",
                        MassUnit::zettagram => "zettagram",
                        MassUnit::exagram => "exagram",
                        MassUnit::petagram => "petagram",
                        MassUnit::teragram => "teragram",
                        MassUnit::gigagram => "gigagram",
                        MassUnit::megagram => "megagram",
                        MassUnit::kilogram => "kilogram",
                        MassUnit::hectogram => "hectogram",
                        MassUnit::decagram => "decagram",
                        MassUnit::gram => "gram",
                        MassUnit::decigram => "decigram",
                        MassUnit::centigram => "centigram",
                        MassUnit::milligram => "milligram",
                        MassUnit::microgram => "microgram",
                        MassUnit::nanogram => "nanogram",
                        MassUnit::picogram => "picogram",
                        MassUnit::femtogram => "femtogram",
                        MassUnit::attogram => "attogram",
                        MassUnit::zeptogram => "zeptogram",
                        MassUnit::yoctogram => "yoctogram",
                        MassUnit::carat => "carat",
                        MassUnit::dalton => "dalton",
                        MassUnit::grain => "grain",
                        MassUnit::hundredweight_long => "hundredweight_long",
                        MassUnit::hundredweight_short => "hundredweight_short",
                        MassUnit::ounce => "ounce",
                        MassUnit::ounce_troy => "ounce_troy",
                        MassUnit::pennyweight => "pennyweight",
                        MassUnit::pound => "pound",
                        MassUnit::pound_troy => "pound_troy",
                        MassUnit::slug => "slug",
                        MassUnit::ton_assay => "ton_assay",
                        MassUnit::ton_long => "ton_long",
                        MassUnit::ton_short => "ton_short",
                        MassUnit::ton => "ton",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for MassUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for MassUnit {
            #[inline]
            fn eq(&self, other: &MassUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for MassUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for MassUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const MASS_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::P1,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const MASS_YOTTAGRAM_CONVERSION: f64 = 1.0_E24 / 1.0_E3;
        pub(crate) const MASS_ZETTAGRAM_CONVERSION: f64 = 1.0_E21 / 1.0_E3;
        pub(crate) const MASS_EXAGRAM_CONVERSION: f64 = 1.0_E18 / 1.0_E3;
        pub(crate) const MASS_PETAGRAM_CONVERSION: f64 = 1.0_E15 / 1.0_E3;
        pub(crate) const MASS_TERAGRAM_CONVERSION: f64 = 1.0_E12 / 1.0_E3;
        pub(crate) const MASS_GIGAGRAM_CONVERSION: f64 = 1.0_E9 / 1.0_E3;
        pub(crate) const MASS_MEGAGRAM_CONVERSION: f64 = 1.0_E6 / 1.0_E3;
        pub(crate) const MASS_KILOGRAM_CONVERSION: f64 = 1.0_E3 / 1.0_E3;
        pub(crate) const MASS_HECTOGRAM_CONVERSION: f64 = 1.0_E2 / 1.0_E3;
        pub(crate) const MASS_DECAGRAM_CONVERSION: f64 = 1.0_E1 / 1.0_E3;
        pub(crate) const MASS_GRAM_CONVERSION: f64 = 1.0_E0 / 1.0_E3;
        pub(crate) const MASS_DECIGRAM_CONVERSION: f64 = 1.0_E-1 / 1.0_E3;
        pub(crate) const MASS_CENTIGRAM_CONVERSION: f64 = 1.0_E-2 / 1.0_E3;
        pub(crate) const MASS_MILLIGRAM_CONVERSION: f64 = 1.0_E-3 / 1.0_E3;
        pub(crate) const MASS_MICROGRAM_CONVERSION: f64 = 1.0_E-6 / 1.0_E3;
        pub(crate) const MASS_NANOGRAM_CONVERSION: f64 = 1.0_E-9 / 1.0_E3;
        pub(crate) const MASS_PICOGRAM_CONVERSION: f64 = 1.0_E-12 / 1.0_E3;
        pub(crate) const MASS_FEMTOGRAM_CONVERSION: f64 = 1.0_E-15 / 1.0_E3;
        pub(crate) const MASS_ATTOGRAM_CONVERSION: f64 = 1.0_E-18 / 1.0_E3;
        pub(crate) const MASS_ZEPTOGRAM_CONVERSION: f64 = 1.0_E-21 / 1.0_E3;
        pub(crate) const MASS_YOCTOGRAM_CONVERSION: f64 = 1.0_E-24 / 1.0_E3;
        pub(crate) const MASS_CARAT_CONVERSION: f64 = 2.0_E-4;
        pub(crate) const MASS_DALTON_CONVERSION: f64 = 1.660_539_066_60_E-27;
        pub(crate) const MASS_GRAIN_CONVERSION: f64 = 6.479_891_E-5;
        pub(crate) const MASS_HUNDREDWEIGHT_LONG_CONVERSION: f64 =
            5.080_235_E1;
        pub(crate) const MASS_HUNDREDWEIGHT_SHORT_CONVERSION: f64 =
            4.535_924_E1;
        pub(crate) const MASS_OUNCE_CONVERSION: f64 = 2.834_952_E-2;
        pub(crate) const MASS_OUNCE_TROY_CONVERSION: f64 = 3.110_348_E-2;
        pub(crate) const MASS_PENNYWEIGHT_CONVERSION: f64 = 1.555_174_E-3;
        pub(crate) const MASS_POUND_CONVERSION: f64 = 4.535_924_E-1;
        pub(crate) const MASS_POUND_TROY_CONVERSION: f64 = 3.732_417_E-1;
        pub(crate) const MASS_SLUG_CONVERSION: f64 = 1.459_390_E1;
        pub(crate) const MASS_TON_ASSAY_CONVERSION: f64 = 2.916_667_E-2;
        pub(crate) const MASS_TON_LONG_CONVERSION: f64 = 1.016_047_E3;
        pub(crate) const MASS_TON_SHORT_CONVERSION: f64 = 9.071_847_E2;
        pub(crate) const MASS_TON_CONVERSION: f64 = 1.0_E3;
        impl MassUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_yottagram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_YOTTAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zettagram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_ZETTAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_exagram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_EXAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_petagram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_PETAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_teragram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_TERAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gigagram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_GIGAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_megagram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_MEGAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kilogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_KILOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hectogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_HECTOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decagram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_DECAGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_GRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decigram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_DECIGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_centigram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_CENTIGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_milligram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_MILLIGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_microgram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_MICROGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nanogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_NANOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_picogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_PICOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_femtogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_FEMTOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_attogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_ATTOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zeptogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_ZEPTOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yoctogram() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_YOCTOGRAM_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_carat() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_CARAT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_dalton() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_DALTON_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_grain() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_GRAIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hundredweight_long() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_HUNDREDWEIGHT_LONG_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hundredweight_short() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_HUNDREDWEIGHT_SHORT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_ounce() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_OUNCE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_ounce_troy() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_OUNCE_TROY_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_pennyweight() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_PENNYWEIGHT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_pound() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_POUND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_pound_troy() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_POUND_TROY_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_slug() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_SLUG_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_ton_assay() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_TON_ASSAY_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_ton_long() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_TON_LONG_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_ton_short() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_TON_SHORT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_ton() -> UnitDefinition {
                UnitDefinition {
                    base: MASS_UNIT_BASE,
                    multiplier: MASS_TON_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    MassUnit::yottagram => MASS_YOTTAGRAM_CONVERSION,
                    MassUnit::zettagram => MASS_ZETTAGRAM_CONVERSION,
                    MassUnit::exagram => MASS_EXAGRAM_CONVERSION,
                    MassUnit::petagram => MASS_PETAGRAM_CONVERSION,
                    MassUnit::teragram => MASS_TERAGRAM_CONVERSION,
                    MassUnit::gigagram => MASS_GIGAGRAM_CONVERSION,
                    MassUnit::megagram => MASS_MEGAGRAM_CONVERSION,
                    MassUnit::kilogram => MASS_KILOGRAM_CONVERSION,
                    MassUnit::hectogram => MASS_HECTOGRAM_CONVERSION,
                    MassUnit::decagram => MASS_DECAGRAM_CONVERSION,
                    MassUnit::gram => MASS_GRAM_CONVERSION,
                    MassUnit::decigram => MASS_DECIGRAM_CONVERSION,
                    MassUnit::centigram => MASS_CENTIGRAM_CONVERSION,
                    MassUnit::milligram => MASS_MILLIGRAM_CONVERSION,
                    MassUnit::microgram => MASS_MICROGRAM_CONVERSION,
                    MassUnit::nanogram => MASS_NANOGRAM_CONVERSION,
                    MassUnit::picogram => MASS_PICOGRAM_CONVERSION,
                    MassUnit::femtogram => MASS_FEMTOGRAM_CONVERSION,
                    MassUnit::attogram => MASS_ATTOGRAM_CONVERSION,
                    MassUnit::zeptogram => MASS_ZEPTOGRAM_CONVERSION,
                    MassUnit::yoctogram => MASS_YOCTOGRAM_CONVERSION,
                    MassUnit::carat => MASS_CARAT_CONVERSION,
                    MassUnit::dalton => MASS_DALTON_CONVERSION,
                    MassUnit::grain => MASS_GRAIN_CONVERSION,
                    MassUnit::hundredweight_long =>
                        MASS_HUNDREDWEIGHT_LONG_CONVERSION,
                    MassUnit::hundredweight_short =>
                        MASS_HUNDREDWEIGHT_SHORT_CONVERSION,
                    MassUnit::ounce => MASS_OUNCE_CONVERSION,
                    MassUnit::ounce_troy => MASS_OUNCE_TROY_CONVERSION,
                    MassUnit::pennyweight => MASS_PENNYWEIGHT_CONVERSION,
                    MassUnit::pound => MASS_POUND_CONVERSION,
                    MassUnit::pound_troy => MASS_POUND_TROY_CONVERSION,
                    MassUnit::slug => MASS_SLUG_CONVERSION,
                    MassUnit::ton_assay => MASS_TON_ASSAY_CONVERSION,
                    MassUnit::ton_long => MASS_TON_LONG_CONVERSION,
                    MassUnit::ton_short => MASS_TON_SHORT_CONVERSION,
                    MassUnit::ton => MASS_TON_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    MassUnit::yottagram => "Yg",
                    MassUnit::zettagram => "Zg",
                    MassUnit::exagram => "Eg",
                    MassUnit::petagram => "Pg",
                    MassUnit::teragram => "Tg",
                    MassUnit::gigagram => "Gg",
                    MassUnit::megagram => "Mg",
                    MassUnit::kilogram => "kg",
                    MassUnit::hectogram => "hg",
                    MassUnit::decagram => "dag",
                    MassUnit::gram => "g",
                    MassUnit::decigram => "dg",
                    MassUnit::centigram => "cg",
                    MassUnit::milligram => "mg",
                    MassUnit::microgram => "g",
                    MassUnit::nanogram => "ng",
                    MassUnit::picogram => "pg",
                    MassUnit::femtogram => "fg",
                    MassUnit::attogram => "ag",
                    MassUnit::zeptogram => "zg",
                    MassUnit::yoctogram => "yg",
                    MassUnit::carat => "ct",
                    MassUnit::dalton => "Da",
                    MassUnit::grain => "gr",
                    MassUnit::hundredweight_long => "cwt long",
                    MassUnit::hundredweight_short => "cwt short",
                    MassUnit::ounce => "oz",
                    MassUnit::ounce_troy => "oz t",
                    MassUnit::pennyweight => "dwt",
                    MassUnit::pound => "lb",
                    MassUnit::pound_troy => "lb t",
                    MassUnit::slug => "slug",
                    MassUnit::ton_assay => "AT",
                    MassUnit::ton_long => "2240 lb",
                    MassUnit::ton_short => "2000 lb",
                    MassUnit::ton => "t",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    MassUnit::yottagram => "yottagram",
                    MassUnit::zettagram => "zettagram",
                    MassUnit::exagram => "exagram",
                    MassUnit::petagram => "petagram",
                    MassUnit::teragram => "teragram",
                    MassUnit::gigagram => "gigagram",
                    MassUnit::megagram => "megagram",
                    MassUnit::kilogram => "kilogram",
                    MassUnit::hectogram => "hectogram",
                    MassUnit::decagram => "decagram",
                    MassUnit::gram => "gram",
                    MassUnit::decigram => "decigram",
                    MassUnit::centigram => "centigram",
                    MassUnit::milligram => "milligram",
                    MassUnit::microgram => "microgram",
                    MassUnit::nanogram => "nanogram",
                    MassUnit::picogram => "picogram",
                    MassUnit::femtogram => "femtogram",
                    MassUnit::attogram => "attogram",
                    MassUnit::zeptogram => "zeptogram",
                    MassUnit::yoctogram => "yoctogram",
                    MassUnit::carat => "carat",
                    MassUnit::dalton => "dalton",
                    MassUnit::grain => "grain",
                    MassUnit::hundredweight_long => "hundredweight (long)",
                    MassUnit::hundredweight_short => "hundredweight (short)",
                    MassUnit::ounce => "ounce",
                    MassUnit::ounce_troy => "troy ounce",
                    MassUnit::pennyweight => "pennyweight",
                    MassUnit::pound => "pound",
                    MassUnit::pound_troy => "troy pound",
                    MassUnit::slug => "slug",
                    MassUnit::ton_assay => "assay ton",
                    MassUnit::ton_long => "long ton",
                    MassUnit::ton_short => "short ton",
                    MassUnit::ton => "ton",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    MassUnit::yottagram => "yottagrams",
                    MassUnit::zettagram => "zettagrams",
                    MassUnit::exagram => "exagrams",
                    MassUnit::petagram => "petagrams",
                    MassUnit::teragram => "teragrams",
                    MassUnit::gigagram => "gigagrams",
                    MassUnit::megagram => "megagrams",
                    MassUnit::kilogram => "kilograms",
                    MassUnit::hectogram => "hectograms",
                    MassUnit::decagram => "decagrams",
                    MassUnit::gram => "grams",
                    MassUnit::decigram => "decigrams",
                    MassUnit::centigram => "centigrams",
                    MassUnit::milligram => "milligrams",
                    MassUnit::microgram => "micrograms",
                    MassUnit::nanogram => "nanograms",
                    MassUnit::picogram => "picograms",
                    MassUnit::femtogram => "femtograms",
                    MassUnit::attogram => "attograms",
                    MassUnit::zeptogram => "zeptograms",
                    MassUnit::yoctogram => "yoctograms",
                    MassUnit::carat => "carats",
                    MassUnit::dalton => "daltons",
                    MassUnit::grain => "grains",
                    MassUnit::hundredweight_long => "hundredweight (long)",
                    MassUnit::hundredweight_short => "hundredweight (short)",
                    MassUnit::ounce => "ounces",
                    MassUnit::ounce_troy => "troy ounces",
                    MassUnit::pennyweight => "pennyweight",
                    MassUnit::pound => "pounds",
                    MassUnit::pound_troy => "troy pounds",
                    MassUnit::slug => "slugs",
                    MassUnit::ton_assay => "assay tons",
                    MassUnit::ton_long => "long tons",
                    MassUnit::ton_short => "short tons",
                    MassUnit::ton => "tons",
                }
            }
            #[doc = "Available units for this `[MassUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["yottagram", "zettagram", "exagram", "petagram",
                                "teragram", "gigagram", "megagram", "kilogram", "hectogram",
                                "decagram", "gram", "decigram", "centigram", "milligram",
                                "microgram", "nanogram", "picogram", "femtogram",
                                "attogram", "zeptogram", "yoctogram", "carat", "dalton",
                                "grain", "hundredweight (long)", "hundredweight (short)",
                                "ounce", "troy ounce", "pennyweight", "pound", "troy pound",
                                "slug", "assay ton", "long ton", "short ton", "ton"];
                UNITS
            }
        }
        impl crate::traits::Unit for MassUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    MassUnit::yottagram => MassUnit::get_yottagram(),
                    MassUnit::zettagram => MassUnit::get_zettagram(),
                    MassUnit::exagram => MassUnit::get_exagram(),
                    MassUnit::petagram => MassUnit::get_petagram(),
                    MassUnit::teragram => MassUnit::get_teragram(),
                    MassUnit::gigagram => MassUnit::get_gigagram(),
                    MassUnit::megagram => MassUnit::get_megagram(),
                    MassUnit::kilogram => MassUnit::get_kilogram(),
                    MassUnit::hectogram => MassUnit::get_hectogram(),
                    MassUnit::decagram => MassUnit::get_decagram(),
                    MassUnit::gram => MassUnit::get_gram(),
                    MassUnit::decigram => MassUnit::get_decigram(),
                    MassUnit::centigram => MassUnit::get_centigram(),
                    MassUnit::milligram => MassUnit::get_milligram(),
                    MassUnit::microgram => MassUnit::get_microgram(),
                    MassUnit::nanogram => MassUnit::get_nanogram(),
                    MassUnit::picogram => MassUnit::get_picogram(),
                    MassUnit::femtogram => MassUnit::get_femtogram(),
                    MassUnit::attogram => MassUnit::get_attogram(),
                    MassUnit::zeptogram => MassUnit::get_zeptogram(),
                    MassUnit::yoctogram => MassUnit::get_yoctogram(),
                    MassUnit::carat => MassUnit::get_carat(),
                    MassUnit::dalton => MassUnit::get_dalton(),
                    MassUnit::grain => MassUnit::get_grain(),
                    MassUnit::hundredweight_long =>
                        MassUnit::get_hundredweight_long(),
                    MassUnit::hundredweight_short =>
                        MassUnit::get_hundredweight_short(),
                    MassUnit::ounce => MassUnit::get_ounce(),
                    MassUnit::ounce_troy => MassUnit::get_ounce_troy(),
                    MassUnit::pennyweight => MassUnit::get_pennyweight(),
                    MassUnit::pound => MassUnit::get_pound(),
                    MassUnit::pound_troy => MassUnit::get_pound_troy(),
                    MassUnit::slug => MassUnit::get_slug(),
                    MassUnit::ton_assay => MassUnit::get_ton_assay(),
                    MassUnit::ton_long => MassUnit::get_ton_long(),
                    MassUnit::ton_short => MassUnit::get_ton_short(),
                    MassUnit::ton => MassUnit::get_ton(),
                }
            }
            #[inline]
            fn base() -> UnitBase { MASS_UNIT_BASE }
        }
        impl From<MassUnit> for crate::Units {
            fn from(value: MassUnit) -> Self {
                match value {
                    MassUnit::yottagram =>
                        crate::Units::Mass(MassUnit::yottagram),
                    MassUnit::zettagram =>
                        crate::Units::Mass(MassUnit::zettagram),
                    MassUnit::exagram => crate::Units::Mass(MassUnit::exagram),
                    MassUnit::petagram =>
                        crate::Units::Mass(MassUnit::petagram),
                    MassUnit::teragram =>
                        crate::Units::Mass(MassUnit::teragram),
                    MassUnit::gigagram =>
                        crate::Units::Mass(MassUnit::gigagram),
                    MassUnit::megagram =>
                        crate::Units::Mass(MassUnit::megagram),
                    MassUnit::kilogram =>
                        crate::Units::Mass(MassUnit::kilogram),
                    MassUnit::hectogram =>
                        crate::Units::Mass(MassUnit::hectogram),
                    MassUnit::decagram =>
                        crate::Units::Mass(MassUnit::decagram),
                    MassUnit::gram => crate::Units::Mass(MassUnit::gram),
                    MassUnit::decigram =>
                        crate::Units::Mass(MassUnit::decigram),
                    MassUnit::centigram =>
                        crate::Units::Mass(MassUnit::centigram),
                    MassUnit::milligram =>
                        crate::Units::Mass(MassUnit::milligram),
                    MassUnit::microgram =>
                        crate::Units::Mass(MassUnit::microgram),
                    MassUnit::nanogram =>
                        crate::Units::Mass(MassUnit::nanogram),
                    MassUnit::picogram =>
                        crate::Units::Mass(MassUnit::picogram),
                    MassUnit::femtogram =>
                        crate::Units::Mass(MassUnit::femtogram),
                    MassUnit::attogram =>
                        crate::Units::Mass(MassUnit::attogram),
                    MassUnit::zeptogram =>
                        crate::Units::Mass(MassUnit::zeptogram),
                    MassUnit::yoctogram =>
                        crate::Units::Mass(MassUnit::yoctogram),
                    MassUnit::carat => crate::Units::Mass(MassUnit::carat),
                    MassUnit::dalton => crate::Units::Mass(MassUnit::dalton),
                    MassUnit::grain => crate::Units::Mass(MassUnit::grain),
                    MassUnit::hundredweight_long =>
                        crate::Units::Mass(MassUnit::hundredweight_long),
                    MassUnit::hundredweight_short =>
                        crate::Units::Mass(MassUnit::hundredweight_short),
                    MassUnit::ounce => crate::Units::Mass(MassUnit::ounce),
                    MassUnit::ounce_troy =>
                        crate::Units::Mass(MassUnit::ounce_troy),
                    MassUnit::pennyweight =>
                        crate::Units::Mass(MassUnit::pennyweight),
                    MassUnit::pound => crate::Units::Mass(MassUnit::pound),
                    MassUnit::pound_troy =>
                        crate::Units::Mass(MassUnit::pound_troy),
                    MassUnit::slug => crate::Units::Mass(MassUnit::slug),
                    MassUnit::ton_assay =>
                        crate::Units::Mass(MassUnit::ton_assay),
                    MassUnit::ton_long =>
                        crate::Units::Mass(MassUnit::ton_long),
                    MassUnit::ton_short =>
                        crate::Units::Mass(MassUnit::ton_short),
                    MassUnit::ton => crate::Units::Mass(MassUnit::ton),
                }
            }
        }
        impl TryFrom<UnitDefinition> for MassUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_YOTTAGRAM_CONVERSION
                        } => Ok(MassUnit::yottagram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_ZETTAGRAM_CONVERSION
                        } => Ok(MassUnit::zettagram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_EXAGRAM_CONVERSION }
                        => Ok(MassUnit::exagram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_PETAGRAM_CONVERSION }
                        => Ok(MassUnit::petagram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_TERAGRAM_CONVERSION }
                        => Ok(MassUnit::teragram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_GIGAGRAM_CONVERSION }
                        => Ok(MassUnit::gigagram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_MEGAGRAM_CONVERSION }
                        => Ok(MassUnit::megagram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_KILOGRAM_CONVERSION }
                        => Ok(MassUnit::kilogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_HECTOGRAM_CONVERSION
                        } => Ok(MassUnit::hectogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_DECAGRAM_CONVERSION }
                        => Ok(MassUnit::decagram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_GRAM_CONVERSION } =>
                        Ok(MassUnit::gram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_DECIGRAM_CONVERSION }
                        => Ok(MassUnit::decigram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_CENTIGRAM_CONVERSION
                        } => Ok(MassUnit::centigram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_MILLIGRAM_CONVERSION
                        } => Ok(MassUnit::milligram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_MICROGRAM_CONVERSION
                        } => Ok(MassUnit::microgram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_NANOGRAM_CONVERSION }
                        => Ok(MassUnit::nanogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_PICOGRAM_CONVERSION }
                        => Ok(MassUnit::picogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_FEMTOGRAM_CONVERSION
                        } => Ok(MassUnit::femtogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_ATTOGRAM_CONVERSION }
                        => Ok(MassUnit::attogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_ZEPTOGRAM_CONVERSION
                        } => Ok(MassUnit::zeptogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_YOCTOGRAM_CONVERSION
                        } => Ok(MassUnit::yoctogram),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_CARAT_CONVERSION } =>
                        Ok(MassUnit::carat),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_DALTON_CONVERSION }
                        => Ok(MassUnit::dalton),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_GRAIN_CONVERSION } =>
                        Ok(MassUnit::grain),
                    UnitDefinition {
                        base: MASS_UNIT_BASE,
                        multiplier: MASS_HUNDREDWEIGHT_LONG_CONVERSION } =>
                        Ok(MassUnit::hundredweight_long),
                    UnitDefinition {
                        base: MASS_UNIT_BASE,
                        multiplier: MASS_HUNDREDWEIGHT_SHORT_CONVERSION } =>
                        Ok(MassUnit::hundredweight_short),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_OUNCE_CONVERSION } =>
                        Ok(MassUnit::ounce),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_OUNCE_TROY_CONVERSION
                        } => Ok(MassUnit::ounce_troy),
                    UnitDefinition {
                        base: MASS_UNIT_BASE,
                        multiplier: MASS_PENNYWEIGHT_CONVERSION } =>
                        Ok(MassUnit::pennyweight),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_POUND_CONVERSION } =>
                        Ok(MassUnit::pound),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_POUND_TROY_CONVERSION
                        } => Ok(MassUnit::pound_troy),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_SLUG_CONVERSION } =>
                        Ok(MassUnit::slug),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_TON_ASSAY_CONVERSION
                        } => Ok(MassUnit::ton_assay),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_TON_LONG_CONVERSION }
                        => Ok(MassUnit::ton_long),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_TON_SHORT_CONVERSION
                        } => Ok(MassUnit::ton_short),
                    UnitDefinition {
                        base: MASS_UNIT_BASE, multiplier: MASS_TON_CONVERSION } =>
                        Ok(MassUnit::ton),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "Mass"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for MassUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::Mass(MassUnit::yottagram) =>
                        Ok(MassUnit::yottagram),
                    crate::Units::Mass(MassUnit::zettagram) =>
                        Ok(MassUnit::zettagram),
                    crate::Units::Mass(MassUnit::exagram) =>
                        Ok(MassUnit::exagram),
                    crate::Units::Mass(MassUnit::petagram) =>
                        Ok(MassUnit::petagram),
                    crate::Units::Mass(MassUnit::teragram) =>
                        Ok(MassUnit::teragram),
                    crate::Units::Mass(MassUnit::gigagram) =>
                        Ok(MassUnit::gigagram),
                    crate::Units::Mass(MassUnit::megagram) =>
                        Ok(MassUnit::megagram),
                    crate::Units::Mass(MassUnit::kilogram) =>
                        Ok(MassUnit::kilogram),
                    crate::Units::Mass(MassUnit::hectogram) =>
                        Ok(MassUnit::hectogram),
                    crate::Units::Mass(MassUnit::decagram) =>
                        Ok(MassUnit::decagram),
                    crate::Units::Mass(MassUnit::gram) => Ok(MassUnit::gram),
                    crate::Units::Mass(MassUnit::decigram) =>
                        Ok(MassUnit::decigram),
                    crate::Units::Mass(MassUnit::centigram) =>
                        Ok(MassUnit::centigram),
                    crate::Units::Mass(MassUnit::milligram) =>
                        Ok(MassUnit::milligram),
                    crate::Units::Mass(MassUnit::microgram) =>
                        Ok(MassUnit::microgram),
                    crate::Units::Mass(MassUnit::nanogram) =>
                        Ok(MassUnit::nanogram),
                    crate::Units::Mass(MassUnit::picogram) =>
                        Ok(MassUnit::picogram),
                    crate::Units::Mass(MassUnit::femtogram) =>
                        Ok(MassUnit::femtogram),
                    crate::Units::Mass(MassUnit::attogram) =>
                        Ok(MassUnit::attogram),
                    crate::Units::Mass(MassUnit::zeptogram) =>
                        Ok(MassUnit::zeptogram),
                    crate::Units::Mass(MassUnit::yoctogram) =>
                        Ok(MassUnit::yoctogram),
                    crate::Units::Mass(MassUnit::carat) => Ok(MassUnit::carat),
                    crate::Units::Mass(MassUnit::dalton) =>
                        Ok(MassUnit::dalton),
                    crate::Units::Mass(MassUnit::grain) => Ok(MassUnit::grain),
                    crate::Units::Mass(MassUnit::hundredweight_long) =>
                        Ok(MassUnit::hundredweight_long),
                    crate::Units::Mass(MassUnit::hundredweight_short) =>
                        Ok(MassUnit::hundredweight_short),
                    crate::Units::Mass(MassUnit::ounce) => Ok(MassUnit::ounce),
                    crate::Units::Mass(MassUnit::ounce_troy) =>
                        Ok(MassUnit::ounce_troy),
                    crate::Units::Mass(MassUnit::pennyweight) =>
                        Ok(MassUnit::pennyweight),
                    crate::Units::Mass(MassUnit::pound) => Ok(MassUnit::pound),
                    crate::Units::Mass(MassUnit::pound_troy) =>
                        Ok(MassUnit::pound_troy),
                    crate::Units::Mass(MassUnit::slug) => Ok(MassUnit::slug),
                    crate::Units::Mass(MassUnit::ton_assay) =>
                        Ok(MassUnit::ton_assay),
                    crate::Units::Mass(MassUnit::ton_long) =>
                        Ok(MassUnit::ton_long),
                    crate::Units::Mass(MassUnit::ton_short) =>
                        Ok(MassUnit::ton_short),
                    crate::Units::Mass(MassUnit::ton) => Ok(MassUnit::ton),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "Mass"));
                                        res
                                    }))),
                }
            }
        }
        impl From<Mass> for crate::Units {
            fn from(value: Mass) -> Self { crate::Units::Mass(value.unit) }
        }
        impl From<&Mass> for crate::Units {
            fn from(value: &Mass) -> Self { crate::Units::Mass(value.unit) }
        }
        impl From<MassVec> for crate::Units {
            fn from(value: MassVec) -> Self { crate::Units::Mass(value.unit) }
        }
        impl From<&MassVec> for crate::Units {
            fn from(value: &MassVec) -> Self {
                crate::Units::Mass(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Mass (base UnitDefinition kilogram, kg)."]
        #[schema(title = "Mass")]
        #[doc = "Scalar storage of a quantity (f64 and [`MassUnit`])."]
        pub struct Mass {
            pub(crate) value: f64,
            pub(crate) unit: MassUnit,
        }
        impl utoipa::__dev::ComposeSchema for Mass {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <MassUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("Mass")).description(Some(" Mass (base UnitDefinition kilogram, kg).\nScalar storage of a quantity (f64 and [`MassUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for Mass {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("Mass")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <MassUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <MassUnit as utoipa::PartialSchema>::schema())]);
                <MassUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Mass {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer, "Mass",
                                    false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Mass {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Mass>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Mass;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct Mass")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct Mass with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<MassUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct Mass with 2 elements")),
                                    };
                                _serde::__private::Ok(Mass {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<MassUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<MassUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(Mass {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "Mass", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Mass>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for Mass { }
        #[automatically_derived]
        impl ::core::clone::Clone for Mass {
            #[inline]
            fn clone(&self) -> Mass {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _: ::core::clone::AssertParamIsClone<MassUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Mass {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f, "Mass",
                    "value", &self.value, "unit", &&self.unit)
            }
        }
        impl Mass {
            #[doc = "Create a new [`MassUnit`]."]
            pub fn new(value: f64, unit: MassUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::yottagram`]."]
            pub fn yottagram(value: f64) -> Self {
                Self { value, unit: MassUnit::yottagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::zettagram`]."]
            pub fn zettagram(value: f64) -> Self {
                Self { value, unit: MassUnit::zettagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::exagram`]."]
            pub fn exagram(value: f64) -> Self {
                Self { value, unit: MassUnit::exagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::petagram`]."]
            pub fn petagram(value: f64) -> Self {
                Self { value, unit: MassUnit::petagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::teragram`]."]
            pub fn teragram(value: f64) -> Self {
                Self { value, unit: MassUnit::teragram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::gigagram`]."]
            pub fn gigagram(value: f64) -> Self {
                Self { value, unit: MassUnit::gigagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::megagram`]."]
            pub fn megagram(value: f64) -> Self {
                Self { value, unit: MassUnit::megagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::kilogram`]."]
            pub fn kilogram(value: f64) -> Self {
                Self { value, unit: MassUnit::kilogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::hectogram`]."]
            pub fn hectogram(value: f64) -> Self {
                Self { value, unit: MassUnit::hectogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::decagram`]."]
            pub fn decagram(value: f64) -> Self {
                Self { value, unit: MassUnit::decagram.into() }
            }
            #[doc = "Create a new [`Mass`] with units of [`MassUnit::gram`]."]
            pub fn gram(value: f64) -> Self {
                Self { value, unit: MassUnit::gram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::decigram`]."]
            pub fn decigram(value: f64) -> Self {
                Self { value, unit: MassUnit::decigram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::centigram`]."]
            pub fn centigram(value: f64) -> Self {
                Self { value, unit: MassUnit::centigram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::milligram`]."]
            pub fn milligram(value: f64) -> Self {
                Self { value, unit: MassUnit::milligram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::microgram`]."]
            pub fn microgram(value: f64) -> Self {
                Self { value, unit: MassUnit::microgram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::nanogram`]."]
            pub fn nanogram(value: f64) -> Self {
                Self { value, unit: MassUnit::nanogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::picogram`]."]
            pub fn picogram(value: f64) -> Self {
                Self { value, unit: MassUnit::picogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::femtogram`]."]
            pub fn femtogram(value: f64) -> Self {
                Self { value, unit: MassUnit::femtogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::attogram`]."]
            pub fn attogram(value: f64) -> Self {
                Self { value, unit: MassUnit::attogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::zeptogram`]."]
            pub fn zeptogram(value: f64) -> Self {
                Self { value, unit: MassUnit::zeptogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::yoctogram`]."]
            pub fn yoctogram(value: f64) -> Self {
                Self { value, unit: MassUnit::yoctogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::carat`]."]
            pub fn carat(value: f64) -> Self {
                Self { value, unit: MassUnit::carat.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::dalton`]."]
            pub fn dalton(value: f64) -> Self {
                Self { value, unit: MassUnit::dalton.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::grain`]."]
            pub fn grain(value: f64) -> Self {
                Self { value, unit: MassUnit::grain.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::hundredweight_long`]."]
            pub fn hundredweight_long(value: f64) -> Self {
                Self { value, unit: MassUnit::hundredweight_long.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::hundredweight_short`]."]
            pub fn hundredweight_short(value: f64) -> Self {
                Self { value, unit: MassUnit::hundredweight_short.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ounce`]."]
            pub fn ounce(value: f64) -> Self {
                Self { value, unit: MassUnit::ounce.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ounce_troy`]."]
            pub fn ounce_troy(value: f64) -> Self {
                Self { value, unit: MassUnit::ounce_troy.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::pennyweight`]."]
            pub fn pennyweight(value: f64) -> Self {
                Self { value, unit: MassUnit::pennyweight.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::pound`]."]
            pub fn pound(value: f64) -> Self {
                Self { value, unit: MassUnit::pound.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::pound_troy`]."]
            pub fn pound_troy(value: f64) -> Self {
                Self { value, unit: MassUnit::pound_troy.into() }
            }
            #[doc = "Create a new [`Mass`] with units of [`MassUnit::slug`]."]
            pub fn slug(value: f64) -> Self {
                Self { value, unit: MassUnit::slug.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ton_assay`]."]
            pub fn ton_assay(value: f64) -> Self {
                Self { value, unit: MassUnit::ton_assay.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ton_long`]."]
            pub fn ton_long(value: f64) -> Self {
                Self { value, unit: MassUnit::ton_long.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ton_short`]."]
            pub fn ton_short(value: f64) -> Self {
                Self { value, unit: MassUnit::ton_short.into() }
            }
            #[doc = "Create a new [`Mass`] with units of [`MassUnit::ton`]."]
            pub fn ton(value: f64) -> Self {
                Self { value, unit: MassUnit::ton.into() }
            }
            #[doc = "Retrieve the value associated with this [`Mass`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`Mass`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`Mass`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`MassUnit::yottagram`]."]
            #[inline]
            pub fn to_yottagram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_YOTTAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::yottagram,
                }
            }
            #[doc = "Convert to [`MassUnit::zettagram`]."]
            #[inline]
            pub fn to_zettagram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_ZETTAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::zettagram,
                }
            }
            #[doc = "Convert to [`MassUnit::exagram`]."]
            #[inline]
            pub fn to_exagram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_EXAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::exagram,
                }
            }
            #[doc = "Convert to [`MassUnit::petagram`]."]
            #[inline]
            pub fn to_petagram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_PETAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::petagram,
                }
            }
            #[doc = "Convert to [`MassUnit::teragram`]."]
            #[inline]
            pub fn to_teragram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_TERAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::teragram,
                }
            }
            #[doc = "Convert to [`MassUnit::gigagram`]."]
            #[inline]
            pub fn to_gigagram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_GIGAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::gigagram,
                }
            }
            #[doc = "Convert to [`MassUnit::megagram`]."]
            #[inline]
            pub fn to_megagram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_MEGAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::megagram,
                }
            }
            #[doc = "Convert to [`MassUnit::kilogram`]."]
            #[inline]
            pub fn to_kilogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_KILOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::kilogram,
                }
            }
            #[doc = "Convert to [`MassUnit::hectogram`]."]
            #[inline]
            pub fn to_hectogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_HECTOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::hectogram,
                }
            }
            #[doc = "Convert to [`MassUnit::decagram`]."]
            #[inline]
            pub fn to_decagram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_DECAGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::decagram,
                }
            }
            #[doc = "Convert to [`MassUnit::gram`]."]
            #[inline]
            pub fn to_gram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_GRAM_CONVERSION)) as
                            f64,
                    unit: MassUnit::gram,
                }
            }
            #[doc = "Convert to [`MassUnit::decigram`]."]
            #[inline]
            pub fn to_decigram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_DECIGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::decigram,
                }
            }
            #[doc = "Convert to [`MassUnit::centigram`]."]
            #[inline]
            pub fn to_centigram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_CENTIGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::centigram,
                }
            }
            #[doc = "Convert to [`MassUnit::milligram`]."]
            #[inline]
            pub fn to_milligram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_MILLIGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::milligram,
                }
            }
            #[doc = "Convert to [`MassUnit::microgram`]."]
            #[inline]
            pub fn to_microgram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_MICROGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::microgram,
                }
            }
            #[doc = "Convert to [`MassUnit::nanogram`]."]
            #[inline]
            pub fn to_nanogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_NANOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::nanogram,
                }
            }
            #[doc = "Convert to [`MassUnit::picogram`]."]
            #[inline]
            pub fn to_picogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_PICOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::picogram,
                }
            }
            #[doc = "Convert to [`MassUnit::femtogram`]."]
            #[inline]
            pub fn to_femtogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_FEMTOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::femtogram,
                }
            }
            #[doc = "Convert to [`MassUnit::attogram`]."]
            #[inline]
            pub fn to_attogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_ATTOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::attogram,
                }
            }
            #[doc = "Convert to [`MassUnit::zeptogram`]."]
            #[inline]
            pub fn to_zeptogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_ZEPTOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::zeptogram,
                }
            }
            #[doc = "Convert to [`MassUnit::yoctogram`]."]
            #[inline]
            pub fn to_yoctogram(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_YOCTOGRAM_CONVERSION))
                            as f64,
                    unit: MassUnit::yoctogram,
                }
            }
            #[doc = "Convert to [`MassUnit::carat`]."]
            #[inline]
            pub fn to_carat(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_CARAT_CONVERSION)) as
                            f64,
                    unit: MassUnit::carat,
                }
            }
            #[doc = "Convert to [`MassUnit::dalton`]."]
            #[inline]
            pub fn to_dalton(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_DALTON_CONVERSION)) as
                            f64,
                    unit: MassUnit::dalton,
                }
            }
            #[doc = "Convert to [`MassUnit::grain`]."]
            #[inline]
            pub fn to_grain(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_GRAIN_CONVERSION)) as
                            f64,
                    unit: MassUnit::grain,
                }
            }
            #[doc = "Convert to [`MassUnit::hundredweight_long`]."]
            #[inline]
            pub fn to_hundredweight_long(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (MASS_HUNDREDWEIGHT_LONG_CONVERSION)) as f64,
                    unit: MassUnit::hundredweight_long,
                }
            }
            #[doc = "Convert to [`MassUnit::hundredweight_short`]."]
            #[inline]
            pub fn to_hundredweight_short(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (MASS_HUNDREDWEIGHT_SHORT_CONVERSION)) as f64,
                    unit: MassUnit::hundredweight_short,
                }
            }
            #[doc = "Convert to [`MassUnit::ounce`]."]
            #[inline]
            pub fn to_ounce(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_OUNCE_CONVERSION)) as
                            f64,
                    unit: MassUnit::ounce,
                }
            }
            #[doc = "Convert to [`MassUnit::ounce_troy`]."]
            #[inline]
            pub fn to_ounce_troy(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (MASS_OUNCE_TROY_CONVERSION)) as f64,
                    unit: MassUnit::ounce_troy,
                }
            }
            #[doc = "Convert to [`MassUnit::pennyweight`]."]
            #[inline]
            pub fn to_pennyweight(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (MASS_PENNYWEIGHT_CONVERSION)) as f64,
                    unit: MassUnit::pennyweight,
                }
            }
            #[doc = "Convert to [`MassUnit::pound`]."]
            #[inline]
            pub fn to_pound(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_POUND_CONVERSION)) as
                            f64,
                    unit: MassUnit::pound,
                }
            }
            #[doc = "Convert to [`MassUnit::pound_troy`]."]
            #[inline]
            pub fn to_pound_troy(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (MASS_POUND_TROY_CONVERSION)) as f64,
                    unit: MassUnit::pound_troy,
                }
            }
            #[doc = "Convert to [`MassUnit::slug`]."]
            #[inline]
            pub fn to_slug(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_SLUG_CONVERSION)) as
                            f64,
                    unit: MassUnit::slug,
                }
            }
            #[doc = "Convert to [`MassUnit::ton_assay`]."]
            #[inline]
            pub fn to_ton_assay(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_TON_ASSAY_CONVERSION))
                            as f64,
                    unit: MassUnit::ton_assay,
                }
            }
            #[doc = "Convert to [`MassUnit::ton_long`]."]
            #[inline]
            pub fn to_ton_long(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_TON_LONG_CONVERSION))
                            as f64,
                    unit: MassUnit::ton_long,
                }
            }
            #[doc = "Convert to [`MassUnit::ton_short`]."]
            #[inline]
            pub fn to_ton_short(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_TON_SHORT_CONVERSION))
                            as f64,
                    unit: MassUnit::ton_short,
                }
            }
            #[doc = "Convert to [`MassUnit::ton`]."]
            #[inline]
            pub fn to_ton(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (MASS_TON_CONVERSION)) as
                            f64,
                    unit: MassUnit::ton,
                }
            }
        }
        impl FixedQuantity<MassUnit> for Mass {
            #[inline]
            fn unit(&self) -> MassUnit { self.unit }
            #[inline]
            fn convert(&self, unit: MassUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: MassUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut MassUnit { &mut self.unit }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: MassUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<Mass> for UnitDefinition {
            #[inline]
            fn from(value: Mass) -> Self {
                match value.unit {
                    MassUnit::yottagram => MassUnit::get_yottagram(),
                    MassUnit::zettagram => MassUnit::get_zettagram(),
                    MassUnit::exagram => MassUnit::get_exagram(),
                    MassUnit::petagram => MassUnit::get_petagram(),
                    MassUnit::teragram => MassUnit::get_teragram(),
                    MassUnit::gigagram => MassUnit::get_gigagram(),
                    MassUnit::megagram => MassUnit::get_megagram(),
                    MassUnit::kilogram => MassUnit::get_kilogram(),
                    MassUnit::hectogram => MassUnit::get_hectogram(),
                    MassUnit::decagram => MassUnit::get_decagram(),
                    MassUnit::gram => MassUnit::get_gram(),
                    MassUnit::decigram => MassUnit::get_decigram(),
                    MassUnit::centigram => MassUnit::get_centigram(),
                    MassUnit::milligram => MassUnit::get_milligram(),
                    MassUnit::microgram => MassUnit::get_microgram(),
                    MassUnit::nanogram => MassUnit::get_nanogram(),
                    MassUnit::picogram => MassUnit::get_picogram(),
                    MassUnit::femtogram => MassUnit::get_femtogram(),
                    MassUnit::attogram => MassUnit::get_attogram(),
                    MassUnit::zeptogram => MassUnit::get_zeptogram(),
                    MassUnit::yoctogram => MassUnit::get_yoctogram(),
                    MassUnit::carat => MassUnit::get_carat(),
                    MassUnit::dalton => MassUnit::get_dalton(),
                    MassUnit::grain => MassUnit::get_grain(),
                    MassUnit::hundredweight_long =>
                        MassUnit::get_hundredweight_long(),
                    MassUnit::hundredweight_short =>
                        MassUnit::get_hundredweight_short(),
                    MassUnit::ounce => MassUnit::get_ounce(),
                    MassUnit::ounce_troy => MassUnit::get_ounce_troy(),
                    MassUnit::pennyweight => MassUnit::get_pennyweight(),
                    MassUnit::pound => MassUnit::get_pound(),
                    MassUnit::pound_troy => MassUnit::get_pound_troy(),
                    MassUnit::slug => MassUnit::get_slug(),
                    MassUnit::ton_assay => MassUnit::get_ton_assay(),
                    MassUnit::ton_long => MassUnit::get_ton_long(),
                    MassUnit::ton_short => MassUnit::get_ton_short(),
                    MassUnit::ton => MassUnit::get_ton(),
                }
            }
        }
        impl From<Mass> for Quantity {
            fn from(quantity: Mass) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for Mass {
            fn from(quantity: Quantity) -> Mass {
                Mass {
                    value: quantity.value,
                    unit: MassUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for Mass {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl MassVec {
            #[doc = "Create a new vector of [`MassUnit`]."]
            pub fn new(values: Vec<f64>, unit: MassUnit) -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc = "Retrieve values associated with this [`MassSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`MassSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::yottagram`]."]
            pub fn yottagram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::yottagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::zettagram`]."]
            pub fn zettagram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::zettagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::exagram`]."]
            pub fn exagram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::exagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::petagram`]."]
            pub fn petagram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::petagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::teragram`]."]
            pub fn teragram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::teragram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::gigagram`]."]
            pub fn gigagram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::gigagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::megagram`]."]
            pub fn megagram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::megagram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::kilogram`]."]
            pub fn kilogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::kilogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::hectogram`]."]
            pub fn hectogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::hectogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::decagram`]."]
            pub fn decagram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::decagram.into() }
            }
            #[doc = "Create a new [`Mass`] with units of [`MassUnit::gram`]."]
            pub fn gram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::gram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::decigram`]."]
            pub fn decigram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::decigram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::centigram`]."]
            pub fn centigram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::centigram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::milligram`]."]
            pub fn milligram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::milligram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::microgram`]."]
            pub fn microgram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::microgram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::nanogram`]."]
            pub fn nanogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::nanogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::picogram`]."]
            pub fn picogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::picogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::femtogram`]."]
            pub fn femtogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::femtogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::attogram`]."]
            pub fn attogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::attogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::zeptogram`]."]
            pub fn zeptogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::zeptogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::yoctogram`]."]
            pub fn yoctogram(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::yoctogram.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::carat`]."]
            pub fn carat(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::carat.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::dalton`]."]
            pub fn dalton(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::dalton.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::grain`]."]
            pub fn grain(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::grain.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::hundredweight_long`]."]
            pub fn hundredweight_long(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::hundredweight_long.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::hundredweight_short`]."]
            pub fn hundredweight_short(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::hundredweight_short.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ounce`]."]
            pub fn ounce(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::ounce.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ounce_troy`]."]
            pub fn ounce_troy(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::ounce_troy.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::pennyweight`]."]
            pub fn pennyweight(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::pennyweight.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::pound`]."]
            pub fn pound(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::pound.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::pound_troy`]."]
            pub fn pound_troy(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::pound_troy.into() }
            }
            #[doc = "Create a new [`Mass`] with units of [`MassUnit::slug`]."]
            pub fn slug(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::slug.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ton_assay`]."]
            pub fn ton_assay(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::ton_assay.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ton_long`]."]
            pub fn ton_long(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::ton_long.into() }
            }
            #[doc =
            "Create a new [`Mass`] with units of [`MassUnit::ton_short`]."]
            pub fn ton_short(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::ton_short.into() }
            }
            #[doc = "Create a new [`Mass`] with units of [`MassUnit::ton`]."]
            pub fn ton(values: Vec<f64>) -> Self {
                Self { values, unit: MassUnit::ton.into() }
            }
            #[doc = "Convert to [`MassUnit::yottagram`]."]
            #[inline]
            pub fn to_yottagram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::yottagram);
                r
            }
            #[doc = "Convert to [`MassUnit::zettagram`]."]
            #[inline]
            pub fn to_zettagram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::zettagram);
                r
            }
            #[doc = "Convert to [`MassUnit::exagram`]."]
            #[inline]
            pub fn to_exagram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::exagram);
                r
            }
            #[doc = "Convert to [`MassUnit::petagram`]."]
            #[inline]
            pub fn to_petagram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::petagram);
                r
            }
            #[doc = "Convert to [`MassUnit::teragram`]."]
            #[inline]
            pub fn to_teragram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::teragram);
                r
            }
            #[doc = "Convert to [`MassUnit::gigagram`]."]
            #[inline]
            pub fn to_gigagram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::gigagram);
                r
            }
            #[doc = "Convert to [`MassUnit::megagram`]."]
            #[inline]
            pub fn to_megagram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::megagram);
                r
            }
            #[doc = "Convert to [`MassUnit::kilogram`]."]
            #[inline]
            pub fn to_kilogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::kilogram);
                r
            }
            #[doc = "Convert to [`MassUnit::hectogram`]."]
            #[inline]
            pub fn to_hectogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::hectogram);
                r
            }
            #[doc = "Convert to [`MassUnit::decagram`]."]
            #[inline]
            pub fn to_decagram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::decagram);
                r
            }
            #[doc = "Convert to [`MassUnit::gram`]."]
            #[inline]
            pub fn to_gram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::gram);
                r
            }
            #[doc = "Convert to [`MassUnit::decigram`]."]
            #[inline]
            pub fn to_decigram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::decigram);
                r
            }
            #[doc = "Convert to [`MassUnit::centigram`]."]
            #[inline]
            pub fn to_centigram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::centigram);
                r
            }
            #[doc = "Convert to [`MassUnit::milligram`]."]
            #[inline]
            pub fn to_milligram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::milligram);
                r
            }
            #[doc = "Convert to [`MassUnit::microgram`]."]
            #[inline]
            pub fn to_microgram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::microgram);
                r
            }
            #[doc = "Convert to [`MassUnit::nanogram`]."]
            #[inline]
            pub fn to_nanogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::nanogram);
                r
            }
            #[doc = "Convert to [`MassUnit::picogram`]."]
            #[inline]
            pub fn to_picogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::picogram);
                r
            }
            #[doc = "Convert to [`MassUnit::femtogram`]."]
            #[inline]
            pub fn to_femtogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::femtogram);
                r
            }
            #[doc = "Convert to [`MassUnit::attogram`]."]
            #[inline]
            pub fn to_attogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::attogram);
                r
            }
            #[doc = "Convert to [`MassUnit::zeptogram`]."]
            #[inline]
            pub fn to_zeptogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::zeptogram);
                r
            }
            #[doc = "Convert to [`MassUnit::yoctogram`]."]
            #[inline]
            pub fn to_yoctogram(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::yoctogram);
                r
            }
            #[doc = "Convert to [`MassUnit::carat`]."]
            #[inline]
            pub fn to_carat(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::carat);
                r
            }
            #[doc = "Convert to [`MassUnit::dalton`]."]
            #[inline]
            pub fn to_dalton(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::dalton);
                r
            }
            #[doc = "Convert to [`MassUnit::grain`]."]
            #[inline]
            pub fn to_grain(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::grain);
                r
            }
            #[doc = "Convert to [`MassUnit::hundredweight_long`]."]
            #[inline]
            pub fn to_hundredweight_long(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::hundredweight_long);
                r
            }
            #[doc = "Convert to [`MassUnit::hundredweight_short`]."]
            #[inline]
            pub fn to_hundredweight_short(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::hundredweight_short);
                r
            }
            #[doc = "Convert to [`MassUnit::ounce`]."]
            #[inline]
            pub fn to_ounce(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::ounce);
                r
            }
            #[doc = "Convert to [`MassUnit::ounce_troy`]."]
            #[inline]
            pub fn to_ounce_troy(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::ounce_troy);
                r
            }
            #[doc = "Convert to [`MassUnit::pennyweight`]."]
            #[inline]
            pub fn to_pennyweight(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::pennyweight);
                r
            }
            #[doc = "Convert to [`MassUnit::pound`]."]
            #[inline]
            pub fn to_pound(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::pound);
                r
            }
            #[doc = "Convert to [`MassUnit::pound_troy`]."]
            #[inline]
            pub fn to_pound_troy(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::pound_troy);
                r
            }
            #[doc = "Convert to [`MassUnit::slug`]."]
            #[inline]
            pub fn to_slug(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::slug);
                r
            }
            #[doc = "Convert to [`MassUnit::ton_assay`]."]
            #[inline]
            pub fn to_ton_assay(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::ton_assay);
                r
            }
            #[doc = "Convert to [`MassUnit::ton_long`]."]
            #[inline]
            pub fn to_ton_long(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::ton_long);
                r
            }
            #[doc = "Convert to [`MassUnit::ton_short`]."]
            #[inline]
            pub fn to_ton_short(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::ton_short);
                r
            }
            #[doc = "Convert to [`MassUnit::ton`]."]
            #[inline]
            pub fn to_ton(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(MassUnit::ton);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for Mass {
            type Output = Mass;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for Mass {
            type Output = Mass;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for Mass {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for Mass {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for Mass {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<Mass> for Quantity {
            fn eq(&self, other: &Mass) -> bool { *other == *self }
        }
        impl PartialEq<Mass> for Mass {
            fn eq(&self, other: &Mass) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for Mass {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for Mass {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<Mass> for Mass {
            type Output = Self;
            fn add(self, rhs: Mass) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Mass> for Mass {
            type Output = Self;
            fn sub(self, rhs: Mass) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for Mass {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for Mass {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for Mass {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for Mass {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for Mass {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for Mass {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc = "Array storage for a series of values and [`MassUnit`]."]
        pub struct MassArray<const N : usize> {
            pub(crate) unit: MassUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for MassArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <MassUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`MassUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for MassArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("MassArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <MassUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <MassUnit as utoipa::PartialSchema>::schema())]);
                <MassUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for MassArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "MassArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<MassArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<MassArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    MassArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<MassArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = MassArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct MassArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<MassUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct MassArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<MassArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct MassArray with 2 elements")),
                                    };
                                _serde::__private::Ok(MassArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<MassUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<MassUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<MassArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(MassArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "MassArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<MassArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for MassArray<N> { }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for MassArray<N> {
            #[inline]
            fn clone(&self) -> MassArray<N> {
                let _: ::core::clone::AssertParamIsClone<MassUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for MassArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "MassArray", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            MassArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for MassArray<N> {
            #[inline]
            fn eq(&self, other: &MassArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for MassArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for MassArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc = "Vector storage for a series of values and [`MassUnit`]."]
        pub struct MassVec {
            pub(crate) unit: MassUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for MassVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <MassUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`MassUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for MassVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("MassVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <MassUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <MassUnit as utoipa::PartialSchema>::schema())]);
                <MassUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for MassVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "MassVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for MassVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<MassVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = MassVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct MassVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<MassUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct MassVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct MassVec with 2 elements")),
                                    };
                                _serde::__private::Ok(MassVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<MassUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<MassUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(MassVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "MassVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<MassVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for MassVec {
            #[inline]
            fn clone(&self) -> MassVec {
                MassVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MassVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "MassVec", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MassVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MassVec {
            #[inline]
            fn eq(&self, other: &MassVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for MassVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for MassVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<MassUnit, f64> for MassVec {
            fn unit(&self) -> MassUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: MassUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: MassUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: MassUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize> crate::traits::FixedSliceQuantity<MassUnit, f64>
            for MassArray<N> {
            fn unit(&self) -> MassUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: MassUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: MassUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: MassUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for MassVec {
            type Output = MassVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for MassVec {
            type Output = MassVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for MassVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for MassVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<MassVec> for MassVec {
            fn add_assign(&mut self, rhs: MassVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<MassVec> for MassVec {
            fn sub_assign(&mut self, rhs: MassVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for MassArray<N> {
            type Output = MassArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for MassArray<N> {
            type Output = MassArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for MassArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for MassArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<MassArray<N>> for MassArray<N> {
            fn add_assign(&mut self, rhs: MassArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<MassArray<N>> for MassArray<N> {
            fn sub_assign(&mut self, rhs: MassArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<MassVec> for VecQuantity {
            fn from(input: MassVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<MassUnit> for UnitDefinition {
            #[inline]
            fn from(value: MassUnit) -> Self {
                match value {
                    MassUnit::yottagram => MassUnit::get_yottagram(),
                    MassUnit::zettagram => MassUnit::get_zettagram(),
                    MassUnit::exagram => MassUnit::get_exagram(),
                    MassUnit::petagram => MassUnit::get_petagram(),
                    MassUnit::teragram => MassUnit::get_teragram(),
                    MassUnit::gigagram => MassUnit::get_gigagram(),
                    MassUnit::megagram => MassUnit::get_megagram(),
                    MassUnit::kilogram => MassUnit::get_kilogram(),
                    MassUnit::hectogram => MassUnit::get_hectogram(),
                    MassUnit::decagram => MassUnit::get_decagram(),
                    MassUnit::gram => MassUnit::get_gram(),
                    MassUnit::decigram => MassUnit::get_decigram(),
                    MassUnit::centigram => MassUnit::get_centigram(),
                    MassUnit::milligram => MassUnit::get_milligram(),
                    MassUnit::microgram => MassUnit::get_microgram(),
                    MassUnit::nanogram => MassUnit::get_nanogram(),
                    MassUnit::picogram => MassUnit::get_picogram(),
                    MassUnit::femtogram => MassUnit::get_femtogram(),
                    MassUnit::attogram => MassUnit::get_attogram(),
                    MassUnit::zeptogram => MassUnit::get_zeptogram(),
                    MassUnit::yoctogram => MassUnit::get_yoctogram(),
                    MassUnit::carat => MassUnit::get_carat(),
                    MassUnit::dalton => MassUnit::get_dalton(),
                    MassUnit::grain => MassUnit::get_grain(),
                    MassUnit::hundredweight_long =>
                        MassUnit::get_hundredweight_long(),
                    MassUnit::hundredweight_short =>
                        MassUnit::get_hundredweight_short(),
                    MassUnit::ounce => MassUnit::get_ounce(),
                    MassUnit::ounce_troy => MassUnit::get_ounce_troy(),
                    MassUnit::pennyweight => MassUnit::get_pennyweight(),
                    MassUnit::pound => MassUnit::get_pound(),
                    MassUnit::pound_troy => MassUnit::get_pound_troy(),
                    MassUnit::slug => MassUnit::get_slug(),
                    MassUnit::ton_assay => MassUnit::get_ton_assay(),
                    MassUnit::ton_long => MassUnit::get_ton_long(),
                    MassUnit::ton_short => MassUnit::get_ton_short(),
                    MassUnit::ton => MassUnit::get_ton(),
                }
            }
        }
        impl TryFrom<&str> for MassUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<MassUnit> =
                    match value {
                        "Yg" => Some(MassUnit::yottagram),
                        "Zg" => Some(MassUnit::zettagram),
                        "Eg" => Some(MassUnit::exagram),
                        "Pg" => Some(MassUnit::petagram),
                        "Tg" => Some(MassUnit::teragram),
                        "Gg" => Some(MassUnit::gigagram),
                        "Mg" => Some(MassUnit::megagram),
                        "kg" => Some(MassUnit::kilogram),
                        "hg" => Some(MassUnit::hectogram),
                        "dag" => Some(MassUnit::decagram),
                        "g" => Some(MassUnit::gram),
                        "dg" => Some(MassUnit::decigram),
                        "cg" => Some(MassUnit::centigram),
                        "mg" => Some(MassUnit::milligram),
                        "g" => Some(MassUnit::microgram),
                        "ng" => Some(MassUnit::nanogram),
                        "pg" => Some(MassUnit::picogram),
                        "fg" => Some(MassUnit::femtogram),
                        "ag" => Some(MassUnit::attogram),
                        "zg" => Some(MassUnit::zeptogram),
                        "yg" => Some(MassUnit::yoctogram),
                        "ct" => Some(MassUnit::carat),
                        "Da" => Some(MassUnit::dalton),
                        "gr" => Some(MassUnit::grain),
                        "cwt long" => Some(MassUnit::hundredweight_long),
                        "cwt short" => Some(MassUnit::hundredweight_short),
                        "oz" => Some(MassUnit::ounce),
                        "oz t" => Some(MassUnit::ounce_troy),
                        "dwt" => Some(MassUnit::pennyweight),
                        "lb" => Some(MassUnit::pound),
                        "lb t" => Some(MassUnit::pound_troy),
                        "slug" => Some(MassUnit::slug),
                        "AT" => Some(MassUnit::ton_assay),
                        "2240 lb" => Some(MassUnit::ton_long),
                        "2000 lb" => Some(MassUnit::ton_short),
                        "t" => Some(MassUnit::ton),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<MassUnit> =
                    match value {
                        "yottagram" => Some(MassUnit::yottagram),
                        "zettagram" => Some(MassUnit::zettagram),
                        "exagram" => Some(MassUnit::exagram),
                        "petagram" => Some(MassUnit::petagram),
                        "teragram" => Some(MassUnit::teragram),
                        "gigagram" => Some(MassUnit::gigagram),
                        "megagram" => Some(MassUnit::megagram),
                        "kilogram" => Some(MassUnit::kilogram),
                        "hectogram" => Some(MassUnit::hectogram),
                        "decagram" => Some(MassUnit::decagram),
                        "gram" => Some(MassUnit::gram),
                        "decigram" => Some(MassUnit::decigram),
                        "centigram" => Some(MassUnit::centigram),
                        "milligram" => Some(MassUnit::milligram),
                        "microgram" => Some(MassUnit::microgram),
                        "nanogram" => Some(MassUnit::nanogram),
                        "picogram" => Some(MassUnit::picogram),
                        "femtogram" => Some(MassUnit::femtogram),
                        "attogram" => Some(MassUnit::attogram),
                        "zeptogram" => Some(MassUnit::zeptogram),
                        "yoctogram" => Some(MassUnit::yoctogram),
                        "carat" => Some(MassUnit::carat),
                        "dalton" => Some(MassUnit::dalton),
                        "grain" => Some(MassUnit::grain),
                        "hundredweight (long)" =>
                            Some(MassUnit::hundredweight_long),
                        "hundredweight (short)" =>
                            Some(MassUnit::hundredweight_short),
                        "ounce" => Some(MassUnit::ounce),
                        "troy ounce" => Some(MassUnit::ounce_troy),
                        "pennyweight" => Some(MassUnit::pennyweight),
                        "pound" => Some(MassUnit::pound),
                        "troy pound" => Some(MassUnit::pound_troy),
                        "slug" => Some(MassUnit::slug),
                        "assay ton" => Some(MassUnit::ton_assay),
                        "long ton" => Some(MassUnit::ton_long),
                        "short ton" => Some(MassUnit::ton_short),
                        "ton" => Some(MassUnit::ton),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<MassUnit> =
                    match value {
                        "yottagrams" => Some(MassUnit::yottagram),
                        "zettagrams" => Some(MassUnit::zettagram),
                        "exagrams" => Some(MassUnit::exagram),
                        "petagrams" => Some(MassUnit::petagram),
                        "teragrams" => Some(MassUnit::teragram),
                        "gigagrams" => Some(MassUnit::gigagram),
                        "megagrams" => Some(MassUnit::megagram),
                        "kilograms" => Some(MassUnit::kilogram),
                        "hectograms" => Some(MassUnit::hectogram),
                        "decagrams" => Some(MassUnit::decagram),
                        "grams" => Some(MassUnit::gram),
                        "decigrams" => Some(MassUnit::decigram),
                        "centigrams" => Some(MassUnit::centigram),
                        "milligrams" => Some(MassUnit::milligram),
                        "micrograms" => Some(MassUnit::microgram),
                        "nanograms" => Some(MassUnit::nanogram),
                        "picograms" => Some(MassUnit::picogram),
                        "femtograms" => Some(MassUnit::femtogram),
                        "attograms" => Some(MassUnit::attogram),
                        "zeptograms" => Some(MassUnit::zeptogram),
                        "yoctograms" => Some(MassUnit::yoctogram),
                        "carats" => Some(MassUnit::carat),
                        "daltons" => Some(MassUnit::dalton),
                        "grains" => Some(MassUnit::grain),
                        "hundredweight (long)" =>
                            Some(MassUnit::hundredweight_long),
                        "hundredweight (short)" =>
                            Some(MassUnit::hundredweight_short),
                        "ounces" => Some(MassUnit::ounce),
                        "troy ounces" => Some(MassUnit::ounce_troy),
                        "pennyweight" => Some(MassUnit::pennyweight),
                        "pounds" => Some(MassUnit::pound),
                        "troy pounds" => Some(MassUnit::pound_troy),
                        "slugs" => Some(MassUnit::slug),
                        "assay tons" => Some(MassUnit::ton_assay),
                        "long tons" => Some(MassUnit::ton_long),
                        "short tons" => Some(MassUnit::ton_short),
                        "tons" => Some(MassUnit::ton),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"Mass\"")
                   }
            }
        }
        impl core::fmt::Display for MassUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    MassUnit::yottagram =>
                        f.write_fmt(format_args!("{0}", "yottagram")),
                    MassUnit::zettagram =>
                        f.write_fmt(format_args!("{0}", "zettagram")),
                    MassUnit::exagram =>
                        f.write_fmt(format_args!("{0}", "exagram")),
                    MassUnit::petagram =>
                        f.write_fmt(format_args!("{0}", "petagram")),
                    MassUnit::teragram =>
                        f.write_fmt(format_args!("{0}", "teragram")),
                    MassUnit::gigagram =>
                        f.write_fmt(format_args!("{0}", "gigagram")),
                    MassUnit::megagram =>
                        f.write_fmt(format_args!("{0}", "megagram")),
                    MassUnit::kilogram =>
                        f.write_fmt(format_args!("{0}", "kilogram")),
                    MassUnit::hectogram =>
                        f.write_fmt(format_args!("{0}", "hectogram")),
                    MassUnit::decagram =>
                        f.write_fmt(format_args!("{0}", "decagram")),
                    MassUnit::gram => f.write_fmt(format_args!("{0}", "gram")),
                    MassUnit::decigram =>
                        f.write_fmt(format_args!("{0}", "decigram")),
                    MassUnit::centigram =>
                        f.write_fmt(format_args!("{0}", "centigram")),
                    MassUnit::milligram =>
                        f.write_fmt(format_args!("{0}", "milligram")),
                    MassUnit::microgram =>
                        f.write_fmt(format_args!("{0}", "microgram")),
                    MassUnit::nanogram =>
                        f.write_fmt(format_args!("{0}", "nanogram")),
                    MassUnit::picogram =>
                        f.write_fmt(format_args!("{0}", "picogram")),
                    MassUnit::femtogram =>
                        f.write_fmt(format_args!("{0}", "femtogram")),
                    MassUnit::attogram =>
                        f.write_fmt(format_args!("{0}", "attogram")),
                    MassUnit::zeptogram =>
                        f.write_fmt(format_args!("{0}", "zeptogram")),
                    MassUnit::yoctogram =>
                        f.write_fmt(format_args!("{0}", "yoctogram")),
                    MassUnit::carat =>
                        f.write_fmt(format_args!("{0}", "carat")),
                    MassUnit::dalton =>
                        f.write_fmt(format_args!("{0}", "dalton")),
                    MassUnit::grain =>
                        f.write_fmt(format_args!("{0}", "grain")),
                    MassUnit::hundredweight_long =>
                        f.write_fmt(format_args!("{0}", "hundredweight (long)")),
                    MassUnit::hundredweight_short =>
                        f.write_fmt(format_args!("{0}", "hundredweight (short)")),
                    MassUnit::ounce =>
                        f.write_fmt(format_args!("{0}", "ounce")),
                    MassUnit::ounce_troy =>
                        f.write_fmt(format_args!("{0}", "troy ounce")),
                    MassUnit::pennyweight =>
                        f.write_fmt(format_args!("{0}", "pennyweight")),
                    MassUnit::pound =>
                        f.write_fmt(format_args!("{0}", "pound")),
                    MassUnit::pound_troy =>
                        f.write_fmt(format_args!("{0}", "troy pound")),
                    MassUnit::slug => f.write_fmt(format_args!("{0}", "slug")),
                    MassUnit::ton_assay =>
                        f.write_fmt(format_args!("{0}", "assay ton")),
                    MassUnit::ton_long =>
                        f.write_fmt(format_args!("{0}", "long ton")),
                    MassUnit::ton_short =>
                        f.write_fmt(format_args!("{0}", "short ton")),
                    MassUnit::ton => f.write_fmt(format_args!("{0}", "ton")),
                }
            }
        }
    }
    #[cfg(any(feature = "Mass", feature = "All"))]
    pub use crate::unit_definitions::mass::MassArray;
    #[cfg(any(feature = "Mass", feature = "All"))]
    pub use crate::unit_definitions::mass::Mass;
    #[cfg(any(feature = "Mass", feature = "All"))]
    pub use crate::unit_definitions::mass::MassVec;
    #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
    mod temperature_interval {
        //! Temperature interval (base UnitDefinition kelvin, K).
        //!
        //! Temperature interval has the same dimensions as [thermodynamic temperature][tt] but is not
        //! directly comparable. See [thermodynamic temperature][tt] for a full explanation.
        //!
        //! [tt]: ../thermodynamic_temperature/index.html
        use crate::{prefix, quantity};
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Temperature interval (base UnitDefinition kelvin, K)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "TemperatureIntervalUnit")]
        pub enum TemperatureIntervalUnit {
            yottakelvin,
            zettakelvin,
            exakelvin,
            petakelvin,
            terakelvin,
            gigakelvin,
            megakelvin,
            kilokelvin,
            hectokelvin,
            decakelvin,
            kelvin,
            decikelvin,
            centikelvin,
            millikelvin,
            microkelvin,
            nanokelvin,
            picokelvin,
            femtokelvin,
            attokelvin,
            zeptokelvin,
            yoctokelvin,
            degree_celsius,
            degree_fahrenheit,
            degree_rankine,
        }
        impl utoipa::__dev::ComposeSchema for TemperatureIntervalUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 24usize],
                                &str>(Some(["yottakelvin", "zettakelvin", "exakelvin",
                                            "petakelvin", "terakelvin", "gigakelvin", "megakelvin",
                                            "kilokelvin", "hectokelvin", "decakelvin", "kelvin",
                                            "decikelvin", "centikelvin", "millikelvin", "microkelvin",
                                            "nanokelvin", "picokelvin", "femtokelvin", "attokelvin",
                                            "zeptokelvin", "yoctokelvin", "degree_celsius",
                                            "degree_fahrenheit",
                                            "degree_rankine"])).title(Some("TemperatureIntervalUnit")).description(Some("Temperature interval (base UnitDefinition kelvin, K).")).into()
            }
        }
        impl utoipa::ToSchema for TemperatureIntervalUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TemperatureIntervalUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TemperatureIntervalUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            TemperatureIntervalUnit::yottakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 0u32, "yottakelvin"),
                            TemperatureIntervalUnit::zettakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 1u32, "zettakelvin"),
                            TemperatureIntervalUnit::exakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 2u32, "exakelvin"),
                            TemperatureIntervalUnit::petakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 3u32, "petakelvin"),
                            TemperatureIntervalUnit::terakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 4u32, "terakelvin"),
                            TemperatureIntervalUnit::gigakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 5u32, "gigakelvin"),
                            TemperatureIntervalUnit::megakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 6u32, "megakelvin"),
                            TemperatureIntervalUnit::kilokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 7u32, "kilokelvin"),
                            TemperatureIntervalUnit::hectokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 8u32, "hectokelvin"),
                            TemperatureIntervalUnit::decakelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 9u32, "decakelvin"),
                            TemperatureIntervalUnit::kelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 10u32, "kelvin"),
                            TemperatureIntervalUnit::decikelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 11u32, "decikelvin"),
                            TemperatureIntervalUnit::centikelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 12u32, "centikelvin"),
                            TemperatureIntervalUnit::millikelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 13u32, "millikelvin"),
                            TemperatureIntervalUnit::microkelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 14u32, "microkelvin"),
                            TemperatureIntervalUnit::nanokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 15u32, "nanokelvin"),
                            TemperatureIntervalUnit::picokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 16u32, "picokelvin"),
                            TemperatureIntervalUnit::femtokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 17u32, "femtokelvin"),
                            TemperatureIntervalUnit::attokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 18u32, "attokelvin"),
                            TemperatureIntervalUnit::zeptokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 19u32, "zeptokelvin"),
                            TemperatureIntervalUnit::yoctokelvin =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 20u32, "yoctokelvin"),
                            TemperatureIntervalUnit::degree_celsius =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 21u32, "degree_celsius"),
                            TemperatureIntervalUnit::degree_fahrenheit =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 22u32, "degree_fahrenheit"),
                            TemperatureIntervalUnit::degree_rankine =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TemperatureIntervalUnit", 23u32, "degree_rankine"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TemperatureIntervalUnit
                    {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    17u64 => _serde::__private::Ok(__Field::__field17),
                                    18u64 => _serde::__private::Ok(__Field::__field18),
                                    19u64 => _serde::__private::Ok(__Field::__field19),
                                    20u64 => _serde::__private::Ok(__Field::__field20),
                                    21u64 => _serde::__private::Ok(__Field::__field21),
                                    22u64 => _serde::__private::Ok(__Field::__field22),
                                    23u64 => _serde::__private::Ok(__Field::__field23),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 24")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "yottakelvin" => _serde::__private::Ok(__Field::__field0),
                                    "zettakelvin" => _serde::__private::Ok(__Field::__field1),
                                    "exakelvin" => _serde::__private::Ok(__Field::__field2),
                                    "petakelvin" => _serde::__private::Ok(__Field::__field3),
                                    "terakelvin" => _serde::__private::Ok(__Field::__field4),
                                    "gigakelvin" => _serde::__private::Ok(__Field::__field5),
                                    "megakelvin" => _serde::__private::Ok(__Field::__field6),
                                    "kilokelvin" => _serde::__private::Ok(__Field::__field7),
                                    "hectokelvin" => _serde::__private::Ok(__Field::__field8),
                                    "decakelvin" => _serde::__private::Ok(__Field::__field9),
                                    "kelvin" => _serde::__private::Ok(__Field::__field10),
                                    "decikelvin" => _serde::__private::Ok(__Field::__field11),
                                    "centikelvin" => _serde::__private::Ok(__Field::__field12),
                                    "millikelvin" => _serde::__private::Ok(__Field::__field13),
                                    "microkelvin" => _serde::__private::Ok(__Field::__field14),
                                    "nanokelvin" => _serde::__private::Ok(__Field::__field15),
                                    "picokelvin" => _serde::__private::Ok(__Field::__field16),
                                    "femtokelvin" => _serde::__private::Ok(__Field::__field17),
                                    "attokelvin" => _serde::__private::Ok(__Field::__field18),
                                    "zeptokelvin" => _serde::__private::Ok(__Field::__field19),
                                    "yoctokelvin" => _serde::__private::Ok(__Field::__field20),
                                    "degree_celsius" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    "degree_fahrenheit" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    "degree_rankine" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"yottakelvin" => _serde::__private::Ok(__Field::__field0),
                                    b"zettakelvin" => _serde::__private::Ok(__Field::__field1),
                                    b"exakelvin" => _serde::__private::Ok(__Field::__field2),
                                    b"petakelvin" => _serde::__private::Ok(__Field::__field3),
                                    b"terakelvin" => _serde::__private::Ok(__Field::__field4),
                                    b"gigakelvin" => _serde::__private::Ok(__Field::__field5),
                                    b"megakelvin" => _serde::__private::Ok(__Field::__field6),
                                    b"kilokelvin" => _serde::__private::Ok(__Field::__field7),
                                    b"hectokelvin" => _serde::__private::Ok(__Field::__field8),
                                    b"decakelvin" => _serde::__private::Ok(__Field::__field9),
                                    b"kelvin" => _serde::__private::Ok(__Field::__field10),
                                    b"decikelvin" => _serde::__private::Ok(__Field::__field11),
                                    b"centikelvin" => _serde::__private::Ok(__Field::__field12),
                                    b"millikelvin" => _serde::__private::Ok(__Field::__field13),
                                    b"microkelvin" => _serde::__private::Ok(__Field::__field14),
                                    b"nanokelvin" => _serde::__private::Ok(__Field::__field15),
                                    b"picokelvin" => _serde::__private::Ok(__Field::__field16),
                                    b"femtokelvin" => _serde::__private::Ok(__Field::__field17),
                                    b"attokelvin" => _serde::__private::Ok(__Field::__field18),
                                    b"zeptokelvin" => _serde::__private::Ok(__Field::__field19),
                                    b"yoctokelvin" => _serde::__private::Ok(__Field::__field20),
                                    b"degree_celsius" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    b"degree_fahrenheit" =>
                                        _serde::__private::Ok(__Field::__field22),
                                    b"degree_rankine" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TemperatureIntervalUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TemperatureIntervalUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum TemperatureIntervalUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::yottakelvin)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::zettakelvin)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::exakelvin)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::petakelvin)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::terakelvin)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::gigakelvin)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::megakelvin)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::kilokelvin)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::hectokelvin)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::decakelvin)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::kelvin)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::decikelvin)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::centikelvin)
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::millikelvin)
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::microkelvin)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::nanokelvin)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::picokelvin)
                                    }
                                    (__Field::__field17, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::femtokelvin)
                                    }
                                    (__Field::__field18, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::attokelvin)
                                    }
                                    (__Field::__field19, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::zeptokelvin)
                                    }
                                    (__Field::__field20, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::yoctokelvin)
                                    }
                                    (__Field::__field21, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::degree_celsius)
                                    }
                                    (__Field::__field22, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::degree_fahrenheit)
                                    }
                                    (__Field::__field23, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TemperatureIntervalUnit::degree_rankine)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["yottakelvin", "zettakelvin", "exakelvin", "petakelvin",
                                        "terakelvin", "gigakelvin", "megakelvin", "kilokelvin",
                                        "hectokelvin", "decakelvin", "kelvin", "decikelvin",
                                        "centikelvin", "millikelvin", "microkelvin", "nanokelvin",
                                        "picokelvin", "femtokelvin", "attokelvin", "zeptokelvin",
                                        "yoctokelvin", "degree_celsius", "degree_fahrenheit",
                                        "degree_rankine"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "TemperatureIntervalUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TemperatureIntervalUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for TemperatureIntervalUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for TemperatureIntervalUnit {
            #[inline]
            fn clone(&self) -> TemperatureIntervalUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for TemperatureIntervalUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        TemperatureIntervalUnit::yottakelvin => "yottakelvin",
                        TemperatureIntervalUnit::zettakelvin => "zettakelvin",
                        TemperatureIntervalUnit::exakelvin => "exakelvin",
                        TemperatureIntervalUnit::petakelvin => "petakelvin",
                        TemperatureIntervalUnit::terakelvin => "terakelvin",
                        TemperatureIntervalUnit::gigakelvin => "gigakelvin",
                        TemperatureIntervalUnit::megakelvin => "megakelvin",
                        TemperatureIntervalUnit::kilokelvin => "kilokelvin",
                        TemperatureIntervalUnit::hectokelvin => "hectokelvin",
                        TemperatureIntervalUnit::decakelvin => "decakelvin",
                        TemperatureIntervalUnit::kelvin => "kelvin",
                        TemperatureIntervalUnit::decikelvin => "decikelvin",
                        TemperatureIntervalUnit::centikelvin => "centikelvin",
                        TemperatureIntervalUnit::millikelvin => "millikelvin",
                        TemperatureIntervalUnit::microkelvin => "microkelvin",
                        TemperatureIntervalUnit::nanokelvin => "nanokelvin",
                        TemperatureIntervalUnit::picokelvin => "picokelvin",
                        TemperatureIntervalUnit::femtokelvin => "femtokelvin",
                        TemperatureIntervalUnit::attokelvin => "attokelvin",
                        TemperatureIntervalUnit::zeptokelvin => "zeptokelvin",
                        TemperatureIntervalUnit::yoctokelvin => "yoctokelvin",
                        TemperatureIntervalUnit::degree_celsius => "degree_celsius",
                        TemperatureIntervalUnit::degree_fahrenheit =>
                            "degree_fahrenheit",
                        TemperatureIntervalUnit::degree_rankine => "degree_rankine",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for TemperatureIntervalUnit {
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for TemperatureIntervalUnit {
            #[inline]
            fn eq(&self, other: &TemperatureIntervalUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for TemperatureIntervalUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for TemperatureIntervalUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const TEMPERATUREINTERVAL_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::P1,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const TEMPERATUREINTERVAL_YOTTAKELVIN_CONVERSION: f64 =
            1.0_E24;
        pub(crate) const TEMPERATUREINTERVAL_ZETTAKELVIN_CONVERSION: f64 =
            1.0_E21;
        pub(crate) const TEMPERATUREINTERVAL_EXAKELVIN_CONVERSION: f64 =
            1.0_E18;
        pub(crate) const TEMPERATUREINTERVAL_PETAKELVIN_CONVERSION: f64 =
            1.0_E15;
        pub(crate) const TEMPERATUREINTERVAL_TERAKELVIN_CONVERSION: f64 =
            1.0_E12;
        pub(crate) const TEMPERATUREINTERVAL_GIGAKELVIN_CONVERSION: f64 =
            1.0_E9;
        pub(crate) const TEMPERATUREINTERVAL_MEGAKELVIN_CONVERSION: f64 =
            1.0_E6;
        pub(crate) const TEMPERATUREINTERVAL_KILOKELVIN_CONVERSION: f64 =
            1.0_E3;
        pub(crate) const TEMPERATUREINTERVAL_HECTOKELVIN_CONVERSION: f64 =
            1.0_E2;
        pub(crate) const TEMPERATUREINTERVAL_DECAKELVIN_CONVERSION: f64 =
            1.0_E1;
        pub(crate) const TEMPERATUREINTERVAL_KELVIN_CONVERSION: f64 = 1.0_E0;
        pub(crate) const TEMPERATUREINTERVAL_DECIKELVIN_CONVERSION: f64 =
            1.0_E-1;
        pub(crate) const TEMPERATUREINTERVAL_CENTIKELVIN_CONVERSION: f64 =
            1.0_E-2;
        pub(crate) const TEMPERATUREINTERVAL_MILLIKELVIN_CONVERSION: f64 =
            1.0_E-3;
        pub(crate) const TEMPERATUREINTERVAL_MICROKELVIN_CONVERSION: f64 =
            1.0_E-6;
        pub(crate) const TEMPERATUREINTERVAL_NANOKELVIN_CONVERSION: f64 =
            1.0_E-9;
        pub(crate) const TEMPERATUREINTERVAL_PICOKELVIN_CONVERSION: f64 =
            1.0_E-12;
        pub(crate) const TEMPERATUREINTERVAL_FEMTOKELVIN_CONVERSION: f64 =
            1.0_E-15;
        pub(crate) const TEMPERATUREINTERVAL_ATTOKELVIN_CONVERSION: f64 =
            1.0_E-18;
        pub(crate) const TEMPERATUREINTERVAL_ZEPTOKELVIN_CONVERSION: f64 =
            1.0_E-21;
        pub(crate) const TEMPERATUREINTERVAL_YOCTOKELVIN_CONVERSION: f64 =
            1.0_E-24;
        pub(crate) const TEMPERATUREINTERVAL_DEGREE_CELSIUS_CONVERSION: f64 =
            1.0_E0;
        pub(crate) const TEMPERATUREINTERVAL_DEGREE_FAHRENHEIT_CONVERSION: f64
            =
            5.0_E0 / 9.0_E0;
        pub(crate) const TEMPERATUREINTERVAL_DEGREE_RANKINE_CONVERSION: f64 =
            5.0_E0 / 9.0_E0;
        impl TemperatureIntervalUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_yottakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_YOTTAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zettakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_ZETTAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_exakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_EXAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_petakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_PETAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_terakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_TERAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gigakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_GIGAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_megakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_MEGAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kilokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_KILOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hectokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_HECTOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decakelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_DECAKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_KELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decikelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_DECIKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_centikelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_CENTIKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_millikelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_MILLIKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_microkelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_MICROKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nanokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_NANOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_picokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_PICOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_femtokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_FEMTOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_attokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_ATTOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zeptokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_ZEPTOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yoctokelvin() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_YOCTOKELVIN_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_degree_celsius() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_DEGREE_CELSIUS_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_degree_fahrenheit() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_DEGREE_FAHRENHEIT_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_degree_rankine() -> UnitDefinition {
                UnitDefinition {
                    base: TEMPERATUREINTERVAL_UNIT_BASE,
                    multiplier: TEMPERATUREINTERVAL_DEGREE_RANKINE_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    TemperatureIntervalUnit::yottakelvin =>
                        TEMPERATUREINTERVAL_YOTTAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::zettakelvin =>
                        TEMPERATUREINTERVAL_ZETTAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::exakelvin =>
                        TEMPERATUREINTERVAL_EXAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::petakelvin =>
                        TEMPERATUREINTERVAL_PETAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::terakelvin =>
                        TEMPERATUREINTERVAL_TERAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::gigakelvin =>
                        TEMPERATUREINTERVAL_GIGAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::megakelvin =>
                        TEMPERATUREINTERVAL_MEGAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::kilokelvin =>
                        TEMPERATUREINTERVAL_KILOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::hectokelvin =>
                        TEMPERATUREINTERVAL_HECTOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::decakelvin =>
                        TEMPERATUREINTERVAL_DECAKELVIN_CONVERSION,
                    TemperatureIntervalUnit::kelvin =>
                        TEMPERATUREINTERVAL_KELVIN_CONVERSION,
                    TemperatureIntervalUnit::decikelvin =>
                        TEMPERATUREINTERVAL_DECIKELVIN_CONVERSION,
                    TemperatureIntervalUnit::centikelvin =>
                        TEMPERATUREINTERVAL_CENTIKELVIN_CONVERSION,
                    TemperatureIntervalUnit::millikelvin =>
                        TEMPERATUREINTERVAL_MILLIKELVIN_CONVERSION,
                    TemperatureIntervalUnit::microkelvin =>
                        TEMPERATUREINTERVAL_MICROKELVIN_CONVERSION,
                    TemperatureIntervalUnit::nanokelvin =>
                        TEMPERATUREINTERVAL_NANOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::picokelvin =>
                        TEMPERATUREINTERVAL_PICOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::femtokelvin =>
                        TEMPERATUREINTERVAL_FEMTOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::attokelvin =>
                        TEMPERATUREINTERVAL_ATTOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::zeptokelvin =>
                        TEMPERATUREINTERVAL_ZEPTOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::yoctokelvin =>
                        TEMPERATUREINTERVAL_YOCTOKELVIN_CONVERSION,
                    TemperatureIntervalUnit::degree_celsius =>
                        TEMPERATUREINTERVAL_DEGREE_CELSIUS_CONVERSION,
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        TEMPERATUREINTERVAL_DEGREE_FAHRENHEIT_CONVERSION,
                    TemperatureIntervalUnit::degree_rankine =>
                        TEMPERATUREINTERVAL_DEGREE_RANKINE_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    TemperatureIntervalUnit::yottakelvin => "YK",
                    TemperatureIntervalUnit::zettakelvin => "ZK",
                    TemperatureIntervalUnit::exakelvin => "EK",
                    TemperatureIntervalUnit::petakelvin => "PK",
                    TemperatureIntervalUnit::terakelvin => "TK",
                    TemperatureIntervalUnit::gigakelvin => "GK",
                    TemperatureIntervalUnit::megakelvin => "MK",
                    TemperatureIntervalUnit::kilokelvin => "kK",
                    TemperatureIntervalUnit::hectokelvin => "hK",
                    TemperatureIntervalUnit::decakelvin => "daK",
                    TemperatureIntervalUnit::kelvin => "K",
                    TemperatureIntervalUnit::decikelvin => "dK",
                    TemperatureIntervalUnit::centikelvin => "cK",
                    TemperatureIntervalUnit::millikelvin => "mK",
                    TemperatureIntervalUnit::microkelvin => "K",
                    TemperatureIntervalUnit::nanokelvin => "nK",
                    TemperatureIntervalUnit::picokelvin => "pK",
                    TemperatureIntervalUnit::femtokelvin => "fK",
                    TemperatureIntervalUnit::attokelvin => "aK",
                    TemperatureIntervalUnit::zeptokelvin => "zK",
                    TemperatureIntervalUnit::yoctokelvin => "yK",
                    TemperatureIntervalUnit::degree_celsius => "C",
                    TemperatureIntervalUnit::degree_fahrenheit => "F",
                    TemperatureIntervalUnit::degree_rankine => "R",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    TemperatureIntervalUnit::yottakelvin => "yottakelvin",
                    TemperatureIntervalUnit::zettakelvin => "zettakelvin",
                    TemperatureIntervalUnit::exakelvin => "exakelvin",
                    TemperatureIntervalUnit::petakelvin => "petakelvin",
                    TemperatureIntervalUnit::terakelvin => "terakelvin",
                    TemperatureIntervalUnit::gigakelvin => "gigakelvin",
                    TemperatureIntervalUnit::megakelvin => "megakelvin",
                    TemperatureIntervalUnit::kilokelvin => "kilokelvin",
                    TemperatureIntervalUnit::hectokelvin => "hectokelvin",
                    TemperatureIntervalUnit::decakelvin => "decakelvin",
                    TemperatureIntervalUnit::kelvin => "kelvin",
                    TemperatureIntervalUnit::decikelvin => "decikelvin",
                    TemperatureIntervalUnit::centikelvin => "centikelvin",
                    TemperatureIntervalUnit::millikelvin => "millikelvin",
                    TemperatureIntervalUnit::microkelvin => "microkelvin",
                    TemperatureIntervalUnit::nanokelvin => "nanokelvin",
                    TemperatureIntervalUnit::picokelvin => "picokelvin",
                    TemperatureIntervalUnit::femtokelvin => "femtokelvin",
                    TemperatureIntervalUnit::attokelvin => "attokelvin",
                    TemperatureIntervalUnit::zeptokelvin => "zeptokelvin",
                    TemperatureIntervalUnit::yoctokelvin => "yoctokelvin",
                    TemperatureIntervalUnit::degree_celsius => "degree Celsius",
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        "degree Fahrenheit",
                    TemperatureIntervalUnit::degree_rankine => "degree Rankine",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    TemperatureIntervalUnit::yottakelvin => "yottakelvins",
                    TemperatureIntervalUnit::zettakelvin => "zettakelvins",
                    TemperatureIntervalUnit::exakelvin => "exakelvins",
                    TemperatureIntervalUnit::petakelvin => "petakelvins",
                    TemperatureIntervalUnit::terakelvin => "terakelvins",
                    TemperatureIntervalUnit::gigakelvin => "gigakelvins",
                    TemperatureIntervalUnit::megakelvin => "megakelvins",
                    TemperatureIntervalUnit::kilokelvin => "kilokelvins",
                    TemperatureIntervalUnit::hectokelvin => "hectokelvins",
                    TemperatureIntervalUnit::decakelvin => "decakelvins",
                    TemperatureIntervalUnit::kelvin => "kelvins",
                    TemperatureIntervalUnit::decikelvin => "decikelvins",
                    TemperatureIntervalUnit::centikelvin => "centikelvins",
                    TemperatureIntervalUnit::millikelvin => "millikelvins",
                    TemperatureIntervalUnit::microkelvin => "microkelvins",
                    TemperatureIntervalUnit::nanokelvin => "nanokelvins",
                    TemperatureIntervalUnit::picokelvin => "picokelvins",
                    TemperatureIntervalUnit::femtokelvin => "femtokelvins",
                    TemperatureIntervalUnit::attokelvin => "attokelvins",
                    TemperatureIntervalUnit::zeptokelvin => "zeptokelvins",
                    TemperatureIntervalUnit::yoctokelvin => "yoctokelvins",
                    TemperatureIntervalUnit::degree_celsius =>
                        "degrees Celsius",
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        "degrees Fahrenheit",
                    TemperatureIntervalUnit::degree_rankine =>
                        "degrees Rankine",
                }
            }
            #[doc = "Available units for this `[TemperatureIntervalUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["yottakelvin", "zettakelvin", "exakelvin", "petakelvin",
                                "terakelvin", "gigakelvin", "megakelvin", "kilokelvin",
                                "hectokelvin", "decakelvin", "kelvin", "decikelvin",
                                "centikelvin", "millikelvin", "microkelvin", "nanokelvin",
                                "picokelvin", "femtokelvin", "attokelvin", "zeptokelvin",
                                "yoctokelvin", "degree Celsius", "degree Fahrenheit",
                                "degree Rankine"];
                UNITS
            }
        }
        impl crate::traits::Unit for TemperatureIntervalUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    TemperatureIntervalUnit::yottakelvin =>
                        TemperatureIntervalUnit::get_yottakelvin(),
                    TemperatureIntervalUnit::zettakelvin =>
                        TemperatureIntervalUnit::get_zettakelvin(),
                    TemperatureIntervalUnit::exakelvin =>
                        TemperatureIntervalUnit::get_exakelvin(),
                    TemperatureIntervalUnit::petakelvin =>
                        TemperatureIntervalUnit::get_petakelvin(),
                    TemperatureIntervalUnit::terakelvin =>
                        TemperatureIntervalUnit::get_terakelvin(),
                    TemperatureIntervalUnit::gigakelvin =>
                        TemperatureIntervalUnit::get_gigakelvin(),
                    TemperatureIntervalUnit::megakelvin =>
                        TemperatureIntervalUnit::get_megakelvin(),
                    TemperatureIntervalUnit::kilokelvin =>
                        TemperatureIntervalUnit::get_kilokelvin(),
                    TemperatureIntervalUnit::hectokelvin =>
                        TemperatureIntervalUnit::get_hectokelvin(),
                    TemperatureIntervalUnit::decakelvin =>
                        TemperatureIntervalUnit::get_decakelvin(),
                    TemperatureIntervalUnit::kelvin =>
                        TemperatureIntervalUnit::get_kelvin(),
                    TemperatureIntervalUnit::decikelvin =>
                        TemperatureIntervalUnit::get_decikelvin(),
                    TemperatureIntervalUnit::centikelvin =>
                        TemperatureIntervalUnit::get_centikelvin(),
                    TemperatureIntervalUnit::millikelvin =>
                        TemperatureIntervalUnit::get_millikelvin(),
                    TemperatureIntervalUnit::microkelvin =>
                        TemperatureIntervalUnit::get_microkelvin(),
                    TemperatureIntervalUnit::nanokelvin =>
                        TemperatureIntervalUnit::get_nanokelvin(),
                    TemperatureIntervalUnit::picokelvin =>
                        TemperatureIntervalUnit::get_picokelvin(),
                    TemperatureIntervalUnit::femtokelvin =>
                        TemperatureIntervalUnit::get_femtokelvin(),
                    TemperatureIntervalUnit::attokelvin =>
                        TemperatureIntervalUnit::get_attokelvin(),
                    TemperatureIntervalUnit::zeptokelvin =>
                        TemperatureIntervalUnit::get_zeptokelvin(),
                    TemperatureIntervalUnit::yoctokelvin =>
                        TemperatureIntervalUnit::get_yoctokelvin(),
                    TemperatureIntervalUnit::degree_celsius =>
                        TemperatureIntervalUnit::get_degree_celsius(),
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        TemperatureIntervalUnit::get_degree_fahrenheit(),
                    TemperatureIntervalUnit::degree_rankine =>
                        TemperatureIntervalUnit::get_degree_rankine(),
                }
            }
            #[inline]
            fn base() -> UnitBase { TEMPERATUREINTERVAL_UNIT_BASE }
        }
        impl From<TemperatureIntervalUnit> for crate::Units {
            fn from(value: TemperatureIntervalUnit) -> Self {
                match value {
                    TemperatureIntervalUnit::yottakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::yottakelvin),
                    TemperatureIntervalUnit::zettakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::zettakelvin),
                    TemperatureIntervalUnit::exakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::exakelvin),
                    TemperatureIntervalUnit::petakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::petakelvin),
                    TemperatureIntervalUnit::terakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::terakelvin),
                    TemperatureIntervalUnit::gigakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::gigakelvin),
                    TemperatureIntervalUnit::megakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::megakelvin),
                    TemperatureIntervalUnit::kilokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::kilokelvin),
                    TemperatureIntervalUnit::hectokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::hectokelvin),
                    TemperatureIntervalUnit::decakelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::decakelvin),
                    TemperatureIntervalUnit::kelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::kelvin),
                    TemperatureIntervalUnit::decikelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::decikelvin),
                    TemperatureIntervalUnit::centikelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::centikelvin),
                    TemperatureIntervalUnit::millikelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::millikelvin),
                    TemperatureIntervalUnit::microkelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::microkelvin),
                    TemperatureIntervalUnit::nanokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::nanokelvin),
                    TemperatureIntervalUnit::picokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::picokelvin),
                    TemperatureIntervalUnit::femtokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::femtokelvin),
                    TemperatureIntervalUnit::attokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::attokelvin),
                    TemperatureIntervalUnit::zeptokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::zeptokelvin),
                    TemperatureIntervalUnit::yoctokelvin =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::yoctokelvin),
                    TemperatureIntervalUnit::degree_celsius =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::degree_celsius),
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::degree_fahrenheit),
                    TemperatureIntervalUnit::degree_rankine =>
                        crate::Units::TemperatureInterval(TemperatureIntervalUnit::degree_rankine),
                }
            }
        }
        impl TryFrom<UnitDefinition> for TemperatureIntervalUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_YOTTAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::yottakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_ZETTAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::zettakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_EXAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::exakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_PETAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::petakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_TERAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::terakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_GIGAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::gigakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_MEGAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::megakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_KILOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::kilokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_HECTOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::hectokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_DECAKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::decakelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_KELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::kelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_DECIKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::decikelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_CENTIKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::centikelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_MILLIKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::millikelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_MICROKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::microkelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_NANOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::nanokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_PICOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::picokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_FEMTOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::femtokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_ATTOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::attokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_ZEPTOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::zeptokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_YOCTOKELVIN_CONVERSION } =>
                        Ok(TemperatureIntervalUnit::yoctokelvin),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_DEGREE_CELSIUS_CONVERSION }
                        => Ok(TemperatureIntervalUnit::degree_celsius),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_DEGREE_FAHRENHEIT_CONVERSION
                        } => Ok(TemperatureIntervalUnit::degree_fahrenheit),
                    UnitDefinition {
                        base: TEMPERATUREINTERVAL_UNIT_BASE,
                        multiplier: TEMPERATUREINTERVAL_DEGREE_RANKINE_CONVERSION }
                        => Ok(TemperatureIntervalUnit::degree_rankine),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "TemperatureInterval"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for TemperatureIntervalUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::yottakelvin)
                        => Ok(TemperatureIntervalUnit::yottakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::zettakelvin)
                        => Ok(TemperatureIntervalUnit::zettakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::exakelvin)
                        => Ok(TemperatureIntervalUnit::exakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::petakelvin)
                        => Ok(TemperatureIntervalUnit::petakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::terakelvin)
                        => Ok(TemperatureIntervalUnit::terakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::gigakelvin)
                        => Ok(TemperatureIntervalUnit::gigakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::megakelvin)
                        => Ok(TemperatureIntervalUnit::megakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::kilokelvin)
                        => Ok(TemperatureIntervalUnit::kilokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::hectokelvin)
                        => Ok(TemperatureIntervalUnit::hectokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::decakelvin)
                        => Ok(TemperatureIntervalUnit::decakelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::kelvin)
                        => Ok(TemperatureIntervalUnit::kelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::decikelvin)
                        => Ok(TemperatureIntervalUnit::decikelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::centikelvin)
                        => Ok(TemperatureIntervalUnit::centikelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::millikelvin)
                        => Ok(TemperatureIntervalUnit::millikelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::microkelvin)
                        => Ok(TemperatureIntervalUnit::microkelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::nanokelvin)
                        => Ok(TemperatureIntervalUnit::nanokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::picokelvin)
                        => Ok(TemperatureIntervalUnit::picokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::femtokelvin)
                        => Ok(TemperatureIntervalUnit::femtokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::attokelvin)
                        => Ok(TemperatureIntervalUnit::attokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::zeptokelvin)
                        => Ok(TemperatureIntervalUnit::zeptokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::yoctokelvin)
                        => Ok(TemperatureIntervalUnit::yoctokelvin),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::degree_celsius)
                        => Ok(TemperatureIntervalUnit::degree_celsius),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::degree_fahrenheit)
                        => Ok(TemperatureIntervalUnit::degree_fahrenheit),
                    crate::Units::TemperatureInterval(TemperatureIntervalUnit::degree_rankine)
                        => Ok(TemperatureIntervalUnit::degree_rankine),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "TemperatureInterval"));
                                        res
                                    }))),
                }
            }
        }
        impl From<TemperatureInterval> for crate::Units {
            fn from(value: TemperatureInterval) -> Self {
                crate::Units::TemperatureInterval(value.unit)
            }
        }
        impl From<&TemperatureInterval> for crate::Units {
            fn from(value: &TemperatureInterval) -> Self {
                crate::Units::TemperatureInterval(value.unit)
            }
        }
        impl From<TemperatureIntervalVec> for crate::Units {
            fn from(value: TemperatureIntervalVec) -> Self {
                crate::Units::TemperatureInterval(value.unit)
            }
        }
        impl From<&TemperatureIntervalVec> for crate::Units {
            fn from(value: &TemperatureIntervalVec) -> Self {
                crate::Units::TemperatureInterval(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Temperature interval (base UnitDefinition kelvin, K)."]
        #[schema(title = "TemperatureInterval")]
        #[doc =
        "Scalar storage of a quantity (f64 and [`TemperatureIntervalUnit`])."]
        pub struct TemperatureInterval {
            pub(crate) value: f64,
            pub(crate) unit: TemperatureIntervalUnit,
        }
        impl utoipa::__dev::ComposeSchema for TemperatureInterval {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("TemperatureInterval")).description(Some(" Temperature interval (base UnitDefinition kelvin, K).\nScalar storage of a quantity (f64 and [`TemperatureIntervalUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for TemperatureInterval {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TemperatureInterval")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <TemperatureIntervalUnit as
                                        utoipa::PartialSchema>::schema())]);
                <TemperatureIntervalUnit as
                        utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TemperatureInterval {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "TemperatureInterval", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TemperatureInterval {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TemperatureInterval>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TemperatureInterval;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct TemperatureInterval")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct TemperatureInterval with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<TemperatureIntervalUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct TemperatureInterval with 2 elements")),
                                    };
                                _serde::__private::Ok(TemperatureInterval {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1:
                                        _serde::__private::Option<TemperatureIntervalUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<TemperatureIntervalUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(TemperatureInterval {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "TemperatureInterval", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TemperatureInterval>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for TemperatureInterval { }
        #[automatically_derived]
        impl ::core::clone::Clone for TemperatureInterval {
            #[inline]
            fn clone(&self) -> TemperatureInterval {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _:
                        ::core::clone::AssertParamIsClone<TemperatureIntervalUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TemperatureInterval {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "TemperatureInterval", "value", &self.value, "unit",
                    &&self.unit)
            }
        }
        impl TemperatureInterval {
            #[doc = "Create a new [`TemperatureIntervalUnit`]."]
            pub fn new(value: f64, unit: TemperatureIntervalUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::yottakelvin`]."]
            pub fn yottakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::yottakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::zettakelvin`]."]
            pub fn zettakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::zettakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::exakelvin`]."]
            pub fn exakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::exakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::petakelvin`]."]
            pub fn petakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::petakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::terakelvin`]."]
            pub fn terakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::terakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::gigakelvin`]."]
            pub fn gigakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::gigakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::megakelvin`]."]
            pub fn megakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::megakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::kilokelvin`]."]
            pub fn kilokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::kilokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::hectokelvin`]."]
            pub fn hectokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::hectokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::decakelvin`]."]
            pub fn decakelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::decakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::kelvin`]."]
            pub fn kelvin(value: f64) -> Self {
                Self { value, unit: TemperatureIntervalUnit::kelvin.into() }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::decikelvin`]."]
            pub fn decikelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::decikelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::centikelvin`]."]
            pub fn centikelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::centikelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::millikelvin`]."]
            pub fn millikelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::millikelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::microkelvin`]."]
            pub fn microkelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::microkelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::nanokelvin`]."]
            pub fn nanokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::nanokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::picokelvin`]."]
            pub fn picokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::picokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::femtokelvin`]."]
            pub fn femtokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::femtokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::attokelvin`]."]
            pub fn attokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::attokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::zeptokelvin`]."]
            pub fn zeptokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::zeptokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::yoctokelvin`]."]
            pub fn yoctokelvin(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::yoctokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::degree_celsius`]."]
            pub fn degree_celsius(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::degree_celsius.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::degree_fahrenheit`]."]
            pub fn degree_fahrenheit(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::degree_fahrenheit.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::degree_rankine`]."]
            pub fn degree_rankine(value: f64) -> Self {
                Self {
                    value,
                    unit: TemperatureIntervalUnit::degree_rankine.into(),
                }
            }
            #[doc =
            "Retrieve the value associated with this [`TemperatureInterval`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`TemperatureInterval`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`TemperatureInterval`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::yottakelvin`]."]
            #[inline]
            pub fn to_yottakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_YOTTAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::yottakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::zettakelvin`]."]
            #[inline]
            pub fn to_zettakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_ZETTAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::zettakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::exakelvin`]."]
            #[inline]
            pub fn to_exakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_EXAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::exakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::petakelvin`]."]
            #[inline]
            pub fn to_petakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_PETAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::petakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::terakelvin`]."]
            #[inline]
            pub fn to_terakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_TERAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::terakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::gigakelvin`]."]
            #[inline]
            pub fn to_gigakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_GIGAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::gigakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::megakelvin`]."]
            #[inline]
            pub fn to_megakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_MEGAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::megakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::kilokelvin`]."]
            #[inline]
            pub fn to_kilokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_KILOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::kilokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::hectokelvin`]."]
            #[inline]
            pub fn to_hectokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_HECTOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::hectokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::decakelvin`]."]
            #[inline]
            pub fn to_decakelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_DECAKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::decakelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::kelvin`]."]
            #[inline]
            pub fn to_kelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_KELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::kelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::decikelvin`]."]
            #[inline]
            pub fn to_decikelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_DECIKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::decikelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::centikelvin`]."]
            #[inline]
            pub fn to_centikelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_CENTIKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::centikelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::millikelvin`]."]
            #[inline]
            pub fn to_millikelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_MILLIKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::millikelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::microkelvin`]."]
            #[inline]
            pub fn to_microkelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_MICROKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::microkelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::nanokelvin`]."]
            #[inline]
            pub fn to_nanokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_NANOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::nanokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::picokelvin`]."]
            #[inline]
            pub fn to_picokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_PICOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::picokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::femtokelvin`]."]
            #[inline]
            pub fn to_femtokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_FEMTOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::femtokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::attokelvin`]."]
            #[inline]
            pub fn to_attokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_ATTOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::attokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::zeptokelvin`]."]
            #[inline]
            pub fn to_zeptokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_ZEPTOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::zeptokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::yoctokelvin`]."]
            #[inline]
            pub fn to_yoctokelvin(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_YOCTOKELVIN_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::yoctokelvin,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::degree_celsius`]."]
            #[inline]
            pub fn to_degree_celsius(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_DEGREE_CELSIUS_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::degree_celsius,
                }
            }
            #[doc =
            "Convert to [`TemperatureIntervalUnit::degree_fahrenheit`]."]
            #[inline]
            pub fn to_degree_fahrenheit(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_DEGREE_FAHRENHEIT_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::degree_fahrenheit,
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::degree_rankine`]."]
            #[inline]
            pub fn to_degree_rankine(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TEMPERATUREINTERVAL_DEGREE_RANKINE_CONVERSION)) as f64,
                    unit: TemperatureIntervalUnit::degree_rankine,
                }
            }
        }
        impl FixedQuantity<TemperatureIntervalUnit> for TemperatureInterval {
            #[inline]
            fn unit(&self) -> TemperatureIntervalUnit { self.unit }
            #[inline]
            fn convert(&self, unit: TemperatureIntervalUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: TemperatureIntervalUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut TemperatureIntervalUnit {
                &mut self.unit
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: TemperatureIntervalUnit =
                    unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<TemperatureInterval> for UnitDefinition {
            #[inline]
            fn from(value: TemperatureInterval) -> Self {
                match value.unit {
                    TemperatureIntervalUnit::yottakelvin =>
                        TemperatureIntervalUnit::get_yottakelvin(),
                    TemperatureIntervalUnit::zettakelvin =>
                        TemperatureIntervalUnit::get_zettakelvin(),
                    TemperatureIntervalUnit::exakelvin =>
                        TemperatureIntervalUnit::get_exakelvin(),
                    TemperatureIntervalUnit::petakelvin =>
                        TemperatureIntervalUnit::get_petakelvin(),
                    TemperatureIntervalUnit::terakelvin =>
                        TemperatureIntervalUnit::get_terakelvin(),
                    TemperatureIntervalUnit::gigakelvin =>
                        TemperatureIntervalUnit::get_gigakelvin(),
                    TemperatureIntervalUnit::megakelvin =>
                        TemperatureIntervalUnit::get_megakelvin(),
                    TemperatureIntervalUnit::kilokelvin =>
                        TemperatureIntervalUnit::get_kilokelvin(),
                    TemperatureIntervalUnit::hectokelvin =>
                        TemperatureIntervalUnit::get_hectokelvin(),
                    TemperatureIntervalUnit::decakelvin =>
                        TemperatureIntervalUnit::get_decakelvin(),
                    TemperatureIntervalUnit::kelvin =>
                        TemperatureIntervalUnit::get_kelvin(),
                    TemperatureIntervalUnit::decikelvin =>
                        TemperatureIntervalUnit::get_decikelvin(),
                    TemperatureIntervalUnit::centikelvin =>
                        TemperatureIntervalUnit::get_centikelvin(),
                    TemperatureIntervalUnit::millikelvin =>
                        TemperatureIntervalUnit::get_millikelvin(),
                    TemperatureIntervalUnit::microkelvin =>
                        TemperatureIntervalUnit::get_microkelvin(),
                    TemperatureIntervalUnit::nanokelvin =>
                        TemperatureIntervalUnit::get_nanokelvin(),
                    TemperatureIntervalUnit::picokelvin =>
                        TemperatureIntervalUnit::get_picokelvin(),
                    TemperatureIntervalUnit::femtokelvin =>
                        TemperatureIntervalUnit::get_femtokelvin(),
                    TemperatureIntervalUnit::attokelvin =>
                        TemperatureIntervalUnit::get_attokelvin(),
                    TemperatureIntervalUnit::zeptokelvin =>
                        TemperatureIntervalUnit::get_zeptokelvin(),
                    TemperatureIntervalUnit::yoctokelvin =>
                        TemperatureIntervalUnit::get_yoctokelvin(),
                    TemperatureIntervalUnit::degree_celsius =>
                        TemperatureIntervalUnit::get_degree_celsius(),
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        TemperatureIntervalUnit::get_degree_fahrenheit(),
                    TemperatureIntervalUnit::degree_rankine =>
                        TemperatureIntervalUnit::get_degree_rankine(),
                }
            }
        }
        impl From<TemperatureInterval> for Quantity {
            fn from(quantity: TemperatureInterval) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for TemperatureInterval {
            fn from(quantity: Quantity) -> TemperatureInterval {
                TemperatureInterval {
                    value: quantity.value,
                    unit: TemperatureIntervalUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for TemperatureInterval {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl TemperatureIntervalVec {
            #[doc = "Create a new vector of [`TemperatureIntervalUnit`]."]
            pub fn new(values: Vec<f64>, unit: TemperatureIntervalUnit)
                -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc =
            "Retrieve values associated with this [`TemperatureIntervalSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`TemperatureIntervalSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::yottakelvin`]."]
            pub fn yottakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::yottakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::zettakelvin`]."]
            pub fn zettakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::zettakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::exakelvin`]."]
            pub fn exakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::exakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::petakelvin`]."]
            pub fn petakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::petakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::terakelvin`]."]
            pub fn terakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::terakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::gigakelvin`]."]
            pub fn gigakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::gigakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::megakelvin`]."]
            pub fn megakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::megakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::kilokelvin`]."]
            pub fn kilokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::kilokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::hectokelvin`]."]
            pub fn hectokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::hectokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::decakelvin`]."]
            pub fn decakelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::decakelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::kelvin`]."]
            pub fn kelvin(values: Vec<f64>) -> Self {
                Self { values, unit: TemperatureIntervalUnit::kelvin.into() }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::decikelvin`]."]
            pub fn decikelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::decikelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::centikelvin`]."]
            pub fn centikelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::centikelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::millikelvin`]."]
            pub fn millikelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::millikelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::microkelvin`]."]
            pub fn microkelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::microkelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::nanokelvin`]."]
            pub fn nanokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::nanokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::picokelvin`]."]
            pub fn picokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::picokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::femtokelvin`]."]
            pub fn femtokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::femtokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::attokelvin`]."]
            pub fn attokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::attokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::zeptokelvin`]."]
            pub fn zeptokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::zeptokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::yoctokelvin`]."]
            pub fn yoctokelvin(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::yoctokelvin.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::degree_celsius`]."]
            pub fn degree_celsius(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::degree_celsius.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::degree_fahrenheit`]."]
            pub fn degree_fahrenheit(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::degree_fahrenheit.into(),
                }
            }
            #[doc =
            "Create a new [`TemperatureInterval`] with units of [`TemperatureIntervalUnit::degree_rankine`]."]
            pub fn degree_rankine(values: Vec<f64>) -> Self {
                Self {
                    values,
                    unit: TemperatureIntervalUnit::degree_rankine.into(),
                }
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::yottakelvin`]."]
            #[inline]
            pub fn to_yottakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::yottakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::zettakelvin`]."]
            #[inline]
            pub fn to_zettakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::zettakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::exakelvin`]."]
            #[inline]
            pub fn to_exakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::exakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::petakelvin`]."]
            #[inline]
            pub fn to_petakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::petakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::terakelvin`]."]
            #[inline]
            pub fn to_terakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::terakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::gigakelvin`]."]
            #[inline]
            pub fn to_gigakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::gigakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::megakelvin`]."]
            #[inline]
            pub fn to_megakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::megakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::kilokelvin`]."]
            #[inline]
            pub fn to_kilokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::kilokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::hectokelvin`]."]
            #[inline]
            pub fn to_hectokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::hectokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::decakelvin`]."]
            #[inline]
            pub fn to_decakelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::decakelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::kelvin`]."]
            #[inline]
            pub fn to_kelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::kelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::decikelvin`]."]
            #[inline]
            pub fn to_decikelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::decikelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::centikelvin`]."]
            #[inline]
            pub fn to_centikelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::centikelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::millikelvin`]."]
            #[inline]
            pub fn to_millikelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::millikelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::microkelvin`]."]
            #[inline]
            pub fn to_microkelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::microkelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::nanokelvin`]."]
            #[inline]
            pub fn to_nanokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::nanokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::picokelvin`]."]
            #[inline]
            pub fn to_picokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::picokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::femtokelvin`]."]
            #[inline]
            pub fn to_femtokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::femtokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::attokelvin`]."]
            #[inline]
            pub fn to_attokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::attokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::zeptokelvin`]."]
            #[inline]
            pub fn to_zeptokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::zeptokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::yoctokelvin`]."]
            #[inline]
            pub fn to_yoctokelvin(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::yoctokelvin);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::degree_celsius`]."]
            #[inline]
            pub fn to_degree_celsius(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::degree_celsius);
                r
            }
            #[doc =
            "Convert to [`TemperatureIntervalUnit::degree_fahrenheit`]."]
            #[inline]
            pub fn to_degree_fahrenheit(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::degree_fahrenheit);
                r
            }
            #[doc = "Convert to [`TemperatureIntervalUnit::degree_rankine`]."]
            #[inline]
            pub fn to_degree_rankine(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TemperatureIntervalUnit::degree_rankine);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for TemperatureInterval {
            type Output = TemperatureInterval;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for TemperatureInterval {
            type Output = TemperatureInterval;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for TemperatureInterval {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for TemperatureInterval {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for TemperatureInterval {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<TemperatureInterval> for Quantity {
            fn eq(&self, other: &TemperatureInterval) -> bool {
                *other == *self
            }
        }
        impl PartialEq<TemperatureInterval> for TemperatureInterval {
            fn eq(&self, other: &TemperatureInterval) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for TemperatureInterval {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for TemperatureInterval {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<TemperatureInterval> for TemperatureInterval {
            type Output = Self;
            fn add(self, rhs: TemperatureInterval) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<TemperatureInterval> for TemperatureInterval {
            type Output = Self;
            fn sub(self, rhs: TemperatureInterval) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for TemperatureInterval {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for TemperatureInterval {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for TemperatureInterval {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for TemperatureInterval {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for TemperatureInterval {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for TemperatureInterval {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc =
        "Array storage for a series of values and [`TemperatureIntervalUnit`]."]
        pub struct TemperatureIntervalArray<const N : usize> {
            pub(crate) unit: TemperatureIntervalUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for
            TemperatureIntervalArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`TemperatureIntervalUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for TemperatureIntervalArray<N>
            {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TemperatureIntervalArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <TemperatureIntervalUnit as
                                        utoipa::PartialSchema>::schema())]);
                <TemperatureIntervalUnit as
                        utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for
                    TemperatureIntervalArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "TemperatureIntervalArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<TemperatureIntervalArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<TemperatureIntervalArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    TemperatureIntervalArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<TemperatureIntervalArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = TemperatureIntervalArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct TemperatureIntervalArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<TemperatureIntervalUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct TemperatureIntervalArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<TemperatureIntervalArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct TemperatureIntervalArray with 2 elements")),
                                    };
                                _serde::__private::Ok(TemperatureIntervalArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<TemperatureIntervalUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<TemperatureIntervalUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<TemperatureIntervalArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(TemperatureIntervalArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "TemperatureIntervalArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TemperatureIntervalArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for
            TemperatureIntervalArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for
            TemperatureIntervalArray<N> {
            #[inline]
            fn clone(&self) -> TemperatureIntervalArray<N> {
                let _:
                        ::core::clone::AssertParamIsClone<TemperatureIntervalUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for
            TemperatureIntervalArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "TemperatureIntervalArray", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            TemperatureIntervalArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for
            TemperatureIntervalArray<N> {
            #[inline]
            fn eq(&self, other: &TemperatureIntervalArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for TemperatureIntervalArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for TemperatureIntervalArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc =
        "Vector storage for a series of values and [`TemperatureIntervalUnit`]."]
        pub struct TemperatureIntervalVec {
            pub(crate) unit: TemperatureIntervalUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for TemperatureIntervalVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`TemperatureIntervalUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for TemperatureIntervalVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TemperatureIntervalVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                            res
                                        })),
                                <TemperatureIntervalUnit as
                                        utoipa::PartialSchema>::schema())]);
                <TemperatureIntervalUnit as
                        utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TemperatureIntervalVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "TemperatureIntervalVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TemperatureIntervalVec
                    {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TemperatureIntervalVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TemperatureIntervalVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct TemperatureIntervalVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<TemperatureIntervalUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct TemperatureIntervalVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct TemperatureIntervalVec with 2 elements")),
                                    };
                                _serde::__private::Ok(TemperatureIntervalVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<TemperatureIntervalUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<TemperatureIntervalUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(TemperatureIntervalVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "TemperatureIntervalVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TemperatureIntervalVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for TemperatureIntervalVec {
            #[inline]
            fn clone(&self) -> TemperatureIntervalVec {
                TemperatureIntervalVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TemperatureIntervalVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "TemperatureIntervalVec", "unit", &self.unit, "values",
                    &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TemperatureIntervalVec {
        }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TemperatureIntervalVec {
            #[inline]
            fn eq(&self, other: &TemperatureIntervalVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for TemperatureIntervalVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for TemperatureIntervalVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<TemperatureIntervalUnit, f64>
            for TemperatureIntervalVec {
            fn unit(&self) -> TemperatureIntervalUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: TemperatureIntervalUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: TemperatureIntervalUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: TemperatureIntervalUnit =
                    unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize>
            crate::traits::FixedSliceQuantity<TemperatureIntervalUnit, f64>
            for TemperatureIntervalArray<N> {
            fn unit(&self) -> TemperatureIntervalUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: TemperatureIntervalUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: TemperatureIntervalUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: TemperatureIntervalUnit =
                    unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for TemperatureIntervalVec {
            type Output = TemperatureIntervalVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for TemperatureIntervalVec {
            type Output = TemperatureIntervalVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for TemperatureIntervalVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for TemperatureIntervalVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<TemperatureIntervalVec> for TemperatureIntervalVec {
            fn add_assign(&mut self, rhs: TemperatureIntervalVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<TemperatureIntervalVec> for TemperatureIntervalVec {
            fn sub_assign(&mut self, rhs: TemperatureIntervalVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for TemperatureIntervalArray<N> {
            type Output = TemperatureIntervalArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for TemperatureIntervalArray<N> {
            type Output = TemperatureIntervalArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for TemperatureIntervalArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for TemperatureIntervalArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<TemperatureIntervalArray<N>> for
            TemperatureIntervalArray<N> {
            fn add_assign(&mut self, rhs: TemperatureIntervalArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<TemperatureIntervalArray<N>> for
            TemperatureIntervalArray<N> {
            fn sub_assign(&mut self, rhs: TemperatureIntervalArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<TemperatureIntervalVec> for VecQuantity {
            fn from(input: TemperatureIntervalVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<TemperatureIntervalUnit> for UnitDefinition {
            #[inline]
            fn from(value: TemperatureIntervalUnit) -> Self {
                match value {
                    TemperatureIntervalUnit::yottakelvin =>
                        TemperatureIntervalUnit::get_yottakelvin(),
                    TemperatureIntervalUnit::zettakelvin =>
                        TemperatureIntervalUnit::get_zettakelvin(),
                    TemperatureIntervalUnit::exakelvin =>
                        TemperatureIntervalUnit::get_exakelvin(),
                    TemperatureIntervalUnit::petakelvin =>
                        TemperatureIntervalUnit::get_petakelvin(),
                    TemperatureIntervalUnit::terakelvin =>
                        TemperatureIntervalUnit::get_terakelvin(),
                    TemperatureIntervalUnit::gigakelvin =>
                        TemperatureIntervalUnit::get_gigakelvin(),
                    TemperatureIntervalUnit::megakelvin =>
                        TemperatureIntervalUnit::get_megakelvin(),
                    TemperatureIntervalUnit::kilokelvin =>
                        TemperatureIntervalUnit::get_kilokelvin(),
                    TemperatureIntervalUnit::hectokelvin =>
                        TemperatureIntervalUnit::get_hectokelvin(),
                    TemperatureIntervalUnit::decakelvin =>
                        TemperatureIntervalUnit::get_decakelvin(),
                    TemperatureIntervalUnit::kelvin =>
                        TemperatureIntervalUnit::get_kelvin(),
                    TemperatureIntervalUnit::decikelvin =>
                        TemperatureIntervalUnit::get_decikelvin(),
                    TemperatureIntervalUnit::centikelvin =>
                        TemperatureIntervalUnit::get_centikelvin(),
                    TemperatureIntervalUnit::millikelvin =>
                        TemperatureIntervalUnit::get_millikelvin(),
                    TemperatureIntervalUnit::microkelvin =>
                        TemperatureIntervalUnit::get_microkelvin(),
                    TemperatureIntervalUnit::nanokelvin =>
                        TemperatureIntervalUnit::get_nanokelvin(),
                    TemperatureIntervalUnit::picokelvin =>
                        TemperatureIntervalUnit::get_picokelvin(),
                    TemperatureIntervalUnit::femtokelvin =>
                        TemperatureIntervalUnit::get_femtokelvin(),
                    TemperatureIntervalUnit::attokelvin =>
                        TemperatureIntervalUnit::get_attokelvin(),
                    TemperatureIntervalUnit::zeptokelvin =>
                        TemperatureIntervalUnit::get_zeptokelvin(),
                    TemperatureIntervalUnit::yoctokelvin =>
                        TemperatureIntervalUnit::get_yoctokelvin(),
                    TemperatureIntervalUnit::degree_celsius =>
                        TemperatureIntervalUnit::get_degree_celsius(),
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        TemperatureIntervalUnit::get_degree_fahrenheit(),
                    TemperatureIntervalUnit::degree_rankine =>
                        TemperatureIntervalUnit::get_degree_rankine(),
                }
            }
        }
        impl TryFrom<&str> for TemperatureIntervalUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<TemperatureIntervalUnit> =
                    match value {
                        "YK" => Some(TemperatureIntervalUnit::yottakelvin),
                        "ZK" => Some(TemperatureIntervalUnit::zettakelvin),
                        "EK" => Some(TemperatureIntervalUnit::exakelvin),
                        "PK" => Some(TemperatureIntervalUnit::petakelvin),
                        "TK" => Some(TemperatureIntervalUnit::terakelvin),
                        "GK" => Some(TemperatureIntervalUnit::gigakelvin),
                        "MK" => Some(TemperatureIntervalUnit::megakelvin),
                        "kK" => Some(TemperatureIntervalUnit::kilokelvin),
                        "hK" => Some(TemperatureIntervalUnit::hectokelvin),
                        "daK" => Some(TemperatureIntervalUnit::decakelvin),
                        "K" => Some(TemperatureIntervalUnit::kelvin),
                        "dK" => Some(TemperatureIntervalUnit::decikelvin),
                        "cK" => Some(TemperatureIntervalUnit::centikelvin),
                        "mK" => Some(TemperatureIntervalUnit::millikelvin),
                        "K" => Some(TemperatureIntervalUnit::microkelvin),
                        "nK" => Some(TemperatureIntervalUnit::nanokelvin),
                        "pK" => Some(TemperatureIntervalUnit::picokelvin),
                        "fK" => Some(TemperatureIntervalUnit::femtokelvin),
                        "aK" => Some(TemperatureIntervalUnit::attokelvin),
                        "zK" => Some(TemperatureIntervalUnit::zeptokelvin),
                        "yK" => Some(TemperatureIntervalUnit::yoctokelvin),
                        "C" => Some(TemperatureIntervalUnit::degree_celsius),
                        "F" => Some(TemperatureIntervalUnit::degree_fahrenheit),
                        "R" => Some(TemperatureIntervalUnit::degree_rankine),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<TemperatureIntervalUnit> =
                    match value {
                        "yottakelvin" => Some(TemperatureIntervalUnit::yottakelvin),
                        "zettakelvin" => Some(TemperatureIntervalUnit::zettakelvin),
                        "exakelvin" => Some(TemperatureIntervalUnit::exakelvin),
                        "petakelvin" => Some(TemperatureIntervalUnit::petakelvin),
                        "terakelvin" => Some(TemperatureIntervalUnit::terakelvin),
                        "gigakelvin" => Some(TemperatureIntervalUnit::gigakelvin),
                        "megakelvin" => Some(TemperatureIntervalUnit::megakelvin),
                        "kilokelvin" => Some(TemperatureIntervalUnit::kilokelvin),
                        "hectokelvin" => Some(TemperatureIntervalUnit::hectokelvin),
                        "decakelvin" => Some(TemperatureIntervalUnit::decakelvin),
                        "kelvin" => Some(TemperatureIntervalUnit::kelvin),
                        "decikelvin" => Some(TemperatureIntervalUnit::decikelvin),
                        "centikelvin" => Some(TemperatureIntervalUnit::centikelvin),
                        "millikelvin" => Some(TemperatureIntervalUnit::millikelvin),
                        "microkelvin" => Some(TemperatureIntervalUnit::microkelvin),
                        "nanokelvin" => Some(TemperatureIntervalUnit::nanokelvin),
                        "picokelvin" => Some(TemperatureIntervalUnit::picokelvin),
                        "femtokelvin" => Some(TemperatureIntervalUnit::femtokelvin),
                        "attokelvin" => Some(TemperatureIntervalUnit::attokelvin),
                        "zeptokelvin" => Some(TemperatureIntervalUnit::zeptokelvin),
                        "yoctokelvin" => Some(TemperatureIntervalUnit::yoctokelvin),
                        "degree Celsius" =>
                            Some(TemperatureIntervalUnit::degree_celsius),
                        "degree Fahrenheit" =>
                            Some(TemperatureIntervalUnit::degree_fahrenheit),
                        "degree Rankine" =>
                            Some(TemperatureIntervalUnit::degree_rankine),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<TemperatureIntervalUnit> =
                    match value {
                        "yottakelvins" =>
                            Some(TemperatureIntervalUnit::yottakelvin),
                        "zettakelvins" =>
                            Some(TemperatureIntervalUnit::zettakelvin),
                        "exakelvins" => Some(TemperatureIntervalUnit::exakelvin),
                        "petakelvins" => Some(TemperatureIntervalUnit::petakelvin),
                        "terakelvins" => Some(TemperatureIntervalUnit::terakelvin),
                        "gigakelvins" => Some(TemperatureIntervalUnit::gigakelvin),
                        "megakelvins" => Some(TemperatureIntervalUnit::megakelvin),
                        "kilokelvins" => Some(TemperatureIntervalUnit::kilokelvin),
                        "hectokelvins" =>
                            Some(TemperatureIntervalUnit::hectokelvin),
                        "decakelvins" => Some(TemperatureIntervalUnit::decakelvin),
                        "kelvins" => Some(TemperatureIntervalUnit::kelvin),
                        "decikelvins" => Some(TemperatureIntervalUnit::decikelvin),
                        "centikelvins" =>
                            Some(TemperatureIntervalUnit::centikelvin),
                        "millikelvins" =>
                            Some(TemperatureIntervalUnit::millikelvin),
                        "microkelvins" =>
                            Some(TemperatureIntervalUnit::microkelvin),
                        "nanokelvins" => Some(TemperatureIntervalUnit::nanokelvin),
                        "picokelvins" => Some(TemperatureIntervalUnit::picokelvin),
                        "femtokelvins" =>
                            Some(TemperatureIntervalUnit::femtokelvin),
                        "attokelvins" => Some(TemperatureIntervalUnit::attokelvin),
                        "zeptokelvins" =>
                            Some(TemperatureIntervalUnit::zeptokelvin),
                        "yoctokelvins" =>
                            Some(TemperatureIntervalUnit::yoctokelvin),
                        "degrees Celsius" =>
                            Some(TemperatureIntervalUnit::degree_celsius),
                        "degrees Fahrenheit" =>
                            Some(TemperatureIntervalUnit::degree_fahrenheit),
                        "degrees Rankine" =>
                            Some(TemperatureIntervalUnit::degree_rankine),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"TemperatureInterval\"")
                   }
            }
        }
        impl core::fmt::Display for TemperatureIntervalUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    TemperatureIntervalUnit::yottakelvin =>
                        f.write_fmt(format_args!("{0}", "yottakelvin")),
                    TemperatureIntervalUnit::zettakelvin =>
                        f.write_fmt(format_args!("{0}", "zettakelvin")),
                    TemperatureIntervalUnit::exakelvin =>
                        f.write_fmt(format_args!("{0}", "exakelvin")),
                    TemperatureIntervalUnit::petakelvin =>
                        f.write_fmt(format_args!("{0}", "petakelvin")),
                    TemperatureIntervalUnit::terakelvin =>
                        f.write_fmt(format_args!("{0}", "terakelvin")),
                    TemperatureIntervalUnit::gigakelvin =>
                        f.write_fmt(format_args!("{0}", "gigakelvin")),
                    TemperatureIntervalUnit::megakelvin =>
                        f.write_fmt(format_args!("{0}", "megakelvin")),
                    TemperatureIntervalUnit::kilokelvin =>
                        f.write_fmt(format_args!("{0}", "kilokelvin")),
                    TemperatureIntervalUnit::hectokelvin =>
                        f.write_fmt(format_args!("{0}", "hectokelvin")),
                    TemperatureIntervalUnit::decakelvin =>
                        f.write_fmt(format_args!("{0}", "decakelvin")),
                    TemperatureIntervalUnit::kelvin =>
                        f.write_fmt(format_args!("{0}", "kelvin")),
                    TemperatureIntervalUnit::decikelvin =>
                        f.write_fmt(format_args!("{0}", "decikelvin")),
                    TemperatureIntervalUnit::centikelvin =>
                        f.write_fmt(format_args!("{0}", "centikelvin")),
                    TemperatureIntervalUnit::millikelvin =>
                        f.write_fmt(format_args!("{0}", "millikelvin")),
                    TemperatureIntervalUnit::microkelvin =>
                        f.write_fmt(format_args!("{0}", "microkelvin")),
                    TemperatureIntervalUnit::nanokelvin =>
                        f.write_fmt(format_args!("{0}", "nanokelvin")),
                    TemperatureIntervalUnit::picokelvin =>
                        f.write_fmt(format_args!("{0}", "picokelvin")),
                    TemperatureIntervalUnit::femtokelvin =>
                        f.write_fmt(format_args!("{0}", "femtokelvin")),
                    TemperatureIntervalUnit::attokelvin =>
                        f.write_fmt(format_args!("{0}", "attokelvin")),
                    TemperatureIntervalUnit::zeptokelvin =>
                        f.write_fmt(format_args!("{0}", "zeptokelvin")),
                    TemperatureIntervalUnit::yoctokelvin =>
                        f.write_fmt(format_args!("{0}", "yoctokelvin")),
                    TemperatureIntervalUnit::degree_celsius =>
                        f.write_fmt(format_args!("{0}", "degree Celsius")),
                    TemperatureIntervalUnit::degree_fahrenheit =>
                        f.write_fmt(format_args!("{0}", "degree Fahrenheit")),
                    TemperatureIntervalUnit::degree_rankine =>
                        f.write_fmt(format_args!("{0}", "degree Rankine")),
                }
            }
        }
    }
    #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
    pub use crate::unit_definitions::temperature_interval::TemperatureIntervalArray;
    #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
    pub use crate::unit_definitions::temperature_interval::TemperatureInterval;
    #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
    pub use crate::unit_definitions::temperature_interval::TemperatureIntervalVec;
    #[cfg(any(feature = "Time", feature = "All"))]
    mod time {
        //! Time (base UnitDefinition second, s).
        use crate::{prefix, quantity};
        #[cfg(feature = "utoipa")]
        use utoipa::{ToSchema, schema};
        use crate::errors::RuntimeUnitError;
        use crate::Quantity;
        use crate::units_base::{UnitDefinition, UnitBase};
        #[doc = r" Time (base UnitDefinition second, s)."]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        #[schema(title = "TimeUnit")]
        pub enum TimeUnit {
            yottasecond,
            zettasecond,
            exasecond,
            petasecond,
            terasecond,
            gigasecond,
            megasecond,
            kilosecond,
            hectosecond,
            decasecond,
            second,
            decisecond,
            centisecond,
            millisecond,
            microsecond,
            nanosecond,
            picosecond,
            femtosecond,
            attosecond,
            zeptosecond,
            yoctosecond,
            second_sidereal,
            day,
            day_sidereal,
            hour,
            hour_sidereal,
            minute,
            shake,
            year,
            year_sidereal,
            year_tropical,
        }
        impl utoipa::__dev::ComposeSchema for TimeUnit {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                utoipa::openapi::schema::Object::builder().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::String)).enum_values::<[&str; 31usize],
                                &str>(Some(["yottasecond", "zettasecond", "exasecond",
                                            "petasecond", "terasecond", "gigasecond", "megasecond",
                                            "kilosecond", "hectosecond", "decasecond", "second",
                                            "decisecond", "centisecond", "millisecond", "microsecond",
                                            "nanosecond", "picosecond", "femtosecond", "attosecond",
                                            "zeptosecond", "yoctosecond", "second_sidereal", "day",
                                            "day_sidereal", "hour", "hour_sidereal", "minute", "shake",
                                            "year", "year_sidereal",
                                            "year_tropical"])).title(Some("TimeUnit")).description(Some("Time (base UnitDefinition second, s).")).into()
            }
        }
        impl utoipa::ToSchema for TimeUnit {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TimeUnit")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([]);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TimeUnit {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            TimeUnit::yottasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 0u32, "yottasecond"),
                            TimeUnit::zettasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 1u32, "zettasecond"),
                            TimeUnit::exasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 2u32, "exasecond"),
                            TimeUnit::petasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 3u32, "petasecond"),
                            TimeUnit::terasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 4u32, "terasecond"),
                            TimeUnit::gigasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 5u32, "gigasecond"),
                            TimeUnit::megasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 6u32, "megasecond"),
                            TimeUnit::kilosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 7u32, "kilosecond"),
                            TimeUnit::hectosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 8u32, "hectosecond"),
                            TimeUnit::decasecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 9u32, "decasecond"),
                            TimeUnit::second =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 10u32, "second"),
                            TimeUnit::decisecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 11u32, "decisecond"),
                            TimeUnit::centisecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 12u32, "centisecond"),
                            TimeUnit::millisecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 13u32, "millisecond"),
                            TimeUnit::microsecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 14u32, "microsecond"),
                            TimeUnit::nanosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 15u32, "nanosecond"),
                            TimeUnit::picosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 16u32, "picosecond"),
                            TimeUnit::femtosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 17u32, "femtosecond"),
                            TimeUnit::attosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 18u32, "attosecond"),
                            TimeUnit::zeptosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 19u32, "zeptosecond"),
                            TimeUnit::yoctosecond =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 20u32, "yoctosecond"),
                            TimeUnit::second_sidereal =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 21u32, "second_sidereal"),
                            TimeUnit::day =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 22u32, "day"),
                            TimeUnit::day_sidereal =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 23u32, "day_sidereal"),
                            TimeUnit::hour =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 24u32, "hour"),
                            TimeUnit::hour_sidereal =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 25u32, "hour_sidereal"),
                            TimeUnit::minute =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 26u32, "minute"),
                            TimeUnit::shake =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 27u32, "shake"),
                            TimeUnit::year =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 28u32, "year"),
                            TimeUnit::year_sidereal =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 29u32, "year_sidereal"),
                            TimeUnit::year_tropical =>
                                _serde::Serializer::serialize_unit_variant(__serializer,
                                    "TimeUnit", 30u32, "year_tropical"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TimeUnit {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                            __field24,
                            __field25,
                            __field26,
                            __field27,
                            __field28,
                            __field29,
                            __field30,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    17u64 => _serde::__private::Ok(__Field::__field17),
                                    18u64 => _serde::__private::Ok(__Field::__field18),
                                    19u64 => _serde::__private::Ok(__Field::__field19),
                                    20u64 => _serde::__private::Ok(__Field::__field20),
                                    21u64 => _serde::__private::Ok(__Field::__field21),
                                    22u64 => _serde::__private::Ok(__Field::__field22),
                                    23u64 => _serde::__private::Ok(__Field::__field23),
                                    24u64 => _serde::__private::Ok(__Field::__field24),
                                    25u64 => _serde::__private::Ok(__Field::__field25),
                                    26u64 => _serde::__private::Ok(__Field::__field26),
                                    27u64 => _serde::__private::Ok(__Field::__field27),
                                    28u64 => _serde::__private::Ok(__Field::__field28),
                                    29u64 => _serde::__private::Ok(__Field::__field29),
                                    30u64 => _serde::__private::Ok(__Field::__field30),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 31")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "yottasecond" => _serde::__private::Ok(__Field::__field0),
                                    "zettasecond" => _serde::__private::Ok(__Field::__field1),
                                    "exasecond" => _serde::__private::Ok(__Field::__field2),
                                    "petasecond" => _serde::__private::Ok(__Field::__field3),
                                    "terasecond" => _serde::__private::Ok(__Field::__field4),
                                    "gigasecond" => _serde::__private::Ok(__Field::__field5),
                                    "megasecond" => _serde::__private::Ok(__Field::__field6),
                                    "kilosecond" => _serde::__private::Ok(__Field::__field7),
                                    "hectosecond" => _serde::__private::Ok(__Field::__field8),
                                    "decasecond" => _serde::__private::Ok(__Field::__field9),
                                    "second" => _serde::__private::Ok(__Field::__field10),
                                    "decisecond" => _serde::__private::Ok(__Field::__field11),
                                    "centisecond" => _serde::__private::Ok(__Field::__field12),
                                    "millisecond" => _serde::__private::Ok(__Field::__field13),
                                    "microsecond" => _serde::__private::Ok(__Field::__field14),
                                    "nanosecond" => _serde::__private::Ok(__Field::__field15),
                                    "picosecond" => _serde::__private::Ok(__Field::__field16),
                                    "femtosecond" => _serde::__private::Ok(__Field::__field17),
                                    "attosecond" => _serde::__private::Ok(__Field::__field18),
                                    "zeptosecond" => _serde::__private::Ok(__Field::__field19),
                                    "yoctosecond" => _serde::__private::Ok(__Field::__field20),
                                    "second_sidereal" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    "day" => _serde::__private::Ok(__Field::__field22),
                                    "day_sidereal" => _serde::__private::Ok(__Field::__field23),
                                    "hour" => _serde::__private::Ok(__Field::__field24),
                                    "hour_sidereal" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    "minute" => _serde::__private::Ok(__Field::__field26),
                                    "shake" => _serde::__private::Ok(__Field::__field27),
                                    "year" => _serde::__private::Ok(__Field::__field28),
                                    "year_sidereal" =>
                                        _serde::__private::Ok(__Field::__field29),
                                    "year_tropical" =>
                                        _serde::__private::Ok(__Field::__field30),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"yottasecond" => _serde::__private::Ok(__Field::__field0),
                                    b"zettasecond" => _serde::__private::Ok(__Field::__field1),
                                    b"exasecond" => _serde::__private::Ok(__Field::__field2),
                                    b"petasecond" => _serde::__private::Ok(__Field::__field3),
                                    b"terasecond" => _serde::__private::Ok(__Field::__field4),
                                    b"gigasecond" => _serde::__private::Ok(__Field::__field5),
                                    b"megasecond" => _serde::__private::Ok(__Field::__field6),
                                    b"kilosecond" => _serde::__private::Ok(__Field::__field7),
                                    b"hectosecond" => _serde::__private::Ok(__Field::__field8),
                                    b"decasecond" => _serde::__private::Ok(__Field::__field9),
                                    b"second" => _serde::__private::Ok(__Field::__field10),
                                    b"decisecond" => _serde::__private::Ok(__Field::__field11),
                                    b"centisecond" => _serde::__private::Ok(__Field::__field12),
                                    b"millisecond" => _serde::__private::Ok(__Field::__field13),
                                    b"microsecond" => _serde::__private::Ok(__Field::__field14),
                                    b"nanosecond" => _serde::__private::Ok(__Field::__field15),
                                    b"picosecond" => _serde::__private::Ok(__Field::__field16),
                                    b"femtosecond" => _serde::__private::Ok(__Field::__field17),
                                    b"attosecond" => _serde::__private::Ok(__Field::__field18),
                                    b"zeptosecond" => _serde::__private::Ok(__Field::__field19),
                                    b"yoctosecond" => _serde::__private::Ok(__Field::__field20),
                                    b"second_sidereal" =>
                                        _serde::__private::Ok(__Field::__field21),
                                    b"day" => _serde::__private::Ok(__Field::__field22),
                                    b"day_sidereal" =>
                                        _serde::__private::Ok(__Field::__field23),
                                    b"hour" => _serde::__private::Ok(__Field::__field24),
                                    b"hour_sidereal" =>
                                        _serde::__private::Ok(__Field::__field25),
                                    b"minute" => _serde::__private::Ok(__Field::__field26),
                                    b"shake" => _serde::__private::Ok(__Field::__field27),
                                    b"year" => _serde::__private::Ok(__Field::__field28),
                                    b"year_sidereal" =>
                                        _serde::__private::Ok(__Field::__field29),
                                    b"year_tropical" =>
                                        _serde::__private::Ok(__Field::__field30),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TimeUnit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TimeUnit;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum TimeUnit")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::yottasecond)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::zettasecond)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::exasecond)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::petasecond)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::terasecond)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::gigasecond)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::megasecond)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::kilosecond)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::hectosecond)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::decasecond)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::second)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::decisecond)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::centisecond)
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::millisecond)
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::microsecond)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::nanosecond)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::picosecond)
                                    }
                                    (__Field::__field17, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::femtosecond)
                                    }
                                    (__Field::__field18, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::attosecond)
                                    }
                                    (__Field::__field19, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::zeptosecond)
                                    }
                                    (__Field::__field20, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::yoctosecond)
                                    }
                                    (__Field::__field21, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::second_sidereal)
                                    }
                                    (__Field::__field22, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::day)
                                    }
                                    (__Field::__field23, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::day_sidereal)
                                    }
                                    (__Field::__field24, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::hour)
                                    }
                                    (__Field::__field25, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::hour_sidereal)
                                    }
                                    (__Field::__field26, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::minute)
                                    }
                                    (__Field::__field27, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::shake)
                                    }
                                    (__Field::__field28, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::year)
                                    }
                                    (__Field::__field29, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::year_sidereal)
                                    }
                                    (__Field::__field30, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TimeUnit::year_tropical)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["yottasecond", "zettasecond", "exasecond", "petasecond",
                                        "terasecond", "gigasecond", "megasecond", "kilosecond",
                                        "hectosecond", "decasecond", "second", "decisecond",
                                        "centisecond", "millisecond", "microsecond", "nanosecond",
                                        "picosecond", "femtosecond", "attosecond", "zeptosecond",
                                        "yoctosecond", "second_sidereal", "day", "day_sidereal",
                                        "hour", "hour_sidereal", "minute", "shake", "year",
                                        "year_sidereal", "year_tropical"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "TimeUnit", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TimeUnit>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::Copy for TimeUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::clone::Clone for TimeUnit {
            #[inline]
            fn clone(&self) -> TimeUnit { *self }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::fmt::Debug for TimeUnit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        TimeUnit::yottasecond => "yottasecond",
                        TimeUnit::zettasecond => "zettasecond",
                        TimeUnit::exasecond => "exasecond",
                        TimeUnit::petasecond => "petasecond",
                        TimeUnit::terasecond => "terasecond",
                        TimeUnit::gigasecond => "gigasecond",
                        TimeUnit::megasecond => "megasecond",
                        TimeUnit::kilosecond => "kilosecond",
                        TimeUnit::hectosecond => "hectosecond",
                        TimeUnit::decasecond => "decasecond",
                        TimeUnit::second => "second",
                        TimeUnit::decisecond => "decisecond",
                        TimeUnit::centisecond => "centisecond",
                        TimeUnit::millisecond => "millisecond",
                        TimeUnit::microsecond => "microsecond",
                        TimeUnit::nanosecond => "nanosecond",
                        TimeUnit::picosecond => "picosecond",
                        TimeUnit::femtosecond => "femtosecond",
                        TimeUnit::attosecond => "attosecond",
                        TimeUnit::zeptosecond => "zeptosecond",
                        TimeUnit::yoctosecond => "yoctosecond",
                        TimeUnit::second_sidereal => "second_sidereal",
                        TimeUnit::day => "day",
                        TimeUnit::day_sidereal => "day_sidereal",
                        TimeUnit::hour => "hour",
                        TimeUnit::hour_sidereal => "hour_sidereal",
                        TimeUnit::minute => "minute",
                        TimeUnit::shake => "shake",
                        TimeUnit::year => "year",
                        TimeUnit::year_sidereal => "year_sidereal",
                        TimeUnit::year_tropical => "year_tropical",
                    })
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::marker::StructuralPartialEq for TimeUnit { }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::PartialEq for TimeUnit {
            #[inline]
            fn eq(&self, other: &TimeUnit) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::cmp::Eq for TimeUnit {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(non_camel_case_types)]
        #[allow(clippy :: eq_op)]
        impl ::core::hash::Hash for TimeUnit {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        pub(crate) const TIME_UNIT_BASE: UnitBase =
            crate::units_base::UOMDimensions::to_unit_base((crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::P1,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0,
                    crate::units_base::UOMDimensions::Z0));
        pub(crate) const TIME_YOTTASECOND_CONVERSION: f64 = 1.0_E24;
        pub(crate) const TIME_ZETTASECOND_CONVERSION: f64 = 1.0_E21;
        pub(crate) const TIME_EXASECOND_CONVERSION: f64 = 1.0_E18;
        pub(crate) const TIME_PETASECOND_CONVERSION: f64 = 1.0_E15;
        pub(crate) const TIME_TERASECOND_CONVERSION: f64 = 1.0_E12;
        pub(crate) const TIME_GIGASECOND_CONVERSION: f64 = 1.0_E9;
        pub(crate) const TIME_MEGASECOND_CONVERSION: f64 = 1.0_E6;
        pub(crate) const TIME_KILOSECOND_CONVERSION: f64 = 1.0_E3;
        pub(crate) const TIME_HECTOSECOND_CONVERSION: f64 = 1.0_E2;
        pub(crate) const TIME_DECASECOND_CONVERSION: f64 = 1.0_E1;
        pub(crate) const TIME_SECOND_CONVERSION: f64 = 1.0_E0;
        pub(crate) const TIME_DECISECOND_CONVERSION: f64 = 1.0_E-1;
        pub(crate) const TIME_CENTISECOND_CONVERSION: f64 = 1.0_E-2;
        pub(crate) const TIME_MILLISECOND_CONVERSION: f64 = 1.0_E-3;
        pub(crate) const TIME_MICROSECOND_CONVERSION: f64 = 1.0_E-6;
        pub(crate) const TIME_NANOSECOND_CONVERSION: f64 = 1.0_E-9;
        pub(crate) const TIME_PICOSECOND_CONVERSION: f64 = 1.0_E-12;
        pub(crate) const TIME_FEMTOSECOND_CONVERSION: f64 = 1.0_E-15;
        pub(crate) const TIME_ATTOSECOND_CONVERSION: f64 = 1.0_E-18;
        pub(crate) const TIME_ZEPTOSECOND_CONVERSION: f64 = 1.0_E-21;
        pub(crate) const TIME_YOCTOSECOND_CONVERSION: f64 = 1.0_E-24;
        pub(crate) const TIME_SECOND_SIDEREAL_CONVERSION: f64 = 9.972_696_E-1;
        pub(crate) const TIME_DAY_CONVERSION: f64 = 8.64_E4;
        pub(crate) const TIME_DAY_SIDEREAL_CONVERSION: f64 = 8.616_409_E4;
        pub(crate) const TIME_HOUR_CONVERSION: f64 = 3.6_E3;
        pub(crate) const TIME_HOUR_SIDEREAL_CONVERSION: f64 = 3.590_170_E3;
        pub(crate) const TIME_MINUTE_CONVERSION: f64 = 6.0_E1;
        pub(crate) const TIME_SHAKE_CONVERSION: f64 = 1.0_E-8;
        pub(crate) const TIME_YEAR_CONVERSION: f64 = 3.1536_E7;
        pub(crate) const TIME_YEAR_SIDEREAL_CONVERSION: f64 = 3.155_815_E7;
        pub(crate) const TIME_YEAR_TROPICAL_CONVERSION: f64 = 3.155_693_E7;
        impl TimeUnit {
            #[allow(clippy :: eq_op)]
            pub fn get_yottasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_YOTTASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zettasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_ZETTASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_exasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_EXASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_petasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_PETASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_terasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_TERASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_gigasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_GIGASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_megasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_MEGASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_kilosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_KILOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hectosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_HECTOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decasecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_DECASECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_second() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_SECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_decisecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_DECISECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_centisecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_CENTISECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_millisecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_MILLISECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_microsecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_MICROSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_nanosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_NANOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_picosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_PICOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_femtosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_FEMTOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_attosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_ATTOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_zeptosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_ZEPTOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_yoctosecond() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_YOCTOSECOND_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_second_sidereal() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_SECOND_SIDEREAL_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_day() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_DAY_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_day_sidereal() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_DAY_SIDEREAL_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hour() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_HOUR_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_hour_sidereal() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_HOUR_SIDEREAL_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_minute() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_MINUTE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_shake() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_SHAKE_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_year() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_YEAR_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_year_sidereal() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_YEAR_SIDEREAL_CONVERSION,
                }
            }
            #[allow(clippy :: eq_op)]
            pub fn get_year_tropical() -> UnitDefinition {
                UnitDefinition {
                    base: TIME_UNIT_BASE,
                    multiplier: TIME_YEAR_TROPICAL_CONVERSION,
                }
            }
            #[doc = "Multiplier of unit to its base quantity."]
            #[allow(clippy :: eq_op)]
            pub fn multiplier(&self) -> f64 {
                match self {
                    TimeUnit::yottasecond => TIME_YOTTASECOND_CONVERSION,
                    TimeUnit::zettasecond => TIME_ZETTASECOND_CONVERSION,
                    TimeUnit::exasecond => TIME_EXASECOND_CONVERSION,
                    TimeUnit::petasecond => TIME_PETASECOND_CONVERSION,
                    TimeUnit::terasecond => TIME_TERASECOND_CONVERSION,
                    TimeUnit::gigasecond => TIME_GIGASECOND_CONVERSION,
                    TimeUnit::megasecond => TIME_MEGASECOND_CONVERSION,
                    TimeUnit::kilosecond => TIME_KILOSECOND_CONVERSION,
                    TimeUnit::hectosecond => TIME_HECTOSECOND_CONVERSION,
                    TimeUnit::decasecond => TIME_DECASECOND_CONVERSION,
                    TimeUnit::second => TIME_SECOND_CONVERSION,
                    TimeUnit::decisecond => TIME_DECISECOND_CONVERSION,
                    TimeUnit::centisecond => TIME_CENTISECOND_CONVERSION,
                    TimeUnit::millisecond => TIME_MILLISECOND_CONVERSION,
                    TimeUnit::microsecond => TIME_MICROSECOND_CONVERSION,
                    TimeUnit::nanosecond => TIME_NANOSECOND_CONVERSION,
                    TimeUnit::picosecond => TIME_PICOSECOND_CONVERSION,
                    TimeUnit::femtosecond => TIME_FEMTOSECOND_CONVERSION,
                    TimeUnit::attosecond => TIME_ATTOSECOND_CONVERSION,
                    TimeUnit::zeptosecond => TIME_ZEPTOSECOND_CONVERSION,
                    TimeUnit::yoctosecond => TIME_YOCTOSECOND_CONVERSION,
                    TimeUnit::second_sidereal =>
                        TIME_SECOND_SIDEREAL_CONVERSION,
                    TimeUnit::day => TIME_DAY_CONVERSION,
                    TimeUnit::day_sidereal => TIME_DAY_SIDEREAL_CONVERSION,
                    TimeUnit::hour => TIME_HOUR_CONVERSION,
                    TimeUnit::hour_sidereal => TIME_HOUR_SIDEREAL_CONVERSION,
                    TimeUnit::minute => TIME_MINUTE_CONVERSION,
                    TimeUnit::shake => TIME_SHAKE_CONVERSION,
                    TimeUnit::year => TIME_YEAR_CONVERSION,
                    TimeUnit::year_sidereal => TIME_YEAR_SIDEREAL_CONVERSION,
                    TimeUnit::year_tropical => TIME_YEAR_TROPICAL_CONVERSION,
                }
            }
            #[doc = "Abbreviation of unit."]
            pub fn abbreviation(&self) -> &'static str {
                match self {
                    TimeUnit::yottasecond => "Ys",
                    TimeUnit::zettasecond => "Zs",
                    TimeUnit::exasecond => "Es",
                    TimeUnit::petasecond => "Ps",
                    TimeUnit::terasecond => "Ts",
                    TimeUnit::gigasecond => "Gs",
                    TimeUnit::megasecond => "Ms",
                    TimeUnit::kilosecond => "ks",
                    TimeUnit::hectosecond => "hs",
                    TimeUnit::decasecond => "das",
                    TimeUnit::second => "s",
                    TimeUnit::decisecond => "ds",
                    TimeUnit::centisecond => "cs",
                    TimeUnit::millisecond => "ms",
                    TimeUnit::microsecond => "s",
                    TimeUnit::nanosecond => "ns",
                    TimeUnit::picosecond => "ps",
                    TimeUnit::femtosecond => "fs",
                    TimeUnit::attosecond => "as",
                    TimeUnit::zeptosecond => "zs",
                    TimeUnit::yoctosecond => "ys",
                    TimeUnit::second_sidereal => "s (sidereal)",
                    TimeUnit::day => "d",
                    TimeUnit::day_sidereal => "d (sidereal)",
                    TimeUnit::hour => "h",
                    TimeUnit::hour_sidereal => "h (sidereal)",
                    TimeUnit::minute => "min",
                    TimeUnit::shake => "10.0 ns",
                    TimeUnit::year => "a",
                    TimeUnit::year_sidereal => "a (sidereal)",
                    TimeUnit::year_tropical => "a (tropical)",
                }
            }
            #[doc = "Singular name of unit."]
            pub fn singular(&self) -> &'static str {
                match self {
                    TimeUnit::yottasecond => "yottasecond",
                    TimeUnit::zettasecond => "zettasecond",
                    TimeUnit::exasecond => "exasecond",
                    TimeUnit::petasecond => "petasecond",
                    TimeUnit::terasecond => "terasecond",
                    TimeUnit::gigasecond => "gigasecond",
                    TimeUnit::megasecond => "megasecond",
                    TimeUnit::kilosecond => "kilosecond",
                    TimeUnit::hectosecond => "hectosecond",
                    TimeUnit::decasecond => "decasecond",
                    TimeUnit::second => "second",
                    TimeUnit::decisecond => "decisecond",
                    TimeUnit::centisecond => "centisecond",
                    TimeUnit::millisecond => "millisecond",
                    TimeUnit::microsecond => "microsecond",
                    TimeUnit::nanosecond => "nanosecond",
                    TimeUnit::picosecond => "picosecond",
                    TimeUnit::femtosecond => "femtosecond",
                    TimeUnit::attosecond => "attosecond",
                    TimeUnit::zeptosecond => "zeptosecond",
                    TimeUnit::yoctosecond => "yoctosecond",
                    TimeUnit::second_sidereal => "second (sidereal)",
                    TimeUnit::day => "day",
                    TimeUnit::day_sidereal => "day (sidereal)",
                    TimeUnit::hour => "hour",
                    TimeUnit::hour_sidereal => "hour (sidereal)",
                    TimeUnit::minute => "minute",
                    TimeUnit::shake => "shake",
                    TimeUnit::year => "year",
                    TimeUnit::year_sidereal => "year (sidereal)",
                    TimeUnit::year_tropical => "year (tropical)",
                }
            }
            #[doc = "Plural name of unit."]
            pub fn plural(&self) -> &'static str {
                match self {
                    TimeUnit::yottasecond => "yottaseconds",
                    TimeUnit::zettasecond => "zettaseconds",
                    TimeUnit::exasecond => "exaseconds",
                    TimeUnit::petasecond => "petaseconds",
                    TimeUnit::terasecond => "teraseconds",
                    TimeUnit::gigasecond => "gigaseconds",
                    TimeUnit::megasecond => "megaseconds",
                    TimeUnit::kilosecond => "kiloseconds",
                    TimeUnit::hectosecond => "hectoseconds",
                    TimeUnit::decasecond => "decaseconds",
                    TimeUnit::second => "seconds",
                    TimeUnit::decisecond => "deciseconds",
                    TimeUnit::centisecond => "centiseconds",
                    TimeUnit::millisecond => "milliseconds",
                    TimeUnit::microsecond => "microseconds",
                    TimeUnit::nanosecond => "nanoseconds",
                    TimeUnit::picosecond => "picoseconds",
                    TimeUnit::femtosecond => "femtoseconds",
                    TimeUnit::attosecond => "attoseconds",
                    TimeUnit::zeptosecond => "zeptoseconds",
                    TimeUnit::yoctosecond => "yoctoseconds",
                    TimeUnit::second_sidereal => "seconds (sidereal)",
                    TimeUnit::day => "days",
                    TimeUnit::day_sidereal => "days (sidereal)",
                    TimeUnit::hour => "hours",
                    TimeUnit::hour_sidereal => "hours (sidereal)",
                    TimeUnit::minute => "minutes",
                    TimeUnit::shake => "shakes",
                    TimeUnit::year => "years",
                    TimeUnit::year_sidereal => "years (sidereal)",
                    TimeUnit::year_tropical => "years (tropical)",
                }
            }
            #[doc = "Available units for this `[TimeUnit`]."]
            pub fn units() -> &'static [&'static str] {
                const UNITS: &[&'static str] =
                    &["yottasecond", "zettasecond", "exasecond", "petasecond",
                                "terasecond", "gigasecond", "megasecond", "kilosecond",
                                "hectosecond", "decasecond", "second", "decisecond",
                                "centisecond", "millisecond", "microsecond", "nanosecond",
                                "picosecond", "femtosecond", "attosecond", "zeptosecond",
                                "yoctosecond", "second (sidereal)", "day", "day (sidereal)",
                                "hour", "hour (sidereal)", "minute", "shake", "year",
                                "year (sidereal)", "year (tropical)"];
                UNITS
            }
        }
        impl crate::traits::Unit for TimeUnit {
            #[doc =
            " Return unit definition for this Unit Type                "]
            fn definition(&self) -> UnitDefinition {
                match self {
                    TimeUnit::yottasecond => TimeUnit::get_yottasecond(),
                    TimeUnit::zettasecond => TimeUnit::get_zettasecond(),
                    TimeUnit::exasecond => TimeUnit::get_exasecond(),
                    TimeUnit::petasecond => TimeUnit::get_petasecond(),
                    TimeUnit::terasecond => TimeUnit::get_terasecond(),
                    TimeUnit::gigasecond => TimeUnit::get_gigasecond(),
                    TimeUnit::megasecond => TimeUnit::get_megasecond(),
                    TimeUnit::kilosecond => TimeUnit::get_kilosecond(),
                    TimeUnit::hectosecond => TimeUnit::get_hectosecond(),
                    TimeUnit::decasecond => TimeUnit::get_decasecond(),
                    TimeUnit::second => TimeUnit::get_second(),
                    TimeUnit::decisecond => TimeUnit::get_decisecond(),
                    TimeUnit::centisecond => TimeUnit::get_centisecond(),
                    TimeUnit::millisecond => TimeUnit::get_millisecond(),
                    TimeUnit::microsecond => TimeUnit::get_microsecond(),
                    TimeUnit::nanosecond => TimeUnit::get_nanosecond(),
                    TimeUnit::picosecond => TimeUnit::get_picosecond(),
                    TimeUnit::femtosecond => TimeUnit::get_femtosecond(),
                    TimeUnit::attosecond => TimeUnit::get_attosecond(),
                    TimeUnit::zeptosecond => TimeUnit::get_zeptosecond(),
                    TimeUnit::yoctosecond => TimeUnit::get_yoctosecond(),
                    TimeUnit::second_sidereal =>
                        TimeUnit::get_second_sidereal(),
                    TimeUnit::day => TimeUnit::get_day(),
                    TimeUnit::day_sidereal => TimeUnit::get_day_sidereal(),
                    TimeUnit::hour => TimeUnit::get_hour(),
                    TimeUnit::hour_sidereal => TimeUnit::get_hour_sidereal(),
                    TimeUnit::minute => TimeUnit::get_minute(),
                    TimeUnit::shake => TimeUnit::get_shake(),
                    TimeUnit::year => TimeUnit::get_year(),
                    TimeUnit::year_sidereal => TimeUnit::get_year_sidereal(),
                    TimeUnit::year_tropical => TimeUnit::get_year_tropical(),
                }
            }
            #[inline]
            fn base() -> UnitBase { TIME_UNIT_BASE }
        }
        impl From<TimeUnit> for crate::Units {
            fn from(value: TimeUnit) -> Self {
                match value {
                    TimeUnit::yottasecond =>
                        crate::Units::Time(TimeUnit::yottasecond),
                    TimeUnit::zettasecond =>
                        crate::Units::Time(TimeUnit::zettasecond),
                    TimeUnit::exasecond =>
                        crate::Units::Time(TimeUnit::exasecond),
                    TimeUnit::petasecond =>
                        crate::Units::Time(TimeUnit::petasecond),
                    TimeUnit::terasecond =>
                        crate::Units::Time(TimeUnit::terasecond),
                    TimeUnit::gigasecond =>
                        crate::Units::Time(TimeUnit::gigasecond),
                    TimeUnit::megasecond =>
                        crate::Units::Time(TimeUnit::megasecond),
                    TimeUnit::kilosecond =>
                        crate::Units::Time(TimeUnit::kilosecond),
                    TimeUnit::hectosecond =>
                        crate::Units::Time(TimeUnit::hectosecond),
                    TimeUnit::decasecond =>
                        crate::Units::Time(TimeUnit::decasecond),
                    TimeUnit::second => crate::Units::Time(TimeUnit::second),
                    TimeUnit::decisecond =>
                        crate::Units::Time(TimeUnit::decisecond),
                    TimeUnit::centisecond =>
                        crate::Units::Time(TimeUnit::centisecond),
                    TimeUnit::millisecond =>
                        crate::Units::Time(TimeUnit::millisecond),
                    TimeUnit::microsecond =>
                        crate::Units::Time(TimeUnit::microsecond),
                    TimeUnit::nanosecond =>
                        crate::Units::Time(TimeUnit::nanosecond),
                    TimeUnit::picosecond =>
                        crate::Units::Time(TimeUnit::picosecond),
                    TimeUnit::femtosecond =>
                        crate::Units::Time(TimeUnit::femtosecond),
                    TimeUnit::attosecond =>
                        crate::Units::Time(TimeUnit::attosecond),
                    TimeUnit::zeptosecond =>
                        crate::Units::Time(TimeUnit::zeptosecond),
                    TimeUnit::yoctosecond =>
                        crate::Units::Time(TimeUnit::yoctosecond),
                    TimeUnit::second_sidereal =>
                        crate::Units::Time(TimeUnit::second_sidereal),
                    TimeUnit::day => crate::Units::Time(TimeUnit::day),
                    TimeUnit::day_sidereal =>
                        crate::Units::Time(TimeUnit::day_sidereal),
                    TimeUnit::hour => crate::Units::Time(TimeUnit::hour),
                    TimeUnit::hour_sidereal =>
                        crate::Units::Time(TimeUnit::hour_sidereal),
                    TimeUnit::minute => crate::Units::Time(TimeUnit::minute),
                    TimeUnit::shake => crate::Units::Time(TimeUnit::shake),
                    TimeUnit::year => crate::Units::Time(TimeUnit::year),
                    TimeUnit::year_sidereal =>
                        crate::Units::Time(TimeUnit::year_sidereal),
                    TimeUnit::year_tropical =>
                        crate::Units::Time(TimeUnit::year_tropical),
                }
            }
        }
        impl TryFrom<UnitDefinition> for TimeUnit {
            type Error = RuntimeUnitError;
            #[allow(unreachable_patterns)]
            fn try_from(value: UnitDefinition) -> Result<Self, Self::Error> {
                match value {
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_YOTTASECOND_CONVERSION } =>
                        Ok(TimeUnit::yottasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_ZETTASECOND_CONVERSION } =>
                        Ok(TimeUnit::zettasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_EXASECOND_CONVERSION
                        } => Ok(TimeUnit::exasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_PETASECOND_CONVERSION
                        } => Ok(TimeUnit::petasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_TERASECOND_CONVERSION
                        } => Ok(TimeUnit::terasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_GIGASECOND_CONVERSION
                        } => Ok(TimeUnit::gigasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_MEGASECOND_CONVERSION
                        } => Ok(TimeUnit::megasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_KILOSECOND_CONVERSION
                        } => Ok(TimeUnit::kilosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_HECTOSECOND_CONVERSION } =>
                        Ok(TimeUnit::hectosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_DECASECOND_CONVERSION
                        } => Ok(TimeUnit::decasecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_SECOND_CONVERSION }
                        => Ok(TimeUnit::second),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_DECISECOND_CONVERSION
                        } => Ok(TimeUnit::decisecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_CENTISECOND_CONVERSION } =>
                        Ok(TimeUnit::centisecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_MILLISECOND_CONVERSION } =>
                        Ok(TimeUnit::millisecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_MICROSECOND_CONVERSION } =>
                        Ok(TimeUnit::microsecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_NANOSECOND_CONVERSION
                        } => Ok(TimeUnit::nanosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_PICOSECOND_CONVERSION
                        } => Ok(TimeUnit::picosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_FEMTOSECOND_CONVERSION } =>
                        Ok(TimeUnit::femtosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_ATTOSECOND_CONVERSION
                        } => Ok(TimeUnit::attosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_ZEPTOSECOND_CONVERSION } =>
                        Ok(TimeUnit::zeptosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_YOCTOSECOND_CONVERSION } =>
                        Ok(TimeUnit::yoctosecond),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_SECOND_SIDEREAL_CONVERSION } =>
                        Ok(TimeUnit::second_sidereal),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_DAY_CONVERSION } =>
                        Ok(TimeUnit::day),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_DAY_SIDEREAL_CONVERSION } =>
                        Ok(TimeUnit::day_sidereal),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_HOUR_CONVERSION } =>
                        Ok(TimeUnit::hour),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_HOUR_SIDEREAL_CONVERSION } =>
                        Ok(TimeUnit::hour_sidereal),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_MINUTE_CONVERSION }
                        => Ok(TimeUnit::minute),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_SHAKE_CONVERSION } =>
                        Ok(TimeUnit::shake),
                    UnitDefinition {
                        base: TIME_UNIT_BASE, multiplier: TIME_YEAR_CONVERSION } =>
                        Ok(TimeUnit::year),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_YEAR_SIDEREAL_CONVERSION } =>
                        Ok(TimeUnit::year_sidereal),
                    UnitDefinition {
                        base: TIME_UNIT_BASE,
                        multiplier: TIME_YEAR_TROPICAL_CONVERSION } =>
                        Ok(TimeUnit::year_tropical),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0:?} to {1}",
                                                    value, "Time"));
                                        res
                                    }))),
                }
            }
        }
        impl TryFrom<crate::Units> for TimeUnit {
            type Error = RuntimeUnitError;
            fn try_from(value: crate::Units) -> Result<Self, Self::Error> {
                match value {
                    crate::Units::Time(TimeUnit::yottasecond) =>
                        Ok(TimeUnit::yottasecond),
                    crate::Units::Time(TimeUnit::zettasecond) =>
                        Ok(TimeUnit::zettasecond),
                    crate::Units::Time(TimeUnit::exasecond) =>
                        Ok(TimeUnit::exasecond),
                    crate::Units::Time(TimeUnit::petasecond) =>
                        Ok(TimeUnit::petasecond),
                    crate::Units::Time(TimeUnit::terasecond) =>
                        Ok(TimeUnit::terasecond),
                    crate::Units::Time(TimeUnit::gigasecond) =>
                        Ok(TimeUnit::gigasecond),
                    crate::Units::Time(TimeUnit::megasecond) =>
                        Ok(TimeUnit::megasecond),
                    crate::Units::Time(TimeUnit::kilosecond) =>
                        Ok(TimeUnit::kilosecond),
                    crate::Units::Time(TimeUnit::hectosecond) =>
                        Ok(TimeUnit::hectosecond),
                    crate::Units::Time(TimeUnit::decasecond) =>
                        Ok(TimeUnit::decasecond),
                    crate::Units::Time(TimeUnit::second) =>
                        Ok(TimeUnit::second),
                    crate::Units::Time(TimeUnit::decisecond) =>
                        Ok(TimeUnit::decisecond),
                    crate::Units::Time(TimeUnit::centisecond) =>
                        Ok(TimeUnit::centisecond),
                    crate::Units::Time(TimeUnit::millisecond) =>
                        Ok(TimeUnit::millisecond),
                    crate::Units::Time(TimeUnit::microsecond) =>
                        Ok(TimeUnit::microsecond),
                    crate::Units::Time(TimeUnit::nanosecond) =>
                        Ok(TimeUnit::nanosecond),
                    crate::Units::Time(TimeUnit::picosecond) =>
                        Ok(TimeUnit::picosecond),
                    crate::Units::Time(TimeUnit::femtosecond) =>
                        Ok(TimeUnit::femtosecond),
                    crate::Units::Time(TimeUnit::attosecond) =>
                        Ok(TimeUnit::attosecond),
                    crate::Units::Time(TimeUnit::zeptosecond) =>
                        Ok(TimeUnit::zeptosecond),
                    crate::Units::Time(TimeUnit::yoctosecond) =>
                        Ok(TimeUnit::yoctosecond),
                    crate::Units::Time(TimeUnit::second_sidereal) =>
                        Ok(TimeUnit::second_sidereal),
                    crate::Units::Time(TimeUnit::day) => Ok(TimeUnit::day),
                    crate::Units::Time(TimeUnit::day_sidereal) =>
                        Ok(TimeUnit::day_sidereal),
                    crate::Units::Time(TimeUnit::hour) => Ok(TimeUnit::hour),
                    crate::Units::Time(TimeUnit::hour_sidereal) =>
                        Ok(TimeUnit::hour_sidereal),
                    crate::Units::Time(TimeUnit::minute) =>
                        Ok(TimeUnit::minute),
                    crate::Units::Time(TimeUnit::shake) => Ok(TimeUnit::shake),
                    crate::Units::Time(TimeUnit::year) => Ok(TimeUnit::year),
                    crate::Units::Time(TimeUnit::year_sidereal) =>
                        Ok(TimeUnit::year_sidereal),
                    crate::Units::Time(TimeUnit::year_tropical) =>
                        Ok(TimeUnit::year_tropical),
                    _ =>
                        Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("Could not convert from {0} to {1}",
                                                    value, "Time"));
                                        res
                                    }))),
                }
            }
        }
        impl From<Time> for crate::Units {
            fn from(value: Time) -> Self { crate::Units::Time(value.unit) }
        }
        impl From<&Time> for crate::Units {
            fn from(value: &Time) -> Self { crate::Units::Time(value.unit) }
        }
        impl From<TimeVec> for crate::Units {
            fn from(value: TimeVec) -> Self { crate::Units::Time(value.unit) }
        }
        impl From<&TimeVec> for crate::Units {
            fn from(value: &TimeVec) -> Self {
                crate::Units::Time(value.unit)
            }
        }
        use crate::traits::FixedQuantity;
        #[doc = r" Time (base UnitDefinition second, s)."]
        #[schema(title = "Time")]
        #[doc = "Scalar storage of a quantity (f64 and [`TimeUnit`])."]
        pub struct Time {
            pub(crate) value: f64,
            pub(crate) unit: TimeUnit,
        }
        impl utoipa::__dev::ComposeSchema for Time {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                                let mut object = utoipa::openapi::ObjectBuilder::new();
                                object =
                                    object.property("value",
                                            utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double)))).required("value");
                                object =
                                    object.property("unit",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <TimeUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("unit");
                                ;
                                object
                            }.title(Some("Time")).description(Some(" Time (base UnitDefinition second, s).\nScalar storage of a quantity (f64 and [`TimeUnit`]).")).into()
            }
        }
        impl utoipa::ToSchema for Time {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("Time")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <TimeUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <TimeUnit as utoipa::PartialSchema>::schema())]);
                <TimeUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Time {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer, "Time",
                                    false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "value", &self.value)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Time {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"unit" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Time>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Time;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct Time")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<f64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct Time with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<TimeUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct Time with 2 elements")),
                                    };
                                _serde::__private::Ok(Time {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<f64> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<TimeUnit> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("value"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<f64>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<TimeUnit>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("value")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                _serde::__private::Ok(Time {
                                        value: __field0,
                                        unit: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["value", "unit"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "Time", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Time>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::marker::Copy for Time { }
        #[automatically_derived]
        impl ::core::clone::Clone for Time {
            #[inline]
            fn clone(&self) -> Time {
                let _: ::core::clone::AssertParamIsClone<f64>;
                let _: ::core::clone::AssertParamIsClone<TimeUnit>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Time {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f, "Time",
                    "value", &self.value, "unit", &&self.unit)
            }
        }
        impl Time {
            #[doc = "Create a new [`TimeUnit`]."]
            pub fn new(value: f64, unit: TimeUnit) -> Self {
                Self { value, unit }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::yottasecond`]."]
            pub fn yottasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::yottasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::zettasecond`]."]
            pub fn zettasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::zettasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::exasecond`]."]
            pub fn exasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::exasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::petasecond`]."]
            pub fn petasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::petasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::terasecond`]."]
            pub fn terasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::terasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::gigasecond`]."]
            pub fn gigasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::gigasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::megasecond`]."]
            pub fn megasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::megasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::kilosecond`]."]
            pub fn kilosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::kilosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::hectosecond`]."]
            pub fn hectosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::hectosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::decasecond`]."]
            pub fn decasecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::decasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::second`]."]
            pub fn second(value: f64) -> Self {
                Self { value, unit: TimeUnit::second.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::decisecond`]."]
            pub fn decisecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::decisecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::centisecond`]."]
            pub fn centisecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::centisecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::millisecond`]."]
            pub fn millisecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::millisecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::microsecond`]."]
            pub fn microsecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::microsecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::nanosecond`]."]
            pub fn nanosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::nanosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::picosecond`]."]
            pub fn picosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::picosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::femtosecond`]."]
            pub fn femtosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::femtosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::attosecond`]."]
            pub fn attosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::attosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::zeptosecond`]."]
            pub fn zeptosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::zeptosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::yoctosecond`]."]
            pub fn yoctosecond(value: f64) -> Self {
                Self { value, unit: TimeUnit::yoctosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::second_sidereal`]."]
            pub fn second_sidereal(value: f64) -> Self {
                Self { value, unit: TimeUnit::second_sidereal.into() }
            }
            #[doc = "Create a new [`Time`] with units of [`TimeUnit::day`]."]
            pub fn day(value: f64) -> Self {
                Self { value, unit: TimeUnit::day.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::day_sidereal`]."]
            pub fn day_sidereal(value: f64) -> Self {
                Self { value, unit: TimeUnit::day_sidereal.into() }
            }
            #[doc = "Create a new [`Time`] with units of [`TimeUnit::hour`]."]
            pub fn hour(value: f64) -> Self {
                Self { value, unit: TimeUnit::hour.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::hour_sidereal`]."]
            pub fn hour_sidereal(value: f64) -> Self {
                Self { value, unit: TimeUnit::hour_sidereal.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::minute`]."]
            pub fn minute(value: f64) -> Self {
                Self { value, unit: TimeUnit::minute.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::shake`]."]
            pub fn shake(value: f64) -> Self {
                Self { value, unit: TimeUnit::shake.into() }
            }
            #[doc = "Create a new [`Time`] with units of [`TimeUnit::year`]."]
            pub fn year(value: f64) -> Self {
                Self { value, unit: TimeUnit::year.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::year_sidereal`]."]
            pub fn year_sidereal(value: f64) -> Self {
                Self { value, unit: TimeUnit::year_sidereal.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::year_tropical`]."]
            pub fn year_tropical(value: f64) -> Self {
                Self { value, unit: TimeUnit::year_tropical.into() }
            }
            #[doc = "Retrieve the value associated with this [`Time`]."]
            #[inline]
            pub fn value(&self) -> f64 { self.value }
            #[doc =
            "Retrieve the mutable value associated with this [`Time`]."]
            #[inline]
            pub fn value_mut(&mut self) -> &mut f64 { &mut self.value }
            #[doc =
            "Retrieve the `UnitDefinition` associated with this [`Time`]."]
            #[inline]
            pub fn definition(&self) -> UnitDefinition { self.unit.into() }
            #[inline]
            #[doc =
            " Convert from one unit to another (no check is made to ensure destination unit is valid)."]
            fn convert_unchecked(&self, unit: UnitDefinition) -> f64 {
                let definition = self.definition();
                if definition == unit {
                        self.value
                    } else {
                       self.value * definition.multiplier / unit.multiplier()
                   }
            }
            #[doc = "Convert to [`TimeUnit::yottasecond`]."]
            #[inline]
            pub fn to_yottasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_YOTTASECOND_CONVERSION)) as f64,
                    unit: TimeUnit::yottasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::zettasecond`]."]
            #[inline]
            pub fn to_zettasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_ZETTASECOND_CONVERSION)) as f64,
                    unit: TimeUnit::zettasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::exasecond`]."]
            #[inline]
            pub fn to_exasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (TIME_EXASECOND_CONVERSION))
                            as f64,
                    unit: TimeUnit::exasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::petasecond`]."]
            #[inline]
            pub fn to_petasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_PETASECOND_CONVERSION)) as f64,
                    unit: TimeUnit::petasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::terasecond`]."]
            #[inline]
            pub fn to_terasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_TERASECOND_CONVERSION)) as f64,
                    unit: TimeUnit::terasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::gigasecond`]."]
            #[inline]
            pub fn to_gigasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_GIGASECOND_CONVERSION)) as f64,
                    unit: TimeUnit::gigasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::megasecond`]."]
            #[inline]
            pub fn to_megasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_MEGASECOND_CONVERSION)) as f64,
                    unit: TimeUnit::megasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::kilosecond`]."]
            #[inline]
            pub fn to_kilosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_KILOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::kilosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::hectosecond`]."]
            #[inline]
            pub fn to_hectosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_HECTOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::hectosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::decasecond`]."]
            #[inline]
            pub fn to_decasecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_DECASECOND_CONVERSION)) as f64,
                    unit: TimeUnit::decasecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::second`]."]
            #[inline]
            pub fn to_second(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (TIME_SECOND_CONVERSION)) as
                            f64,
                    unit: TimeUnit::second,
                }
            }
            #[doc = "Convert to [`TimeUnit::decisecond`]."]
            #[inline]
            pub fn to_decisecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_DECISECOND_CONVERSION)) as f64,
                    unit: TimeUnit::decisecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::centisecond`]."]
            #[inline]
            pub fn to_centisecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_CENTISECOND_CONVERSION)) as f64,
                    unit: TimeUnit::centisecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::millisecond`]."]
            #[inline]
            pub fn to_millisecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_MILLISECOND_CONVERSION)) as f64,
                    unit: TimeUnit::millisecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::microsecond`]."]
            #[inline]
            pub fn to_microsecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_MICROSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::microsecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::nanosecond`]."]
            #[inline]
            pub fn to_nanosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_NANOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::nanosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::picosecond`]."]
            #[inline]
            pub fn to_picosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_PICOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::picosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::femtosecond`]."]
            #[inline]
            pub fn to_femtosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_FEMTOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::femtosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::attosecond`]."]
            #[inline]
            pub fn to_attosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_ATTOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::attosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::zeptosecond`]."]
            #[inline]
            pub fn to_zeptosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_ZEPTOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::zeptosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::yoctosecond`]."]
            #[inline]
            pub fn to_yoctosecond(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_YOCTOSECOND_CONVERSION)) as f64,
                    unit: TimeUnit::yoctosecond,
                }
            }
            #[doc = "Convert to [`TimeUnit::second_sidereal`]."]
            #[inline]
            pub fn to_second_sidereal(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_SECOND_SIDEREAL_CONVERSION)) as f64,
                    unit: TimeUnit::second_sidereal,
                }
            }
            #[doc = "Convert to [`TimeUnit::day`]."]
            #[inline]
            pub fn to_day(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (TIME_DAY_CONVERSION)) as
                            f64,
                    unit: TimeUnit::day,
                }
            }
            #[doc = "Convert to [`TimeUnit::day_sidereal`]."]
            #[inline]
            pub fn to_day_sidereal(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_DAY_SIDEREAL_CONVERSION)) as f64,
                    unit: TimeUnit::day_sidereal,
                }
            }
            #[doc = "Convert to [`TimeUnit::hour`]."]
            #[inline]
            pub fn to_hour(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (TIME_HOUR_CONVERSION)) as
                            f64,
                    unit: TimeUnit::hour,
                }
            }
            #[doc = "Convert to [`TimeUnit::hour_sidereal`]."]
            #[inline]
            pub fn to_hour_sidereal(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_HOUR_SIDEREAL_CONVERSION)) as f64,
                    unit: TimeUnit::hour_sidereal,
                }
            }
            #[doc = "Convert to [`TimeUnit::minute`]."]
            #[inline]
            pub fn to_minute(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (TIME_MINUTE_CONVERSION)) as
                            f64,
                    unit: TimeUnit::minute,
                }
            }
            #[doc = "Convert to [`TimeUnit::shake`]."]
            #[inline]
            pub fn to_shake(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (TIME_SHAKE_CONVERSION)) as
                            f64,
                    unit: TimeUnit::shake,
                }
            }
            #[doc = "Convert to [`TimeUnit::year`]."]
            #[inline]
            pub fn to_year(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier / (TIME_YEAR_CONVERSION)) as
                            f64,
                    unit: TimeUnit::year,
                }
            }
            #[doc = "Convert to [`TimeUnit::year_sidereal`]."]
            #[inline]
            pub fn to_year_sidereal(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_YEAR_SIDEREAL_CONVERSION)) as f64,
                    unit: TimeUnit::year_sidereal,
                }
            }
            #[doc = "Convert to [`TimeUnit::year_tropical`]."]
            #[inline]
            pub fn to_year_tropical(&self) -> Self {
                Self {
                    value: self.value *
                        (self.definition().multiplier /
                                    (TIME_YEAR_TROPICAL_CONVERSION)) as f64,
                    unit: TimeUnit::year_tropical,
                }
            }
        }
        impl FixedQuantity<TimeUnit> for Time {
            #[inline]
            fn unit(&self) -> TimeUnit { self.unit }
            #[inline]
            fn convert(&self, unit: TimeUnit) -> Self {
                Self {
                    value: self.convert_unchecked(unit.into()),
                    unit: unit,
                }
            }
            #[inline]
            fn convert_mut(&mut self, unit: TimeUnit) {
                self.value = self.convert_unchecked(unit.into());
                self.unit = unit;
            }
            #[inline]
            fn unit_mut(&mut self) -> &mut TimeUnit { &mut self.unit }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: TimeUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl From<Time> for UnitDefinition {
            #[inline]
            fn from(value: Time) -> Self {
                match value.unit {
                    TimeUnit::yottasecond => TimeUnit::get_yottasecond(),
                    TimeUnit::zettasecond => TimeUnit::get_zettasecond(),
                    TimeUnit::exasecond => TimeUnit::get_exasecond(),
                    TimeUnit::petasecond => TimeUnit::get_petasecond(),
                    TimeUnit::terasecond => TimeUnit::get_terasecond(),
                    TimeUnit::gigasecond => TimeUnit::get_gigasecond(),
                    TimeUnit::megasecond => TimeUnit::get_megasecond(),
                    TimeUnit::kilosecond => TimeUnit::get_kilosecond(),
                    TimeUnit::hectosecond => TimeUnit::get_hectosecond(),
                    TimeUnit::decasecond => TimeUnit::get_decasecond(),
                    TimeUnit::second => TimeUnit::get_second(),
                    TimeUnit::decisecond => TimeUnit::get_decisecond(),
                    TimeUnit::centisecond => TimeUnit::get_centisecond(),
                    TimeUnit::millisecond => TimeUnit::get_millisecond(),
                    TimeUnit::microsecond => TimeUnit::get_microsecond(),
                    TimeUnit::nanosecond => TimeUnit::get_nanosecond(),
                    TimeUnit::picosecond => TimeUnit::get_picosecond(),
                    TimeUnit::femtosecond => TimeUnit::get_femtosecond(),
                    TimeUnit::attosecond => TimeUnit::get_attosecond(),
                    TimeUnit::zeptosecond => TimeUnit::get_zeptosecond(),
                    TimeUnit::yoctosecond => TimeUnit::get_yoctosecond(),
                    TimeUnit::second_sidereal =>
                        TimeUnit::get_second_sidereal(),
                    TimeUnit::day => TimeUnit::get_day(),
                    TimeUnit::day_sidereal => TimeUnit::get_day_sidereal(),
                    TimeUnit::hour => TimeUnit::get_hour(),
                    TimeUnit::hour_sidereal => TimeUnit::get_hour_sidereal(),
                    TimeUnit::minute => TimeUnit::get_minute(),
                    TimeUnit::shake => TimeUnit::get_shake(),
                    TimeUnit::year => TimeUnit::get_year(),
                    TimeUnit::year_sidereal => TimeUnit::get_year_sidereal(),
                    TimeUnit::year_tropical => TimeUnit::get_year_tropical(),
                }
            }
        }
        impl From<Time> for Quantity {
            fn from(quantity: Time) -> Self {
                Self { value: quantity.value, unit: quantity.unit.into() }
            }
        }
        impl From<Quantity> for Time {
            fn from(quantity: Quantity) -> Time {
                Time {
                    value: quantity.value,
                    unit: TimeUnit::try_from(quantity.unit).unwrap(),
                }
            }
        }
        impl crate::traits::IsScalarQuantity for Time {
            fn value(&self) -> f64 { self.value }
            fn unit(&self) -> UnitDefinition { self.unit.into() }
        }
        use crate::impl_quantity_ops;
        use crate::create_multivalue_quantities;
        use crate::{
            impl_quantity_vec_ops, impl_quantity_array_ops,
            create_multivalue_quantities_vec_enum,
            create_multivalue_quantities_array_enum,
        };
        impl TimeVec {
            #[doc = "Create a new vector of [`TimeUnit`]."]
            pub fn new(values: Vec<f64>, unit: TimeUnit) -> Self {
                Self { values, unit }
            }
            #[inline]
            #[doc = "Retrieve values associated with this [`TimeSlice`]."]
            pub fn values(&self) -> &Vec<f64> { &self.values }
            #[inline]
            #[doc =
            "Retrieve the mutable values associated with this [`TimeSlice`]."]
            pub fn values_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::yottasecond`]."]
            pub fn yottasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::yottasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::zettasecond`]."]
            pub fn zettasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::zettasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::exasecond`]."]
            pub fn exasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::exasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::petasecond`]."]
            pub fn petasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::petasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::terasecond`]."]
            pub fn terasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::terasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::gigasecond`]."]
            pub fn gigasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::gigasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::megasecond`]."]
            pub fn megasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::megasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::kilosecond`]."]
            pub fn kilosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::kilosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::hectosecond`]."]
            pub fn hectosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::hectosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::decasecond`]."]
            pub fn decasecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::decasecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::second`]."]
            pub fn second(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::second.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::decisecond`]."]
            pub fn decisecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::decisecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::centisecond`]."]
            pub fn centisecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::centisecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::millisecond`]."]
            pub fn millisecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::millisecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::microsecond`]."]
            pub fn microsecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::microsecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::nanosecond`]."]
            pub fn nanosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::nanosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::picosecond`]."]
            pub fn picosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::picosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::femtosecond`]."]
            pub fn femtosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::femtosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::attosecond`]."]
            pub fn attosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::attosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::zeptosecond`]."]
            pub fn zeptosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::zeptosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::yoctosecond`]."]
            pub fn yoctosecond(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::yoctosecond.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::second_sidereal`]."]
            pub fn second_sidereal(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::second_sidereal.into() }
            }
            #[doc = "Create a new [`Time`] with units of [`TimeUnit::day`]."]
            pub fn day(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::day.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::day_sidereal`]."]
            pub fn day_sidereal(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::day_sidereal.into() }
            }
            #[doc = "Create a new [`Time`] with units of [`TimeUnit::hour`]."]
            pub fn hour(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::hour.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::hour_sidereal`]."]
            pub fn hour_sidereal(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::hour_sidereal.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::minute`]."]
            pub fn minute(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::minute.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::shake`]."]
            pub fn shake(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::shake.into() }
            }
            #[doc = "Create a new [`Time`] with units of [`TimeUnit::year`]."]
            pub fn year(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::year.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::year_sidereal`]."]
            pub fn year_sidereal(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::year_sidereal.into() }
            }
            #[doc =
            "Create a new [`Time`] with units of [`TimeUnit::year_tropical`]."]
            pub fn year_tropical(values: Vec<f64>) -> Self {
                Self { values, unit: TimeUnit::year_tropical.into() }
            }
            #[doc = "Convert to [`TimeUnit::yottasecond`]."]
            #[inline]
            pub fn to_yottasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::yottasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::zettasecond`]."]
            #[inline]
            pub fn to_zettasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::zettasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::exasecond`]."]
            #[inline]
            pub fn to_exasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::exasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::petasecond`]."]
            #[inline]
            pub fn to_petasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::petasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::terasecond`]."]
            #[inline]
            pub fn to_terasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::terasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::gigasecond`]."]
            #[inline]
            pub fn to_gigasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::gigasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::megasecond`]."]
            #[inline]
            pub fn to_megasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::megasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::kilosecond`]."]
            #[inline]
            pub fn to_kilosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::kilosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::hectosecond`]."]
            #[inline]
            pub fn to_hectosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::hectosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::decasecond`]."]
            #[inline]
            pub fn to_decasecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::decasecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::second`]."]
            #[inline]
            pub fn to_second(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::second);
                r
            }
            #[doc = "Convert to [`TimeUnit::decisecond`]."]
            #[inline]
            pub fn to_decisecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::decisecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::centisecond`]."]
            #[inline]
            pub fn to_centisecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::centisecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::millisecond`]."]
            #[inline]
            pub fn to_millisecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::millisecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::microsecond`]."]
            #[inline]
            pub fn to_microsecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::microsecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::nanosecond`]."]
            #[inline]
            pub fn to_nanosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::nanosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::picosecond`]."]
            #[inline]
            pub fn to_picosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::picosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::femtosecond`]."]
            #[inline]
            pub fn to_femtosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::femtosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::attosecond`]."]
            #[inline]
            pub fn to_attosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::attosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::zeptosecond`]."]
            #[inline]
            pub fn to_zeptosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::zeptosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::yoctosecond`]."]
            #[inline]
            pub fn to_yoctosecond(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::yoctosecond);
                r
            }
            #[doc = "Convert to [`TimeUnit::second_sidereal`]."]
            #[inline]
            pub fn to_second_sidereal(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::second_sidereal);
                r
            }
            #[doc = "Convert to [`TimeUnit::day`]."]
            #[inline]
            pub fn to_day(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::day);
                r
            }
            #[doc = "Convert to [`TimeUnit::day_sidereal`]."]
            #[inline]
            pub fn to_day_sidereal(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::day_sidereal);
                r
            }
            #[doc = "Convert to [`TimeUnit::hour`]."]
            #[inline]
            pub fn to_hour(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::hour);
                r
            }
            #[doc = "Convert to [`TimeUnit::hour_sidereal`]."]
            #[inline]
            pub fn to_hour_sidereal(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::hour_sidereal);
                r
            }
            #[doc = "Convert to [`TimeUnit::minute`]."]
            #[inline]
            pub fn to_minute(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::minute);
                r
            }
            #[doc = "Convert to [`TimeUnit::shake`]."]
            #[inline]
            pub fn to_shake(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::shake);
                r
            }
            #[doc = "Convert to [`TimeUnit::year`]."]
            #[inline]
            pub fn to_year(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::year);
                r
            }
            #[doc = "Convert to [`TimeUnit::year_sidereal`]."]
            #[inline]
            pub fn to_year_sidereal(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::year_sidereal);
                r
            }
            #[doc = "Convert to [`TimeUnit::year_tropical`]."]
            #[inline]
            pub fn to_year_tropical(&self) -> Self {
                use crate::traits::FixedSliceQuantity;
                let mut r = self.clone();
                r.convert_mut(TimeUnit::year_tropical);
                r
            }
        }
        use crate::traits::IsScalarQuantity;
        impl Mul<f64> for Time {
            type Output = Time;
            fn mul(self, rhs: f64) -> Self::Output {
                Self { value: self.value * rhs, unit: self.unit }
            }
        }
        impl Div<f64> for Time {
            type Output = Time;
            fn div(self, rhs: f64) -> Self::Output {
                Self { value: self.value / rhs, unit: self.unit }
            }
        }
        impl MulAssign<f64> for Time {
            fn mul_assign(&mut self, rhs: f64) { self.value *= rhs; }
        }
        impl DivAssign<f64> for Time {
            fn div_assign(&mut self, rhs: f64) { self.value /= rhs; }
        }
        impl PartialEq<Quantity> for Time {
            fn eq(&self, other: &Quantity) -> bool {
                Quantity::from(*self).eq(other)
            }
        }
        impl PartialEq<Time> for Quantity {
            fn eq(&self, other: &Time) -> bool { *other == *self }
        }
        impl PartialEq<Time> for Time {
            fn eq(&self, other: &Time) -> bool {
                self.value * self.definition().multiplier ==
                    other.value * other.definition().multiplier
            }
        }
        impl<T: IsScalarQuantity> Mul<T> for Time {
            type Output = Quantity;
            fn mul(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value * rhs.value(),
                    unit: self.definition() * rhs.unit(),
                }
            }
        }
        impl<T: IsScalarQuantity> Div<T> for Time {
            type Output = Quantity;
            fn div(self, rhs: T) -> Quantity {
                Quantity {
                    value: self.value / rhs.value(),
                    unit: self.definition() / rhs.unit(),
                }
            }
        }
        impl Add<Time> for Time {
            type Output = Self;
            fn add(self, rhs: Time) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Time> for Time {
            type Output = Self;
            fn sub(self, rhs: Time) -> Self {
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign for Time {
            fn add_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign for Time {
            fn sub_assign(&mut self, rhs: Self) {
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        impl Add<Quantity> for Time {
            type Output = Self;
            fn add(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units added"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value + rhs_value, unit: self.unit }
            }
        }
        impl Sub<Quantity> for Time {
            type Output = Self;
            fn sub(self, rhs: Quantity) -> Self {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                Self { value: self.value - rhs_value, unit: self.unit }
            }
        }
        impl AddAssign<Quantity> for Time {
            fn add_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value += rhs_value;
            }
        }
        impl SubAssign<Quantity> for Time {
            fn sub_assign(&mut self, rhs: Quantity) {
                if self.definition().base != rhs.unit.base {
                        {
                            ::core::panicking::panic_fmt(format_args!("Incompatible units subtracted"));
                        };
                    }
                let rhs_value = rhs.convert_unchecked(self.definition());
                self.value -= rhs_value;
            }
        }
        #[cfg(feature = "serde")]
        use serde_with::serde_as;
        use std::ops::{Deref, DerefMut};
        #[doc = "Array storage for a series of values and [`TimeUnit`]."]
        pub struct TimeArray<const N : usize> {
            pub(crate) unit: TimeUnit,
            #[serde_as(r#as = "[_; N]")]
            #[serde(with =
            ":: serde_with :: As :: < [:: serde_with :: Same; N] >")]
            pub(crate) values: [f64; N],
        }
        impl<const N : usize> utoipa::__dev::ComposeSchema for TimeArray<N> {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <TimeUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Array storage for a series of values and [`TimeUnit`].")).into()
            }
        }
        impl<const N : usize> utoipa::ToSchema for TimeArray<N> {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TimeArray")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <TimeUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <TimeUnit as utoipa::PartialSchema>::schema())]);
                <TimeUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<const N : usize> _serde::Serialize for TimeArray<N> {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "TimeArray", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values",
                                {
                                    #[doc(hidden)]
                                    struct __SerializeWith<'__a, const N : usize> {
                                        values: (&'__a [f64; N],),
                                        phantom: _serde::__private::PhantomData<TimeArray<N>>,
                                    }
                                    #[automatically_derived]
                                    impl<'__a, const N : usize> _serde::Serialize for
                                        __SerializeWith<'__a, N> {
                                        fn serialize<__S>(&self, __s: __S)
                                            -> _serde::__private::Result<__S::Ok, __S::Error> where
                                            __S: _serde::Serializer {
                                            ::serde_with::As::<[::serde_with::Same; N]>::serialize(self.values.0,
                                                __s)
                                        }
                                    }
                                    &__SerializeWith {
                                            values: (&self.values,),
                                            phantom: _serde::__private::PhantomData::<TimeArray<N>>,
                                        }
                                })?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, const N : usize> _serde::Deserialize<'de> for
                    TimeArray<N> {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, const N : usize> {
                            marker: _serde::__private::PhantomData<TimeArray<N>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de, const N : usize> _serde::de::Visitor<'de> for
                            __Visitor<'de, N> {
                            type Value = TimeArray<N>;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct TimeArray")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<TimeUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct TimeArray with 2 elements")),
                                    };
                                let __field1 =
                                    match {
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de, const N : usize> {
                                                value: [f64; N],
                                                phantom: _serde::__private::PhantomData<TimeArray<N>>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                __DeserializeWith<'de, N> {
                                                fn deserialize<__D>(__deserializer: __D)
                                                    -> _serde::__private::Result<Self, __D::Error> where
                                                    __D: _serde::Deserializer<'de> {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                            value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                }
                                            }
                                            _serde::__private::Option::map(_serde::de::SeqAccess::next_element::<__DeserializeWith<'de,
                                                            N>>(&mut __seq)?, |__wrap| __wrap.value)
                                        } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct TimeArray with 2 elements")),
                                    };
                                _serde::__private::Ok(TimeArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<TimeUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<[f64; N]> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<TimeUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some({
                                                        #[doc(hidden)]
                                                        struct __DeserializeWith<'de, const N : usize> {
                                                            value: [f64; N],
                                                            phantom: _serde::__private::PhantomData<TimeArray<N>>,
                                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                                        }
                                                        #[automatically_derived]
                                                        impl<'de, const N : usize> _serde::Deserialize<'de> for
                                                            __DeserializeWith<'de, N> {
                                                            fn deserialize<__D>(__deserializer: __D)
                                                                -> _serde::__private::Result<Self, __D::Error> where
                                                                __D: _serde::Deserializer<'de> {
                                                                _serde::__private::Ok(__DeserializeWith {
                                                                        value: ::serde_with::As::<[::serde_with::Same; N]>::deserialize(__deserializer)?,
                                                                        phantom: _serde::__private::PhantomData,
                                                                        lifetime: _serde::__private::PhantomData,
                                                                    })
                                                            }
                                                        }
                                                        match _serde::de::MapAccess::next_value::<__DeserializeWith<'de,
                                                                    N>>(&mut __map) {
                                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        }
                                                    });
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(<__A::Error as
                                                            _serde::de::Error>::missing_field("values")),
                                    };
                                _serde::__private::Ok(TimeArray {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "TimeArray", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TimeArray<N>>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl<const N : usize> ::core::marker::Copy for TimeArray<N> { }
        #[automatically_derived]
        impl<const N : usize> ::core::clone::Clone for TimeArray<N> {
            #[inline]
            fn clone(&self) -> TimeArray<N> {
                let _: ::core::clone::AssertParamIsClone<TimeUnit>;
                let _: ::core::clone::AssertParamIsClone<[f64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::fmt::Debug for TimeArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "TimeArray", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl<const N : usize> ::core::marker::StructuralPartialEq for
            TimeArray<N> {
        }
        #[automatically_derived]
        impl<const N : usize> ::core::cmp::PartialEq for TimeArray<N> {
            #[inline]
            fn eq(&self, other: &TimeArray<N>) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl<const N : usize> Deref for TimeArray<N> {
            type Target = [f64; N];
            fn deref(&self) -> &[f64; N] { &self.values }
        }
        impl<const N : usize> DerefMut for TimeArray<N> {
            fn deref_mut(&mut self) -> &mut [f64; N] { &mut self.values }
        }
        #[doc = "Vector storage for a series of values and [`TimeUnit`]."]
        pub struct TimeVec {
            pub(crate) unit: TimeUnit,
            pub(crate) values: Vec<f64>,
        }
        impl utoipa::__dev::ComposeSchema for TimeVec {
            fn compose(mut generics:
                    Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
                -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
                {
                            let mut object = utoipa::openapi::ObjectBuilder::new();
                            object =
                                object.property("unit",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <TimeUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("unit");
                            object =
                                object.property("values",
                                        utoipa::openapi::schema::ArrayBuilder::new().items(utoipa::openapi::ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::new(utoipa::openapi::schema::Type::Number)).format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(utoipa::openapi::schema::KnownFormat::Double))))).required("values");
                            ;
                            object
                        }.description(Some("Vector storage for a series of values and [`TimeUnit`].")).into()
            }
        }
        impl utoipa::ToSchema for TimeVec {
            fn name() -> std::borrow::Cow<'static, str> {
                std::borrow::Cow::Borrowed("TimeVec")
            }
            fn schemas(schemas:
                    &mut Vec<(String,
                    utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
                schemas.extend([(String::from(::alloc::__export::must_use({
                                            let res =
                                                ::alloc::fmt::format(format_args!("{0}",
                                                        <TimeUnit as utoipa::ToSchema>::name()));
                                            res
                                        })), <TimeUnit as utoipa::PartialSchema>::schema())]);
                <TimeUnit as utoipa::ToSchema>::schemas(schemas);
                ;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TimeVec {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "TimeVec", false as usize + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "unit", &self.unit)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "values", &self.values)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TimeVec {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "unit" => _serde::__private::Ok(__Field::__field0),
                                    "values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"unit" => _serde::__private::Ok(__Field::__field0),
                                    b"values" => _serde::__private::Ok(__Field::__field1),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TimeVec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TimeVec;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct TimeVec")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<TimeUnit>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct TimeVec with 2 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct TimeVec with 2 elements")),
                                    };
                                _serde::__private::Ok(TimeVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<TimeUnit> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("unit"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<TimeUnit>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("values"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("unit")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("values")?,
                                    };
                                _serde::__private::Ok(TimeVec {
                                        unit: __field0,
                                        values: __field1,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["unit", "values"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "TimeVec", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TimeVec>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for TimeVec {
            #[inline]
            fn clone(&self) -> TimeVec {
                TimeVec {
                    unit: ::core::clone::Clone::clone(&self.unit),
                    values: ::core::clone::Clone::clone(&self.values),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TimeVec {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(f,
                    "TimeVec", "unit", &self.unit, "values", &&self.values)
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TimeVec { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TimeVec {
            #[inline]
            fn eq(&self, other: &TimeVec) -> bool {
                self.unit == other.unit && self.values == other.values
            }
        }
        impl Deref for TimeVec {
            type Target = Vec<f64>;
            fn deref(&self) -> &Vec<f64> { &self.values }
        }
        impl DerefMut for TimeVec {
            fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
        }
        impl crate::traits::FixedSliceQuantity<TimeUnit, f64> for TimeVec {
            fn unit(&self) -> TimeUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: TimeUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: TimeUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: TimeUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        impl<const N : usize> crate::traits::FixedSliceQuantity<TimeUnit, f64>
            for TimeArray<N> {
            fn unit(&self) -> TimeUnit { self.unit }
            fn values(&self) -> &[f64] { &self.values.as_slice() }
            fn values_mut(&mut self) -> &mut [f64] {
                self.values.as_mut_slice()
            }
            fn len(&self) -> usize { self.values.len() }
            fn convert(&self, unit: TimeUnit) -> Self {
                let mut result = self.clone();
                result.convert_mut(unit);
                return result;
            }
            #[inline]
            fn convert_mut(&mut self, unit: TimeUnit) {
                let factor =
                    self.unit.definition().convert_unchecked(unit.definition());
                for val in self.values.as_mut_slice().iter_mut() {
                    *val *= factor;
                }
                self.unit = unit;
            }
            #[inline]
            fn try_convert(&self, unit: crate::Units)
                -> Result<Self, RuntimeUnitError> where Self: Sized {
                let destination_unit: TimeUnit = unit.try_into()?;
                Ok(self.convert(destination_unit))
            }
        }
        use core::ops::{
            Mul, Div, Add, Sub, AddAssign, SubAssign, MulAssign, DivAssign,
        };
        impl Div<f64> for TimeVec {
            type Output = TimeVec;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl Mul<f64> for TimeVec {
            type Output = TimeVec;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl DivAssign<f64> for TimeVec {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl MulAssign<f64> for TimeVec {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        use crate::traits::Unit;
        impl AddAssign<TimeVec> for TimeVec {
            fn add_assign(&mut self, rhs: TimeVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl SubAssign<TimeVec> for TimeVec {
            fn sub_assign(&mut self, rhs: TimeVec) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        impl<const N : usize> Div<f64> for TimeArray<N> {
            type Output = TimeArray<N>;
            fn div(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val /= rhs; }
                result
            }
        }
        impl<const N : usize> Mul<f64> for TimeArray<N> {
            type Output = TimeArray<N>;
            fn mul(self, rhs: f64) -> Self::Output {
                let mut result = self.clone();
                for val in result.values.as_mut_slice() { *val *= rhs; }
                result
            }
        }
        impl<const N : usize> DivAssign<f64> for TimeArray<N> {
            fn div_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val /= rhs; }
            }
        }
        impl<const N : usize> MulAssign<f64> for TimeArray<N> {
            fn mul_assign(&mut self, rhs: f64) {
                for val in self.values.as_mut_slice() { *val *= rhs; }
            }
        }
        impl<const N : usize> AddAssign<TimeArray<N>> for TimeArray<N> {
            fn add_assign(&mut self, rhs: TimeArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor =
                    rhs.unit.definition().convert_unchecked(self.unit.definition());
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val += rhs * factor;
                }
            }
        }
        impl<const N : usize> SubAssign<TimeArray<N>> for TimeArray<N> {
            fn sub_assign(&mut self, rhs: TimeArray<N>) {
                if rhs.values.len() != self.values.len() {
                        {
                            ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                    rhs.values.len(), self.values.len()));
                        };
                    }
                let factor = rhs.unit.convert_unchecked(self.unit);
                for (val, &rhs) in
                    self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                    {
                    *val -= rhs * factor;
                }
            }
        }
        use crate::vector_quantity::VecQuantity;
        impl From<TimeVec> for VecQuantity {
            fn from(input: TimeVec) -> Self {
                VecQuantity {
                    unit: input.unit.definition(),
                    values: input.values,
                }
            }
        }
        impl From<TimeUnit> for UnitDefinition {
            #[inline]
            fn from(value: TimeUnit) -> Self {
                match value {
                    TimeUnit::yottasecond => TimeUnit::get_yottasecond(),
                    TimeUnit::zettasecond => TimeUnit::get_zettasecond(),
                    TimeUnit::exasecond => TimeUnit::get_exasecond(),
                    TimeUnit::petasecond => TimeUnit::get_petasecond(),
                    TimeUnit::terasecond => TimeUnit::get_terasecond(),
                    TimeUnit::gigasecond => TimeUnit::get_gigasecond(),
                    TimeUnit::megasecond => TimeUnit::get_megasecond(),
                    TimeUnit::kilosecond => TimeUnit::get_kilosecond(),
                    TimeUnit::hectosecond => TimeUnit::get_hectosecond(),
                    TimeUnit::decasecond => TimeUnit::get_decasecond(),
                    TimeUnit::second => TimeUnit::get_second(),
                    TimeUnit::decisecond => TimeUnit::get_decisecond(),
                    TimeUnit::centisecond => TimeUnit::get_centisecond(),
                    TimeUnit::millisecond => TimeUnit::get_millisecond(),
                    TimeUnit::microsecond => TimeUnit::get_microsecond(),
                    TimeUnit::nanosecond => TimeUnit::get_nanosecond(),
                    TimeUnit::picosecond => TimeUnit::get_picosecond(),
                    TimeUnit::femtosecond => TimeUnit::get_femtosecond(),
                    TimeUnit::attosecond => TimeUnit::get_attosecond(),
                    TimeUnit::zeptosecond => TimeUnit::get_zeptosecond(),
                    TimeUnit::yoctosecond => TimeUnit::get_yoctosecond(),
                    TimeUnit::second_sidereal =>
                        TimeUnit::get_second_sidereal(),
                    TimeUnit::day => TimeUnit::get_day(),
                    TimeUnit::day_sidereal => TimeUnit::get_day_sidereal(),
                    TimeUnit::hour => TimeUnit::get_hour(),
                    TimeUnit::hour_sidereal => TimeUnit::get_hour_sidereal(),
                    TimeUnit::minute => TimeUnit::get_minute(),
                    TimeUnit::shake => TimeUnit::get_shake(),
                    TimeUnit::year => TimeUnit::get_year(),
                    TimeUnit::year_sidereal => TimeUnit::get_year_sidereal(),
                    TimeUnit::year_tropical => TimeUnit::get_year_tropical(),
                }
            }
        }
        impl TryFrom<&str> for TimeUnit {
            type Error = &'static str;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                let abbreviation_check: Option<TimeUnit> =
                    match value {
                        "Ys" => Some(TimeUnit::yottasecond),
                        "Zs" => Some(TimeUnit::zettasecond),
                        "Es" => Some(TimeUnit::exasecond),
                        "Ps" => Some(TimeUnit::petasecond),
                        "Ts" => Some(TimeUnit::terasecond),
                        "Gs" => Some(TimeUnit::gigasecond),
                        "Ms" => Some(TimeUnit::megasecond),
                        "ks" => Some(TimeUnit::kilosecond),
                        "hs" => Some(TimeUnit::hectosecond),
                        "das" => Some(TimeUnit::decasecond),
                        "s" => Some(TimeUnit::second),
                        "ds" => Some(TimeUnit::decisecond),
                        "cs" => Some(TimeUnit::centisecond),
                        "ms" => Some(TimeUnit::millisecond),
                        "s" => Some(TimeUnit::microsecond),
                        "ns" => Some(TimeUnit::nanosecond),
                        "ps" => Some(TimeUnit::picosecond),
                        "fs" => Some(TimeUnit::femtosecond),
                        "as" => Some(TimeUnit::attosecond),
                        "zs" => Some(TimeUnit::zeptosecond),
                        "ys" => Some(TimeUnit::yoctosecond),
                        "s (sidereal)" => Some(TimeUnit::second_sidereal),
                        "d" => Some(TimeUnit::day),
                        "d (sidereal)" => Some(TimeUnit::day_sidereal),
                        "h" => Some(TimeUnit::hour),
                        "h (sidereal)" => Some(TimeUnit::hour_sidereal),
                        "min" => Some(TimeUnit::minute),
                        "10.0 ns" => Some(TimeUnit::shake),
                        "a" => Some(TimeUnit::year),
                        "a (sidereal)" => Some(TimeUnit::year_sidereal),
                        "a (tropical)" => Some(TimeUnit::year_tropical),
                        _ => None,
                    };
                if abbreviation_check.is_some() {
                        return Ok(abbreviation_check.unwrap());
                    }
                let singular_check: Option<TimeUnit> =
                    match value {
                        "yottasecond" => Some(TimeUnit::yottasecond),
                        "zettasecond" => Some(TimeUnit::zettasecond),
                        "exasecond" => Some(TimeUnit::exasecond),
                        "petasecond" => Some(TimeUnit::petasecond),
                        "terasecond" => Some(TimeUnit::terasecond),
                        "gigasecond" => Some(TimeUnit::gigasecond),
                        "megasecond" => Some(TimeUnit::megasecond),
                        "kilosecond" => Some(TimeUnit::kilosecond),
                        "hectosecond" => Some(TimeUnit::hectosecond),
                        "decasecond" => Some(TimeUnit::decasecond),
                        "second" => Some(TimeUnit::second),
                        "decisecond" => Some(TimeUnit::decisecond),
                        "centisecond" => Some(TimeUnit::centisecond),
                        "millisecond" => Some(TimeUnit::millisecond),
                        "microsecond" => Some(TimeUnit::microsecond),
                        "nanosecond" => Some(TimeUnit::nanosecond),
                        "picosecond" => Some(TimeUnit::picosecond),
                        "femtosecond" => Some(TimeUnit::femtosecond),
                        "attosecond" => Some(TimeUnit::attosecond),
                        "zeptosecond" => Some(TimeUnit::zeptosecond),
                        "yoctosecond" => Some(TimeUnit::yoctosecond),
                        "second (sidereal)" => Some(TimeUnit::second_sidereal),
                        "day" => Some(TimeUnit::day),
                        "day (sidereal)" => Some(TimeUnit::day_sidereal),
                        "hour" => Some(TimeUnit::hour),
                        "hour (sidereal)" => Some(TimeUnit::hour_sidereal),
                        "minute" => Some(TimeUnit::minute),
                        "shake" => Some(TimeUnit::shake),
                        "year" => Some(TimeUnit::year),
                        "year (sidereal)" => Some(TimeUnit::year_sidereal),
                        "year (tropical)" => Some(TimeUnit::year_tropical),
                        _ => None,
                    };
                if singular_check.is_some() {
                        return Ok(singular_check.unwrap());
                    }
                let plural_check: Option<TimeUnit> =
                    match value {
                        "yottaseconds" => Some(TimeUnit::yottasecond),
                        "zettaseconds" => Some(TimeUnit::zettasecond),
                        "exaseconds" => Some(TimeUnit::exasecond),
                        "petaseconds" => Some(TimeUnit::petasecond),
                        "teraseconds" => Some(TimeUnit::terasecond),
                        "gigaseconds" => Some(TimeUnit::gigasecond),
                        "megaseconds" => Some(TimeUnit::megasecond),
                        "kiloseconds" => Some(TimeUnit::kilosecond),
                        "hectoseconds" => Some(TimeUnit::hectosecond),
                        "decaseconds" => Some(TimeUnit::decasecond),
                        "seconds" => Some(TimeUnit::second),
                        "deciseconds" => Some(TimeUnit::decisecond),
                        "centiseconds" => Some(TimeUnit::centisecond),
                        "milliseconds" => Some(TimeUnit::millisecond),
                        "microseconds" => Some(TimeUnit::microsecond),
                        "nanoseconds" => Some(TimeUnit::nanosecond),
                        "picoseconds" => Some(TimeUnit::picosecond),
                        "femtoseconds" => Some(TimeUnit::femtosecond),
                        "attoseconds" => Some(TimeUnit::attosecond),
                        "zeptoseconds" => Some(TimeUnit::zeptosecond),
                        "yoctoseconds" => Some(TimeUnit::yoctosecond),
                        "seconds (sidereal)" => Some(TimeUnit::second_sidereal),
                        "days" => Some(TimeUnit::day),
                        "days (sidereal)" => Some(TimeUnit::day_sidereal),
                        "hours" => Some(TimeUnit::hour),
                        "hours (sidereal)" => Some(TimeUnit::hour_sidereal),
                        "minutes" => Some(TimeUnit::minute),
                        "shakes" => Some(TimeUnit::shake),
                        "years" => Some(TimeUnit::year),
                        "years (sidereal)" => Some(TimeUnit::year_sidereal),
                        "years (tropical)" => Some(TimeUnit::year_tropical),
                        _ => None,
                    };
                if plural_check.is_some() {
                        Ok(plural_check.unwrap())
                    } else {
                       Err("Unit \"{value}\" not supported for quantity \"Time\"")
                   }
            }
        }
        impl core::fmt::Display for TimeUnit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    TimeUnit::yottasecond =>
                        f.write_fmt(format_args!("{0}", "yottasecond")),
                    TimeUnit::zettasecond =>
                        f.write_fmt(format_args!("{0}", "zettasecond")),
                    TimeUnit::exasecond =>
                        f.write_fmt(format_args!("{0}", "exasecond")),
                    TimeUnit::petasecond =>
                        f.write_fmt(format_args!("{0}", "petasecond")),
                    TimeUnit::terasecond =>
                        f.write_fmt(format_args!("{0}", "terasecond")),
                    TimeUnit::gigasecond =>
                        f.write_fmt(format_args!("{0}", "gigasecond")),
                    TimeUnit::megasecond =>
                        f.write_fmt(format_args!("{0}", "megasecond")),
                    TimeUnit::kilosecond =>
                        f.write_fmt(format_args!("{0}", "kilosecond")),
                    TimeUnit::hectosecond =>
                        f.write_fmt(format_args!("{0}", "hectosecond")),
                    TimeUnit::decasecond =>
                        f.write_fmt(format_args!("{0}", "decasecond")),
                    TimeUnit::second =>
                        f.write_fmt(format_args!("{0}", "second")),
                    TimeUnit::decisecond =>
                        f.write_fmt(format_args!("{0}", "decisecond")),
                    TimeUnit::centisecond =>
                        f.write_fmt(format_args!("{0}", "centisecond")),
                    TimeUnit::millisecond =>
                        f.write_fmt(format_args!("{0}", "millisecond")),
                    TimeUnit::microsecond =>
                        f.write_fmt(format_args!("{0}", "microsecond")),
                    TimeUnit::nanosecond =>
                        f.write_fmt(format_args!("{0}", "nanosecond")),
                    TimeUnit::picosecond =>
                        f.write_fmt(format_args!("{0}", "picosecond")),
                    TimeUnit::femtosecond =>
                        f.write_fmt(format_args!("{0}", "femtosecond")),
                    TimeUnit::attosecond =>
                        f.write_fmt(format_args!("{0}", "attosecond")),
                    TimeUnit::zeptosecond =>
                        f.write_fmt(format_args!("{0}", "zeptosecond")),
                    TimeUnit::yoctosecond =>
                        f.write_fmt(format_args!("{0}", "yoctosecond")),
                    TimeUnit::second_sidereal =>
                        f.write_fmt(format_args!("{0}", "second (sidereal)")),
                    TimeUnit::day => f.write_fmt(format_args!("{0}", "day")),
                    TimeUnit::day_sidereal =>
                        f.write_fmt(format_args!("{0}", "day (sidereal)")),
                    TimeUnit::hour => f.write_fmt(format_args!("{0}", "hour")),
                    TimeUnit::hour_sidereal =>
                        f.write_fmt(format_args!("{0}", "hour (sidereal)")),
                    TimeUnit::minute =>
                        f.write_fmt(format_args!("{0}", "minute")),
                    TimeUnit::shake =>
                        f.write_fmt(format_args!("{0}", "shake")),
                    TimeUnit::year => f.write_fmt(format_args!("{0}", "year")),
                    TimeUnit::year_sidereal =>
                        f.write_fmt(format_args!("{0}", "year (sidereal)")),
                    TimeUnit::year_tropical =>
                        f.write_fmt(format_args!("{0}", "year (tropical)")),
                }
            }
        }
    }
    #[cfg(any(feature = "Time", feature = "All"))]
    pub use crate::unit_definitions::time::TimeArray;
    #[cfg(any(feature = "Time", feature = "All"))]
    pub use crate::unit_definitions::time::Time;
    #[cfg(any(feature = "Time", feature = "All"))]
    pub use crate::unit_definitions::time::TimeVec;
    pub mod quantities {
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        pub use crate::unit_definitions::amount_of_substance::AmountOfSubstance;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Angle", feature = "All"))]
        pub use crate::unit_definitions::angle::Angle;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        pub use crate::unit_definitions::dimensionless::Dimensionless;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        pub use crate::unit_definitions::electric_current::ElectricCurrent;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Length", feature = "All"))]
        pub use crate::unit_definitions::length::Length;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Luminance", feature = "All"))]
        pub use crate::unit_definitions::luminance::Luminance;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Mass", feature = "All"))]
        pub use crate::unit_definitions::mass::Mass;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        pub use crate::unit_definitions::temperature_interval::TemperatureInterval;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Time", feature = "All"))]
        pub use crate::unit_definitions::time::Time;
        pub use crate::quantity::Quantity;
    }
    pub mod quantities_array {
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        pub use crate::unit_definitions::amount_of_substance::AmountOfSubstance;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Angle", feature = "All"))]
        pub use crate::unit_definitions::angle::Angle;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        pub use crate::unit_definitions::dimensionless::Dimensionless;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        pub use crate::unit_definitions::electric_current::ElectricCurrent;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Length", feature = "All"))]
        pub use crate::unit_definitions::length::Length;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Luminance", feature = "All"))]
        pub use crate::unit_definitions::luminance::Luminance;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Mass", feature = "All"))]
        pub use crate::unit_definitions::mass::Mass;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        pub use crate::unit_definitions::temperature_interval::TemperatureInterval;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Time", feature = "All"))]
        pub use crate::unit_definitions::time::Time;
        pub use crate::array_quantity::ArrayQuantity;
    }
    pub mod quantities_vector {
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        pub use crate::unit_definitions::amount_of_substance::AmountOfSubstance;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Angle", feature = "All"))]
        pub use crate::unit_definitions::angle::Angle;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        pub use crate::unit_definitions::dimensionless::Dimensionless;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        pub use crate::unit_definitions::electric_current::ElectricCurrent;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Length", feature = "All"))]
        pub use crate::unit_definitions::length::Length;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Luminance", feature = "All"))]
        pub use crate::unit_definitions::luminance::Luminance;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Mass", feature = "All"))]
        pub use crate::unit_definitions::mass::Mass;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        pub use crate::unit_definitions::temperature_interval::TemperatureInterval;
        #[allow(clippy :: eq_op)]
        #[cfg(any(feature = "Time", feature = "All"))]
        pub use crate::unit_definitions::time::Time;
        pub use crate::vector_quantity::VecQuantity;
    }
    pub mod units {
        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        pub use crate::unit_definitions::amount_of_substance::AmountOfSubstanceUnit;
        #[cfg(any(feature = "Angle", feature = "All"))]
        pub use crate::unit_definitions::angle::AngleUnit;
        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        pub use crate::unit_definitions::dimensionless::DimensionlessUnit;
        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        pub use crate::unit_definitions::electric_current::ElectricCurrentUnit;
        #[cfg(any(feature = "Length", feature = "All"))]
        pub use crate::unit_definitions::length::LengthUnit;
        #[cfg(any(feature = "Luminance", feature = "All"))]
        pub use crate::unit_definitions::luminance::LuminanceUnit;
        #[cfg(any(feature = "Mass", feature = "All"))]
        pub use crate::unit_definitions::mass::MassUnit;
        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        pub use crate::unit_definitions::temperature_interval::TemperatureIntervalUnit;
        #[cfg(any(feature = "Time", feature = "All"))]
        pub use crate::unit_definitions::time::TimeUnit;
    }
    #[doc = ""]
    #[doc =
    " A list of unit types supported for the library (given feature flags selected)."]
    #[doc = " "]
    pub enum UnitTypes {

        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        AmountOfSubstance,

        #[cfg(any(feature = "Angle", feature = "All"))]
        Angle,

        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        Dimensionless,

        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        ElectricCurrent,

        #[cfg(any(feature = "Length", feature = "All"))]
        Length,

        #[cfg(any(feature = "Luminance", feature = "All"))]
        Luminance,

        #[cfg(any(feature = "Mass", feature = "All"))]
        Mass,

        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        TemperatureInterval,

        #[cfg(any(feature = "Time", feature = "All"))]
        Time,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for UnitTypes { }
    #[automatically_derived]
    impl ::core::clone::Clone for UnitTypes {
        #[inline]
        fn clone(&self) -> UnitTypes { *self }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UnitTypes {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f,
                match self {
                    UnitTypes::AmountOfSubstance => "AmountOfSubstance",
                    UnitTypes::Angle => "Angle",
                    UnitTypes::Dimensionless => "Dimensionless",
                    UnitTypes::ElectricCurrent => "ElectricCurrent",
                    UnitTypes::Length => "Length",
                    UnitTypes::Luminance => "Luminance",
                    UnitTypes::Mass => "Mass",
                    UnitTypes::TemperatureInterval => "TemperatureInterval",
                    UnitTypes::Time => "Time",
                })
        }
    }
    impl UnitTypes {
        #[doc = ""]
        #[doc = " Retrieve list of units available for this `UnitType`."]
        #[doc = " "]
        pub fn units(&self) -> &'static [&'static str] {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    UnitTypes::AmountOfSubstance =>
                    amount_of_substance::AmountOfSubstanceUnit::units(),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    UnitTypes::Angle =>
                    angle::AngleUnit::units(),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    UnitTypes::Dimensionless =>
                    dimensionless::DimensionlessUnit::units(),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    UnitTypes::ElectricCurrent =>
                    electric_current::ElectricCurrentUnit::units(),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    UnitTypes::Length =>
                    length::LengthUnit::units(),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    UnitTypes::Luminance =>
                    luminance::LuminanceUnit::units(),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    UnitTypes::Mass =>
                    mass::MassUnit::units(),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    UnitTypes::TemperatureInterval =>
                    temperature_interval::TemperatureIntervalUnit::units(),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    UnitTypes::Time => time::TimeUnit::units(),
            }
        }
        #[doc = ""]
        #[doc = " Convert a given unit string to the Corresponding `Units`"]
        #[doc = " "]
        pub fn to_unit(&self, unit_str: &str)
            -> Result<crate::Units, &'static str> {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    UnitTypes::AmountOfSubstance => {
                    match crate::units::AmountOfSubstanceUnit::try_from(unit_str)
                        {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    UnitTypes::Angle => {
                    match crate::units::AngleUnit::try_from(unit_str) {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    UnitTypes::Dimensionless => {
                    match crate::units::DimensionlessUnit::try_from(unit_str) {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    UnitTypes::ElectricCurrent => {
                    match crate::units::ElectricCurrentUnit::try_from(unit_str)
                        {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    UnitTypes::Length => {
                    match crate::units::LengthUnit::try_from(unit_str) {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    UnitTypes::Luminance => {
                    match crate::units::LuminanceUnit::try_from(unit_str) {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    UnitTypes::Mass => {
                    match crate::units::MassUnit::try_from(unit_str) {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    UnitTypes::TemperatureInterval => {
                    match crate::units::TemperatureIntervalUnit::try_from(unit_str)
                        {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    UnitTypes::Time => {
                    match crate::units::TimeUnit::try_from(unit_str) {
                        Ok(r) => Ok(r.into()),
                        Err(err) => Err(err),
                    }
                }
            }
        }
    }
    #[doc = ""]
    #[doc =
    " A wrapper to hold all quantities supported by this library. It is analogous to `Units``, "]
    #[doc =
    " but when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit. "]
    #[doc = " "]
    pub enum Quantities {

        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        #[schema(title = "AmountOfSubstance")]
        AmountOfSubstance(AmountOfSubstance),

        #[cfg(any(feature = "Angle", feature = "All"))]
        #[schema(title = "Angle")]
        Angle(Angle),

        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        #[schema(title = "Dimensionless")]
        Dimensionless(Dimensionless),

        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        #[schema(title = "ElectricCurrent")]
        ElectricCurrent(ElectricCurrent),

        #[cfg(any(feature = "Length", feature = "All"))]
        #[schema(title = "Length")]
        Length(Length),

        #[cfg(any(feature = "Luminance", feature = "All"))]
        #[schema(title = "Luminance")]
        Luminance(Luminance),

        #[cfg(any(feature = "Mass", feature = "All"))]
        #[schema(title = "Mass")]
        Mass(Mass),

        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        #[schema(title = "TemperatureInterval")]
        TemperatureInterval(TemperatureInterval),

        #[cfg(any(feature = "Time", feature = "All"))]
        #[schema(title = "Time")]
        Time(Time),
    }
    impl utoipa::__dev::ComposeSchema for Quantities {
        fn compose(mut generics:
                Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
            -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
            Into::<utoipa::openapi::schema::OneOfBuilder>::into(utoipa::openapi::OneOf::with_capacity(9usize)).item(utoipa::openapi::schema::Object::builder().property("AmountOfSubstance",
                                                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                                let res =
                                                                                    ::alloc::fmt::format(format_args!("{0}",
                                                                                            <AmountOfSubstance as utoipa::ToSchema>::name()));
                                                                                res
                                                                            }))).required("AmountOfSubstance").title(Some("AmountOfSubstance"))).item(utoipa::openapi::schema::Object::builder().property("Angle",
                                                                utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                            let res =
                                                                                ::alloc::fmt::format(format_args!("{0}",
                                                                                        <Angle as utoipa::ToSchema>::name()));
                                                                            res
                                                                        }))).required("Angle").title(Some("Angle"))).item(utoipa::openapi::schema::Object::builder().property("Dimensionless",
                                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                        let res =
                                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                                    <Dimensionless as utoipa::ToSchema>::name()));
                                                                        res
                                                                    }))).required("Dimensionless").title(Some("Dimensionless"))).item(utoipa::openapi::schema::Object::builder().property("ElectricCurrent",
                                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                    let res =
                                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                                <ElectricCurrent as utoipa::ToSchema>::name()));
                                                                    res
                                                                }))).required("ElectricCurrent").title(Some("ElectricCurrent"))).item(utoipa::openapi::schema::Object::builder().property("Length",
                                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                let res =
                                                                    ::alloc::fmt::format(format_args!("{0}",
                                                                            <Length as utoipa::ToSchema>::name()));
                                                                res
                                                            }))).required("Length").title(Some("Length"))).item(utoipa::openapi::schema::Object::builder().property("Luminance",
                                                utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                            let res =
                                                                ::alloc::fmt::format(format_args!("{0}",
                                                                        <Luminance as utoipa::ToSchema>::name()));
                                                            res
                                                        }))).required("Luminance").title(Some("Luminance"))).item(utoipa::openapi::schema::Object::builder().property("Mass",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <Mass as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("Mass").title(Some("Mass"))).item(utoipa::openapi::schema::Object::builder().property("TemperatureInterval",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <TemperatureInterval as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("TemperatureInterval").title(Some("TemperatureInterval"))).item(utoipa::openapi::schema::Object::builder().property("Time",
                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                let res =
                                                    ::alloc::fmt::format(format_args!("{0}",
                                                            <Time as utoipa::ToSchema>::name()));
                                                res
                                            }))).required("Time").title(Some("Time"))).description(Some("\nA wrapper to hold all quantities supported by this library. It is analogous to `Units``,\nbut when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit.\n")).into()
        }
    }
    impl utoipa::ToSchema for Quantities {
        fn name() -> std::borrow::Cow<'static, str> {
            std::borrow::Cow::Borrowed("Quantities")
        }
        fn schemas(schemas:
                &mut Vec<(String,
                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
            schemas.extend([(String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <AmountOfSubstance as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <AmountOfSubstance as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <Angle as utoipa::ToSchema>::name()));
                                        res
                                    })), <Angle as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <Dimensionless as utoipa::ToSchema>::name()));
                                        res
                                    })), <Dimensionless as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <ElectricCurrent as utoipa::ToSchema>::name()));
                                        res
                                    })), <ElectricCurrent as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <Length as utoipa::ToSchema>::name()));
                                        res
                                    })), <Length as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <Luminance as utoipa::ToSchema>::name()));
                                        res
                                    })), <Luminance as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <Mass as utoipa::ToSchema>::name()));
                                        res
                                    })), <Mass as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <TemperatureInterval as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <TemperatureInterval as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <Time as utoipa::ToSchema>::name()));
                                        res
                                    })), <Time as utoipa::PartialSchema>::schema())]);
            <AmountOfSubstance as utoipa::ToSchema>::schemas(schemas);
            <Angle as utoipa::ToSchema>::schemas(schemas);
            <Dimensionless as utoipa::ToSchema>::schemas(schemas);
            <ElectricCurrent as utoipa::ToSchema>::schemas(schemas);
            <Length as utoipa::ToSchema>::schemas(schemas);
            <Luminance as utoipa::ToSchema>::schemas(schemas);
            <Mass as utoipa::ToSchema>::schemas(schemas);
            <TemperatureInterval as utoipa::ToSchema>::schemas(schemas);
            <Time as utoipa::ToSchema>::schemas(schemas);
            ;
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Quantities {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    match *self {
                        Quantities::AmountOfSubstance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 0u32, "AmountOfSubstance", __field0),
                        Quantities::Angle(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 1u32, "Angle", __field0),
                        Quantities::Dimensionless(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 2u32, "Dimensionless", __field0),
                        Quantities::ElectricCurrent(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 3u32, "ElectricCurrent", __field0),
                        Quantities::Length(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 4u32, "Length", __field0),
                        Quantities::Luminance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 5u32, "Luminance", __field0),
                        Quantities::Mass(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 6u32, "Mass", __field0),
                        Quantities::TemperatureInterval(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 7u32, "TemperatureInterval", __field0),
                        Quantities::Time(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Quantities", 8u32, "Time", __field0),
                    }
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Quantities {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "variant identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ =>
                                    _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 9")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                "Angle" => _serde::__private::Ok(__Field::__field1),
                                "Dimensionless" => _serde::__private::Ok(__Field::__field2),
                                "ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                "Length" => _serde::__private::Ok(__Field::__field4),
                                "Luminance" => _serde::__private::Ok(__Field::__field5),
                                "Mass" => _serde::__private::Ok(__Field::__field6),
                                "TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                "Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                b"Angle" => _serde::__private::Ok(__Field::__field1),
                                b"Dimensionless" =>
                                    _serde::__private::Ok(__Field::__field2),
                                b"ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                b"Length" => _serde::__private::Ok(__Field::__field4),
                                b"Luminance" => _serde::__private::Ok(__Field::__field5),
                                b"Mass" => _serde::__private::Ok(__Field::__field6),
                                b"TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                b"Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Quantities>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Quantities;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "enum Quantities")
                        }
                        fn visit_enum<__A>(self, __data: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::EnumAccess<'de> {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<AmountOfSubstance>(__variant),
                                        Quantities::AmountOfSubstance),
                                (__Field::__field1, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<Angle>(__variant),
                                        Quantities::Angle),
                                (__Field::__field2, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<Dimensionless>(__variant),
                                        Quantities::Dimensionless),
                                (__Field::__field3, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<ElectricCurrent>(__variant),
                                        Quantities::ElectricCurrent),
                                (__Field::__field4, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<Length>(__variant),
                                        Quantities::Length),
                                (__Field::__field5, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<Luminance>(__variant),
                                        Quantities::Luminance),
                                (__Field::__field6, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<Mass>(__variant),
                                        Quantities::Mass),
                                (__Field::__field7, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<TemperatureInterval>(__variant),
                                        Quantities::TemperatureInterval),
                                (__Field::__field8, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<Time>(__variant),
                                        Quantities::Time),
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] =
                        &["AmountOfSubstance", "Angle", "Dimensionless",
                                    "ElectricCurrent", "Length", "Luminance", "Mass",
                                    "TemperatureInterval", "Time"];
                    _serde::Deserializer::deserialize_enum(__deserializer,
                        "Quantities", VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Quantities>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    #[automatically_derived]
    impl ::core::marker::Copy for Quantities { }
    #[automatically_derived]
    impl ::core::clone::Clone for Quantities {
        #[inline]
        fn clone(&self) -> Quantities {
            let _: ::core::clone::AssertParamIsClone<AmountOfSubstance>;
            let _: ::core::clone::AssertParamIsClone<Angle>;
            let _: ::core::clone::AssertParamIsClone<Dimensionless>;
            let _: ::core::clone::AssertParamIsClone<ElectricCurrent>;
            let _: ::core::clone::AssertParamIsClone<Length>;
            let _: ::core::clone::AssertParamIsClone<Luminance>;
            let _: ::core::clone::AssertParamIsClone<Mass>;
            let _: ::core::clone::AssertParamIsClone<TemperatureInterval>;
            let _: ::core::clone::AssertParamIsClone<Time>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Quantities {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Quantities::AmountOfSubstance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "AmountOfSubstance", &__self_0),
                Quantities::Angle(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Angle", &__self_0),
                Quantities::Dimensionless(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Dimensionless", &__self_0),
                Quantities::ElectricCurrent(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "ElectricCurrent", &__self_0),
                Quantities::Length(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Length", &__self_0),
                Quantities::Luminance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Luminance", &__self_0),
                Quantities::Mass(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Mass",
                        &__self_0),
                Quantities::TemperatureInterval(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "TemperatureInterval", &__self_0),
                Quantities::Time(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Time",
                        &__self_0),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Quantities { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Quantities {
        #[inline]
        fn eq(&self, other: &Quantities) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr &&
                match (self, other) {
                    (Quantities::AmountOfSubstance(__self_0),
                        Quantities::AmountOfSubstance(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Quantities::Angle(__self_0), Quantities::Angle(__arg1_0))
                        => __self_0 == __arg1_0,
                    (Quantities::Dimensionless(__self_0),
                        Quantities::Dimensionless(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Quantities::ElectricCurrent(__self_0),
                        Quantities::ElectricCurrent(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Quantities::Length(__self_0), Quantities::Length(__arg1_0))
                        => __self_0 == __arg1_0,
                    (Quantities::Luminance(__self_0),
                        Quantities::Luminance(__arg1_0)) => __self_0 == __arg1_0,
                    (Quantities::Mass(__self_0), Quantities::Mass(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Quantities::TemperatureInterval(__self_0),
                        Quantities::TemperatureInterval(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Quantities::Time(__self_0), Quantities::Time(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl Quantities {
        #[doc =
        " Get the `Units` enumeration associated with a given `Quantities` enumeration."]
        pub fn unit(&self) -> Units {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Quantities::AmountOfSubstance(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Quantities::Angle(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Quantities::Dimensionless(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Quantities::ElectricCurrent(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Quantities::Length(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Quantities::Luminance(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Quantities::Mass(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Quantities::TemperatureInterval(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Quantities::Time(x) => crate::Units::from(x.unit),
            }
        }
        #[doc =
        " Try to convert to the unit specified by a given `Units` enumeration."]
        pub fn try_convert(&self, unit: Units)
            -> Result<Quantities, RuntimeUnitError> {
            use crate::traits::FixedQuantity;
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Quantities::AmountOfSubstance(x) => {
                    Ok(Quantities::AmountOfSubstance(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Quantities::Angle(x) => {
                    Ok(Quantities::Angle(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Quantities::Dimensionless(x) => {
                    Ok(Quantities::Dimensionless(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Quantities::ElectricCurrent(x) => {
                    Ok(Quantities::ElectricCurrent(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Quantities::Length(x) => {
                    Ok(Quantities::Length(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Quantities::Luminance(x) => {
                    Ok(Quantities::Luminance(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Quantities::Mass(x) => {
                    Ok(Quantities::Mass(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Quantities::TemperatureInterval(x) => {
                    Ok(Quantities::TemperatureInterval(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Quantities::Time(x) => {
                    Ok(Quantities::Time(x.try_convert(unit)?))
                }
            }
        }
        #[doc = " Create a new quantity from a given value and unit"]
        pub fn new(value: f64, unit: Units) -> Quantities {
            match unit
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) => {
                    Quantities::AmountOfSubstance(AmountOfSubstance::new(value,
                            x))
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) => {
                    Quantities::Angle(Angle::new(value, x))
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) => {
                    Quantities::Dimensionless(Dimensionless::new(value, x))
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) => {
                    Quantities::ElectricCurrent(ElectricCurrent::new(value, x))
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) => {
                    Quantities::Length(Length::new(value, x))
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) => {
                    Quantities::Luminance(Luminance::new(value, x))
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) => {
                    Quantities::Mass(Mass::new(value, x))
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) => {
                    Quantities::TemperatureInterval(TemperatureInterval::new(value,
                            x))
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) => {
                    Quantities::Time(Time::new(value, x))
                }
            }
        }
        #[doc = " Get the value associated with quantity."]
        pub fn value(&self) -> f64 { Quantity::from(*self).value() }
    }
    #[doc =
    " A means to create a default quantity with a given set of units."]
    impl From<Units> for Quantities {
        fn from(value: Units) -> Self {
            match value
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) =>
                    Quantities::AmountOfSubstance(quantities::AmountOfSubstance::new(0.0,
                            x)),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) =>
                    Quantities::Angle(quantities::Angle::new(0.0,
                            x)),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) =>
                    Quantities::Dimensionless(quantities::Dimensionless::new(0.0,
                            x)),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) =>
                    Quantities::ElectricCurrent(quantities::ElectricCurrent::new(0.0,
                            x)),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) =>
                    Quantities::Length(quantities::Length::new(0.0,
                            x)),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) =>
                    Quantities::Luminance(quantities::Luminance::new(0.0,
                            x)),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) =>
                    Quantities::Mass(quantities::Mass::new(0.0,
                            x)),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) =>
                    Quantities::TemperatureInterval(quantities::TemperatureInterval::new(0.0,
                            x)),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) =>
                    Quantities::Time(quantities::Time::new(0.0, x)),
            }
        }
    }
    impl From<Quantities> for Quantity {
        fn from(value: Quantities) -> Self {
            match value
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Quantities::AmountOfSubstance(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: amount_of_substance::AMOUNTOFSUBSTANCE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Quantities::Angle(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: angle::ANGLE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Quantities::Dimensionless(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: dimensionless::DIMENSIONLESS_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Quantities::ElectricCurrent(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: electric_current::ELECTRICCURRENT_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Quantities::Length(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: length::LENGTH_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Quantities::Luminance(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: luminance::LUMINANCE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Quantities::Mass(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: mass::MASS_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Quantities::TemperatureInterval(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: temperature_interval::TEMPERATUREINTERVAL_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Quantities::Time(x) =>
                    Quantity {
                        value: x.value,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: time::TIME_UNIT_BASE,
                        },
                    },
            }
        }
    }
    impl ToString for Quantities {
        fn to_string(&self) -> String {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Quantities::AmountOfSubstance(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Quantities::Angle(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Quantities::Dimensionless(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Quantities::ElectricCurrent(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Quantities::Length(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Quantities::Luminance(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Quantities::Mass(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Quantities::TemperatureInterval(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Quantities::Time(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0} {1}", x.value(),
                                        x.unit.abbreviation()));
                            res
                        }),
            }
        }
    }
    #[doc = ""]
    #[doc =
    " A wrapper to hold all available units supported by the library. Contains utilities to convert from"]
    #[doc =
    " a given arbitrary unit to the underlying `Quantity` that is used to perform unit conversion calculations."]
    #[doc = " "]
    pub enum Units {

        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        #[schema(title = "AmountOfSubstanceUnit")]
        AmountOfSubstance(AmountOfSubstanceUnit),

        #[cfg(any(feature = "Angle", feature = "All"))]
        #[schema(title = "AngleUnit")]
        Angle(AngleUnit),

        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        #[schema(title = "DimensionlessUnit")]
        Dimensionless(DimensionlessUnit),

        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        #[schema(title = "ElectricCurrentUnit")]
        ElectricCurrent(ElectricCurrentUnit),

        #[cfg(any(feature = "Length", feature = "All"))]
        #[schema(title = "LengthUnit")]
        Length(LengthUnit),

        #[cfg(any(feature = "Luminance", feature = "All"))]
        #[schema(title = "LuminanceUnit")]
        Luminance(LuminanceUnit),

        #[cfg(any(feature = "Mass", feature = "All"))]
        #[schema(title = "MassUnit")]
        Mass(MassUnit),

        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        #[schema(title = "TemperatureIntervalUnit")]
        TemperatureInterval(TemperatureIntervalUnit),

        #[cfg(any(feature = "Time", feature = "All"))]
        #[schema(title = "TimeUnit")]
        Time(TimeUnit),
    }
    impl utoipa::__dev::ComposeSchema for Units {
        fn compose(mut generics:
                Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
            -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
            Into::<utoipa::openapi::schema::OneOfBuilder>::into(utoipa::openapi::OneOf::with_capacity(9usize)).item(utoipa::openapi::schema::Object::builder().property("AmountOfSubstance",
                                                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                                let res =
                                                                                    ::alloc::fmt::format(format_args!("{0}",
                                                                                            <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                                                                res
                                                                            }))).required("AmountOfSubstance").title(Some("AmountOfSubstanceUnit"))).item(utoipa::openapi::schema::Object::builder().property("Angle",
                                                                utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                            let res =
                                                                                ::alloc::fmt::format(format_args!("{0}",
                                                                                        <AngleUnit as utoipa::ToSchema>::name()));
                                                                            res
                                                                        }))).required("Angle").title(Some("AngleUnit"))).item(utoipa::openapi::schema::Object::builder().property("Dimensionless",
                                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                        let res =
                                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                                    <DimensionlessUnit as utoipa::ToSchema>::name()));
                                                                        res
                                                                    }))).required("Dimensionless").title(Some("DimensionlessUnit"))).item(utoipa::openapi::schema::Object::builder().property("ElectricCurrent",
                                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                    let res =
                                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                                <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                                                    res
                                                                }))).required("ElectricCurrent").title(Some("ElectricCurrentUnit"))).item(utoipa::openapi::schema::Object::builder().property("Length",
                                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                let res =
                                                                    ::alloc::fmt::format(format_args!("{0}",
                                                                            <LengthUnit as utoipa::ToSchema>::name()));
                                                                res
                                                            }))).required("Length").title(Some("LengthUnit"))).item(utoipa::openapi::schema::Object::builder().property("Luminance",
                                                utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                            let res =
                                                                ::alloc::fmt::format(format_args!("{0}",
                                                                        <LuminanceUnit as utoipa::ToSchema>::name()));
                                                            res
                                                        }))).required("Luminance").title(Some("LuminanceUnit"))).item(utoipa::openapi::schema::Object::builder().property("Mass",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <MassUnit as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("Mass").title(Some("MassUnit"))).item(utoipa::openapi::schema::Object::builder().property("TemperatureInterval",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("TemperatureInterval").title(Some("TemperatureIntervalUnit"))).item(utoipa::openapi::schema::Object::builder().property("Time",
                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                let res =
                                                    ::alloc::fmt::format(format_args!("{0}",
                                                            <TimeUnit as utoipa::ToSchema>::name()));
                                                res
                                            }))).required("Time").title(Some("TimeUnit"))).description(Some("\nA wrapper to hold all available units supported by the library. Contains utilities to convert from\na given arbitrary unit to the underlying `Quantity` that is used to perform unit conversion calculations.\n")).into()
        }
    }
    impl utoipa::ToSchema for Units {
        fn name() -> std::borrow::Cow<'static, str> {
            std::borrow::Cow::Borrowed("Units")
        }
        fn schemas(schemas:
                &mut Vec<(String,
                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
            schemas.extend([(String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <AmountOfSubstanceUnit as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <AmountOfSubstanceUnit as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <AngleUnit as utoipa::ToSchema>::name()));
                                        res
                                    })), <AngleUnit as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <DimensionlessUnit as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <DimensionlessUnit as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <ElectricCurrentUnit as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <ElectricCurrentUnit as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <LengthUnit as utoipa::ToSchema>::name()));
                                        res
                                    })), <LengthUnit as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <LuminanceUnit as utoipa::ToSchema>::name()));
                                        res
                                    })), <LuminanceUnit as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <MassUnit as utoipa::ToSchema>::name()));
                                        res
                                    })), <MassUnit as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <TemperatureIntervalUnit as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <TemperatureIntervalUnit as
                                    utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <TimeUnit as utoipa::ToSchema>::name()));
                                        res
                                    })), <TimeUnit as utoipa::PartialSchema>::schema())]);
            <AmountOfSubstanceUnit as utoipa::ToSchema>::schemas(schemas);
            <AngleUnit as utoipa::ToSchema>::schemas(schemas);
            <DimensionlessUnit as utoipa::ToSchema>::schemas(schemas);
            <ElectricCurrentUnit as utoipa::ToSchema>::schemas(schemas);
            <LengthUnit as utoipa::ToSchema>::schemas(schemas);
            <LuminanceUnit as utoipa::ToSchema>::schemas(schemas);
            <MassUnit as utoipa::ToSchema>::schemas(schemas);
            <TemperatureIntervalUnit as utoipa::ToSchema>::schemas(schemas);
            <TimeUnit as utoipa::ToSchema>::schemas(schemas);
            ;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Units {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state);
            match self {
                Units::AmountOfSubstance(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::Angle(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::Dimensionless(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::ElectricCurrent(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::Length(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::Luminance(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::Mass(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::TemperatureInterval(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
                Units::Time(__self_0) =>
                    ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Units {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    match *self {
                        Units::AmountOfSubstance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 0u32, "AmountOfSubstance", __field0),
                        Units::Angle(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 1u32, "Angle", __field0),
                        Units::Dimensionless(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 2u32, "Dimensionless", __field0),
                        Units::ElectricCurrent(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 3u32, "ElectricCurrent", __field0),
                        Units::Length(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 4u32, "Length", __field0),
                        Units::Luminance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 5u32, "Luminance", __field0),
                        Units::Mass(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 6u32, "Mass", __field0),
                        Units::TemperatureInterval(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 7u32, "TemperatureInterval", __field0),
                        Units::Time(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "Units", 8u32, "Time", __field0),
                    }
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Units {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "variant identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ =>
                                    _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 9")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                "Angle" => _serde::__private::Ok(__Field::__field1),
                                "Dimensionless" => _serde::__private::Ok(__Field::__field2),
                                "ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                "Length" => _serde::__private::Ok(__Field::__field4),
                                "Luminance" => _serde::__private::Ok(__Field::__field5),
                                "Mass" => _serde::__private::Ok(__Field::__field6),
                                "TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                "Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                b"Angle" => _serde::__private::Ok(__Field::__field1),
                                b"Dimensionless" =>
                                    _serde::__private::Ok(__Field::__field2),
                                b"ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                b"Length" => _serde::__private::Ok(__Field::__field4),
                                b"Luminance" => _serde::__private::Ok(__Field::__field5),
                                b"Mass" => _serde::__private::Ok(__Field::__field6),
                                b"TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                b"Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Units>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Units;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "enum Units")
                        }
                        fn visit_enum<__A>(self, __data: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::EnumAccess<'de> {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<AmountOfSubstanceUnit>(__variant),
                                        Units::AmountOfSubstance),
                                (__Field::__field1, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<AngleUnit>(__variant),
                                        Units::Angle),
                                (__Field::__field2, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<DimensionlessUnit>(__variant),
                                        Units::Dimensionless),
                                (__Field::__field3, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<ElectricCurrentUnit>(__variant),
                                        Units::ElectricCurrent),
                                (__Field::__field4, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<LengthUnit>(__variant),
                                        Units::Length),
                                (__Field::__field5, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<LuminanceUnit>(__variant),
                                        Units::Luminance),
                                (__Field::__field6, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<MassUnit>(__variant),
                                        Units::Mass),
                                (__Field::__field7, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<TemperatureIntervalUnit>(__variant),
                                        Units::TemperatureInterval),
                                (__Field::__field8, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<TimeUnit>(__variant),
                                        Units::Time),
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] =
                        &["AmountOfSubstance", "Angle", "Dimensionless",
                                    "ElectricCurrent", "Length", "Luminance", "Mass",
                                    "TemperatureInterval", "Time"];
                    _serde::Deserializer::deserialize_enum(__deserializer,
                        "Units", VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Units>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    #[automatically_derived]
    impl ::core::marker::Copy for Units { }
    #[automatically_derived]
    impl ::core::clone::Clone for Units {
        #[inline]
        fn clone(&self) -> Units {
            let _: ::core::clone::AssertParamIsClone<AmountOfSubstanceUnit>;
            let _: ::core::clone::AssertParamIsClone<AngleUnit>;
            let _: ::core::clone::AssertParamIsClone<DimensionlessUnit>;
            let _: ::core::clone::AssertParamIsClone<ElectricCurrentUnit>;
            let _: ::core::clone::AssertParamIsClone<LengthUnit>;
            let _: ::core::clone::AssertParamIsClone<LuminanceUnit>;
            let _: ::core::clone::AssertParamIsClone<MassUnit>;
            let _: ::core::clone::AssertParamIsClone<TemperatureIntervalUnit>;
            let _: ::core::clone::AssertParamIsClone<TimeUnit>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Units {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Units::AmountOfSubstance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "AmountOfSubstance", &__self_0),
                Units::Angle(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Angle", &__self_0),
                Units::Dimensionless(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Dimensionless", &__self_0),
                Units::ElectricCurrent(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "ElectricCurrent", &__self_0),
                Units::Length(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Length", &__self_0),
                Units::Luminance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Luminance", &__self_0),
                Units::Mass(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Mass",
                        &__self_0),
                Units::TemperatureInterval(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "TemperatureInterval", &__self_0),
                Units::Time(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Time",
                        &__self_0),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Units { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Units {
        #[inline]
        fn eq(&self, other: &Units) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr &&
                match (self, other) {
                    (Units::AmountOfSubstance(__self_0),
                        Units::AmountOfSubstance(__arg1_0)) => __self_0 == __arg1_0,
                    (Units::Angle(__self_0), Units::Angle(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Units::Dimensionless(__self_0),
                        Units::Dimensionless(__arg1_0)) => __self_0 == __arg1_0,
                    (Units::ElectricCurrent(__self_0),
                        Units::ElectricCurrent(__arg1_0)) => __self_0 == __arg1_0,
                    (Units::Length(__self_0), Units::Length(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Units::Luminance(__self_0), Units::Luminance(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Units::Mass(__self_0), Units::Mass(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Units::TemperatureInterval(__self_0),
                        Units::TemperatureInterval(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (Units::Time(__self_0), Units::Time(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Units {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<AmountOfSubstanceUnit>;
            let _: ::core::cmp::AssertParamIsEq<AngleUnit>;
            let _: ::core::cmp::AssertParamIsEq<DimensionlessUnit>;
            let _: ::core::cmp::AssertParamIsEq<ElectricCurrentUnit>;
            let _: ::core::cmp::AssertParamIsEq<LengthUnit>;
            let _: ::core::cmp::AssertParamIsEq<LuminanceUnit>;
            let _: ::core::cmp::AssertParamIsEq<MassUnit>;
            let _: ::core::cmp::AssertParamIsEq<TemperatureIntervalUnit>;
            let _: ::core::cmp::AssertParamIsEq<TimeUnit>;
        }
    }
    impl From<Units> for crate::units_base::UnitDefinition {
        fn from(value: Units) -> Self {
            match value
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: amount_of_substance::AMOUNTOFSUBSTANCE_UNIT_BASE,
                    },
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: angle::ANGLE_UNIT_BASE,
                    },
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: dimensionless::DIMENSIONLESS_UNIT_BASE,
                    },
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: electric_current::ELECTRICCURRENT_UNIT_BASE,
                    },
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: length::LENGTH_UNIT_BASE,
                    },
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: luminance::LUMINANCE_UNIT_BASE,
                    },
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: mass::MASS_UNIT_BASE,
                    },
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: temperature_interval::TEMPERATUREINTERVAL_UNIT_BASE,
                    },
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) =>
                    UnitDefinition {
                        multiplier: x.multiplier(),
                        base: time::TIME_UNIT_BASE,
                    },
            }
        }
    }
    impl core::fmt::Display for Units {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) =>
                    f.write_fmt(format_args!("{0}",
                            x.singular())),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) =>
                    f.write_fmt(format_args!("{0}", x.singular())),
            }
        }
    }
    impl Units {
        #[doc = ""]
        #[doc =
        " Convert a given \'value\' expressed in the given `Units` into a convertible `Quantity`"]
        #[doc = " "]
        pub fn to_quantity(&self, value: f64) -> crate::quantity::Quantity {
            let unit: UnitDefinition = (*self).into();
            crate::quantity::Quantity { unit, value }
        }
        #[doc = ""]
        #[doc = " Get list of units available for this `Units` type"]
        #[doc = " "]
        pub fn units(&self) -> &'static [&'static str] {
            match *self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(_) =>
                    amount_of_substance::AmountOfSubstanceUnit::units(),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(_) =>
                    angle::AngleUnit::units(),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(_) =>
                    dimensionless::DimensionlessUnit::units(),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(_) =>
                    electric_current::ElectricCurrentUnit::units(),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(_) =>
                    length::LengthUnit::units(),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(_) =>
                    luminance::LuminanceUnit::units(),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(_) =>
                    mass::MassUnit::units(),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(_) =>
                    temperature_interval::TemperatureIntervalUnit::units(),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(_) => time::TimeUnit::units(),
            }
        }
    }
    use crate::{
        create_multivalue_quantities_vec_enum,
        create_multivalue_quantities_array_enum,
    };
    #[doc = ""]
    #[doc =
    " A wrapper to hold all QuantitiesVec supported by this library. It is analogous to `Units``, "]
    #[doc =
    " but when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit. "]
    #[doc = " "]
    pub enum QuantitiesVec {

        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        #[schema(title = "AmountOfSubstance")]
        AmountOfSubstance(AmountOfSubstanceVec),

        #[cfg(any(feature = "Angle", feature = "All"))]
        #[schema(title = "Angle")]
        Angle(AngleVec),

        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        #[schema(title = "Dimensionless")]
        Dimensionless(DimensionlessVec),

        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        #[schema(title = "ElectricCurrent")]
        ElectricCurrent(ElectricCurrentVec),

        #[cfg(any(feature = "Length", feature = "All"))]
        #[schema(title = "Length")]
        Length(LengthVec),

        #[cfg(any(feature = "Luminance", feature = "All"))]
        #[schema(title = "Luminance")]
        Luminance(LuminanceVec),

        #[cfg(any(feature = "Mass", feature = "All"))]
        #[schema(title = "Mass")]
        Mass(MassVec),

        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        #[schema(title = "TemperatureInterval")]
        TemperatureInterval(TemperatureIntervalVec),

        #[cfg(any(feature = "Time", feature = "All"))]
        #[schema(title = "Time")]
        Time(TimeVec),
    }
    impl utoipa::__dev::ComposeSchema for QuantitiesVec {
        fn compose(mut generics:
                Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>)
            -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
            Into::<utoipa::openapi::schema::OneOfBuilder>::into(utoipa::openapi::OneOf::with_capacity(9usize)).item(utoipa::openapi::schema::Object::builder().property("AmountOfSubstance",
                                                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                                let res =
                                                                                    ::alloc::fmt::format(format_args!("{0}",
                                                                                            <AmountOfSubstanceVec as utoipa::ToSchema>::name()));
                                                                                res
                                                                            }))).required("AmountOfSubstance").title(Some("AmountOfSubstance"))).item(utoipa::openapi::schema::Object::builder().property("Angle",
                                                                utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                            let res =
                                                                                ::alloc::fmt::format(format_args!("{0}",
                                                                                        <AngleVec as utoipa::ToSchema>::name()));
                                                                            res
                                                                        }))).required("Angle").title(Some("Angle"))).item(utoipa::openapi::schema::Object::builder().property("Dimensionless",
                                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                        let res =
                                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                                    <DimensionlessVec as utoipa::ToSchema>::name()));
                                                                        res
                                                                    }))).required("Dimensionless").title(Some("Dimensionless"))).item(utoipa::openapi::schema::Object::builder().property("ElectricCurrent",
                                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                    let res =
                                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                                <ElectricCurrentVec as utoipa::ToSchema>::name()));
                                                                    res
                                                                }))).required("ElectricCurrent").title(Some("ElectricCurrent"))).item(utoipa::openapi::schema::Object::builder().property("Length",
                                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                                let res =
                                                                    ::alloc::fmt::format(format_args!("{0}",
                                                                            <LengthVec as utoipa::ToSchema>::name()));
                                                                res
                                                            }))).required("Length").title(Some("Length"))).item(utoipa::openapi::schema::Object::builder().property("Luminance",
                                                utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                            let res =
                                                                ::alloc::fmt::format(format_args!("{0}",
                                                                        <LuminanceVec as utoipa::ToSchema>::name()));
                                                            res
                                                        }))).required("Luminance").title(Some("Luminance"))).item(utoipa::openapi::schema::Object::builder().property("Mass",
                                            utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                        let res =
                                                            ::alloc::fmt::format(format_args!("{0}",
                                                                    <MassVec as utoipa::ToSchema>::name()));
                                                        res
                                                    }))).required("Mass").title(Some("Mass"))).item(utoipa::openapi::schema::Object::builder().property("TemperatureInterval",
                                        utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                    let res =
                                                        ::alloc::fmt::format(format_args!("{0}",
                                                                <TemperatureIntervalVec as utoipa::ToSchema>::name()));
                                                    res
                                                }))).required("TemperatureInterval").title(Some("TemperatureInterval"))).item(utoipa::openapi::schema::Object::builder().property("Time",
                                    utoipa::openapi::schema::RefBuilder::new().ref_location_from_schema_name(::alloc::__export::must_use({
                                                let res =
                                                    ::alloc::fmt::format(format_args!("{0}",
                                                            <TimeVec as utoipa::ToSchema>::name()));
                                                res
                                            }))).required("Time").title(Some("Time"))).description(Some("\nA wrapper to hold all QuantitiesVec supported by this library. It is analogous to `Units``,\nbut when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit.\n")).into()
        }
    }
    impl utoipa::ToSchema for QuantitiesVec {
        fn name() -> std::borrow::Cow<'static, str> {
            std::borrow::Cow::Borrowed("QuantitiesVec")
        }
        fn schemas(schemas:
                &mut Vec<(String,
                utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>)>) {
            schemas.extend([(String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <AmountOfSubstanceVec as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <AmountOfSubstanceVec as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <AngleVec as utoipa::ToSchema>::name()));
                                        res
                                    })), <AngleVec as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <DimensionlessVec as utoipa::ToSchema>::name()));
                                        res
                                    })), <DimensionlessVec as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <ElectricCurrentVec as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <ElectricCurrentVec as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <LengthVec as utoipa::ToSchema>::name()));
                                        res
                                    })), <LengthVec as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <LuminanceVec as utoipa::ToSchema>::name()));
                                        res
                                    })), <LuminanceVec as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <MassVec as utoipa::ToSchema>::name()));
                                        res
                                    })), <MassVec as utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <TemperatureIntervalVec as utoipa::ToSchema>::name()));
                                        res
                                    })),
                            <TemperatureIntervalVec as
                                    utoipa::PartialSchema>::schema()),
                        (String::from(::alloc::__export::must_use({
                                        let res =
                                            ::alloc::fmt::format(format_args!("{0}",
                                                    <TimeVec as utoipa::ToSchema>::name()));
                                        res
                                    })), <TimeVec as utoipa::PartialSchema>::schema())]);
            <AmountOfSubstanceVec as utoipa::ToSchema>::schemas(schemas);
            <AngleVec as utoipa::ToSchema>::schemas(schemas);
            <DimensionlessVec as utoipa::ToSchema>::schemas(schemas);
            <ElectricCurrentVec as utoipa::ToSchema>::schemas(schemas);
            <LengthVec as utoipa::ToSchema>::schemas(schemas);
            <LuminanceVec as utoipa::ToSchema>::schemas(schemas);
            <MassVec as utoipa::ToSchema>::schemas(schemas);
            <TemperatureIntervalVec as utoipa::ToSchema>::schemas(schemas);
            <TimeVec as utoipa::ToSchema>::schemas(schemas);
            ;
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QuantitiesVec {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    match *self {
                        QuantitiesVec::AmountOfSubstance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 0u32, "AmountOfSubstance", __field0),
                        QuantitiesVec::Angle(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 1u32, "Angle", __field0),
                        QuantitiesVec::Dimensionless(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 2u32, "Dimensionless", __field0),
                        QuantitiesVec::ElectricCurrent(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 3u32, "ElectricCurrent", __field0),
                        QuantitiesVec::Length(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 4u32, "Length", __field0),
                        QuantitiesVec::Luminance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 5u32, "Luminance", __field0),
                        QuantitiesVec::Mass(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 6u32, "Mass", __field0),
                        QuantitiesVec::TemperatureInterval(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 7u32, "TemperatureInterval", __field0),
                        QuantitiesVec::Time(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesVec", 8u32, "Time", __field0),
                    }
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QuantitiesVec {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "variant identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ =>
                                    _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 9")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                "Angle" => _serde::__private::Ok(__Field::__field1),
                                "Dimensionless" => _serde::__private::Ok(__Field::__field2),
                                "ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                "Length" => _serde::__private::Ok(__Field::__field4),
                                "Luminance" => _serde::__private::Ok(__Field::__field5),
                                "Mass" => _serde::__private::Ok(__Field::__field6),
                                "TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                "Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                b"Angle" => _serde::__private::Ok(__Field::__field1),
                                b"Dimensionless" =>
                                    _serde::__private::Ok(__Field::__field2),
                                b"ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                b"Length" => _serde::__private::Ok(__Field::__field4),
                                b"Luminance" => _serde::__private::Ok(__Field::__field5),
                                b"Mass" => _serde::__private::Ok(__Field::__field6),
                                b"TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                b"Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QuantitiesVec>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QuantitiesVec;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "enum QuantitiesVec")
                        }
                        fn visit_enum<__A>(self, __data: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::EnumAccess<'de> {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<AmountOfSubstanceVec>(__variant),
                                        QuantitiesVec::AmountOfSubstance),
                                (__Field::__field1, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<AngleVec>(__variant),
                                        QuantitiesVec::Angle),
                                (__Field::__field2, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<DimensionlessVec>(__variant),
                                        QuantitiesVec::Dimensionless),
                                (__Field::__field3, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<ElectricCurrentVec>(__variant),
                                        QuantitiesVec::ElectricCurrent),
                                (__Field::__field4, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<LengthVec>(__variant),
                                        QuantitiesVec::Length),
                                (__Field::__field5, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<LuminanceVec>(__variant),
                                        QuantitiesVec::Luminance),
                                (__Field::__field6, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<MassVec>(__variant),
                                        QuantitiesVec::Mass),
                                (__Field::__field7, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<TemperatureIntervalVec>(__variant),
                                        QuantitiesVec::TemperatureInterval),
                                (__Field::__field8, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<TimeVec>(__variant),
                                        QuantitiesVec::Time),
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] =
                        &["AmountOfSubstance", "Angle", "Dimensionless",
                                    "ElectricCurrent", "Length", "Luminance", "Mass",
                                    "TemperatureInterval", "Time"];
                    _serde::Deserializer::deserialize_enum(__deserializer,
                        "QuantitiesVec", VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QuantitiesVec>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    #[automatically_derived]
    impl ::core::clone::Clone for QuantitiesVec {
        #[inline]
        fn clone(&self) -> QuantitiesVec {
            match self {
                QuantitiesVec::AmountOfSubstance(__self_0) =>
                    QuantitiesVec::AmountOfSubstance(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::Angle(__self_0) =>
                    QuantitiesVec::Angle(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::Dimensionless(__self_0) =>
                    QuantitiesVec::Dimensionless(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::ElectricCurrent(__self_0) =>
                    QuantitiesVec::ElectricCurrent(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::Length(__self_0) =>
                    QuantitiesVec::Length(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::Luminance(__self_0) =>
                    QuantitiesVec::Luminance(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::Mass(__self_0) =>
                    QuantitiesVec::Mass(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::TemperatureInterval(__self_0) =>
                    QuantitiesVec::TemperatureInterval(::core::clone::Clone::clone(__self_0)),
                QuantitiesVec::Time(__self_0) =>
                    QuantitiesVec::Time(::core::clone::Clone::clone(__self_0)),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for QuantitiesVec {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                QuantitiesVec::AmountOfSubstance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "AmountOfSubstance", &__self_0),
                QuantitiesVec::Angle(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Angle", &__self_0),
                QuantitiesVec::Dimensionless(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Dimensionless", &__self_0),
                QuantitiesVec::ElectricCurrent(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "ElectricCurrent", &__self_0),
                QuantitiesVec::Length(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Length", &__self_0),
                QuantitiesVec::Luminance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Luminance", &__self_0),
                QuantitiesVec::Mass(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Mass",
                        &__self_0),
                QuantitiesVec::TemperatureInterval(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "TemperatureInterval", &__self_0),
                QuantitiesVec::Time(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Time",
                        &__self_0),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for QuantitiesVec { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for QuantitiesVec {
        #[inline]
        fn eq(&self, other: &QuantitiesVec) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr &&
                match (self, other) {
                    (QuantitiesVec::AmountOfSubstance(__self_0),
                        QuantitiesVec::AmountOfSubstance(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesVec::Angle(__self_0),
                        QuantitiesVec::Angle(__arg1_0)) => __self_0 == __arg1_0,
                    (QuantitiesVec::Dimensionless(__self_0),
                        QuantitiesVec::Dimensionless(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesVec::ElectricCurrent(__self_0),
                        QuantitiesVec::ElectricCurrent(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesVec::Length(__self_0),
                        QuantitiesVec::Length(__arg1_0)) => __self_0 == __arg1_0,
                    (QuantitiesVec::Luminance(__self_0),
                        QuantitiesVec::Luminance(__arg1_0)) => __self_0 == __arg1_0,
                    (QuantitiesVec::Mass(__self_0),
                        QuantitiesVec::Mass(__arg1_0)) => __self_0 == __arg1_0,
                    (QuantitiesVec::TemperatureInterval(__self_0),
                        QuantitiesVec::TemperatureInterval(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesVec::Time(__self_0),
                        QuantitiesVec::Time(__arg1_0)) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl QuantitiesVec {
        #[doc =
        " Get the `Units` enumeration associated with a given `QuantitiesVec` enumeration."]
        pub fn unit(&self) -> Units {
            use crate::traits::FixedSliceQuantity;
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesVec::AmountOfSubstance(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesVec::Angle(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesVec::Dimensionless(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesVec::ElectricCurrent(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesVec::Length(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesVec::Luminance(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesVec::Mass(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesVec::TemperatureInterval(x) =>
                    crate::Units::from(x.unit()),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesVec::Time(x) => crate::Units::from(x.unit()),
            }
        }
        #[doc =
        " Try to convert to the unit specified by a given `Units` enumeration."]
        pub fn try_convert(&self, unit: Units)
            -> Result<QuantitiesVec, RuntimeUnitError> {
            use crate::traits::FixedSliceQuantity;
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesVec::AmountOfSubstance(x) => {
                    Ok(QuantitiesVec::AmountOfSubstance(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesVec::Angle(x) => {
                    Ok(QuantitiesVec::Angle(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesVec::Dimensionless(x) => {
                    Ok(QuantitiesVec::Dimensionless(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesVec::ElectricCurrent(x) => {
                    Ok(QuantitiesVec::ElectricCurrent(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesVec::Length(x) => {
                    Ok(QuantitiesVec::Length(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesVec::Luminance(x) => {
                    Ok(QuantitiesVec::Luminance(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesVec::Mass(x) => {
                    Ok(QuantitiesVec::Mass(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesVec::TemperatureInterval(x) => {
                    Ok(QuantitiesVec::TemperatureInterval(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesVec::Time(x) => {
                    Ok(QuantitiesVec::Time(x.try_convert(unit)?))
                }
            }
        }
        #[doc = " Create a new quantity from a given value and unit"]
        pub fn new(value: Vec<f64>, unit: Units) -> QuantitiesVec {
            match unit
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) => {
                    QuantitiesVec::AmountOfSubstance(AmountOfSubstanceVec::new(value,
                            x))
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) => {
                    QuantitiesVec::Angle(AngleVec::new(value, x))
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) => {
                    QuantitiesVec::Dimensionless(DimensionlessVec::new(value,
                            x))
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) => {
                    QuantitiesVec::ElectricCurrent(ElectricCurrentVec::new(value,
                            x))
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) => {
                    QuantitiesVec::Length(LengthVec::new(value, x))
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) => {
                    QuantitiesVec::Luminance(LuminanceVec::new(value, x))
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) => {
                    QuantitiesVec::Mass(MassVec::new(value, x))
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) => {
                    QuantitiesVec::TemperatureInterval(TemperatureIntervalVec::new(value,
                            x))
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) => {
                    QuantitiesVec::Time(TimeVec::new(value, x))
                }
            }
        }
        #[doc = " Get the value associated with quantity."]
        pub fn values(&self) -> Vec<f64> {
            use crate::vector_quantity::VecQuantity;
            VecQuantity::from(self.clone()).values
        }
    }
    #[doc =
    " A means to create a default quantity with a given set of units."]
    impl From<Units> for QuantitiesVec {
        fn from(value: Units) -> Self {
            match value
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) => {
                    QuantitiesVec::new(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0.0])),
                        x.into())
                }
            }
        }
    }
    impl From<QuantitiesVec> for crate::vector_quantity::VecQuantity {
        fn from(value: QuantitiesVec) -> Self {
            match value
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesVec::AmountOfSubstance(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: amount_of_substance::AMOUNTOFSUBSTANCE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesVec::Angle(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: angle::ANGLE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesVec::Dimensionless(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: dimensionless::DIMENSIONLESS_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesVec::ElectricCurrent(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: electric_current::ELECTRICCURRENT_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesVec::Length(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: length::LENGTH_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesVec::Luminance(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: luminance::LUMINANCE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesVec::Mass(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: mass::MASS_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesVec::TemperatureInterval(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: temperature_interval::TEMPERATUREINTERVAL_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesVec::Time(x) =>
                    crate::vector_quantity::VecQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: time::TIME_UNIT_BASE,
                        },
                    },
            }
        }
    }
    impl ToString for QuantitiesVec {
        fn to_string(&self) -> String {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesVec::AmountOfSubstance(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesVec::Angle(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesVec::Dimensionless(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesVec::ElectricCurrent(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesVec::Length(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesVec::Luminance(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesVec::Mass(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesVec::TemperatureInterval(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesVec::Time(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
            }
        }
    }
    #[doc = ""]
    #[doc =
    " A wrapper to hold all QuantitiesArray supported by this library. It is analogous to `Units``, "]
    #[doc =
    " but when combined with the `serde` feature flag, can serve as a way to serialize a quantity, not just the unit. "]
    #[doc = " "]
    pub enum QuantitiesArray<const N : usize> {

        #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
        AmountOfSubstance(AmountOfSubstanceArray<N>),

        #[cfg(any(feature = "Angle", feature = "All"))]
        Angle(AngleArray<N>),

        #[cfg(any(feature = "Dimensionless", feature = "All"))]
        Dimensionless(DimensionlessArray<N>),

        #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
        ElectricCurrent(ElectricCurrentArray<N>),

        #[cfg(any(feature = "Length", feature = "All"))]
        Length(LengthArray<N>),

        #[cfg(any(feature = "Luminance", feature = "All"))]
        Luminance(LuminanceArray<N>),

        #[cfg(any(feature = "Mass", feature = "All"))]
        Mass(MassArray<N>),

        #[cfg(any(feature = "TemperatureInterval", feature = "All"))]
        TemperatureInterval(TemperatureIntervalArray<N>),

        #[cfg(any(feature = "Time", feature = "All"))]
        Time(TimeArray<N>),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<const N : usize> _serde::Serialize for QuantitiesArray<N> {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    match *self {
                        QuantitiesArray::AmountOfSubstance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 0u32, "AmountOfSubstance", __field0),
                        QuantitiesArray::Angle(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 1u32, "Angle", __field0),
                        QuantitiesArray::Dimensionless(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 2u32, "Dimensionless", __field0),
                        QuantitiesArray::ElectricCurrent(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 3u32, "ElectricCurrent", __field0),
                        QuantitiesArray::Length(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 4u32, "Length", __field0),
                        QuantitiesArray::Luminance(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 5u32, "Luminance", __field0),
                        QuantitiesArray::Mass(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 6u32, "Mass", __field0),
                        QuantitiesArray::TemperatureInterval(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 7u32, "TemperatureInterval", __field0),
                        QuantitiesArray::Time(ref __field0) =>
                            _serde::Serializer::serialize_newtype_variant(__serializer,
                                "QuantitiesArray", 8u32, "Time", __field0),
                    }
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, const N : usize> _serde::Deserialize<'de> for
                QuantitiesArray<N> {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "variant identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ =>
                                    _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 9")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                "Angle" => _serde::__private::Ok(__Field::__field1),
                                "Dimensionless" => _serde::__private::Ok(__Field::__field2),
                                "ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                "Length" => _serde::__private::Ok(__Field::__field4),
                                "Luminance" => _serde::__private::Ok(__Field::__field5),
                                "Mass" => _serde::__private::Ok(__Field::__field6),
                                "TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                "Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"AmountOfSubstance" =>
                                    _serde::__private::Ok(__Field::__field0),
                                b"Angle" => _serde::__private::Ok(__Field::__field1),
                                b"Dimensionless" =>
                                    _serde::__private::Ok(__Field::__field2),
                                b"ElectricCurrent" =>
                                    _serde::__private::Ok(__Field::__field3),
                                b"Length" => _serde::__private::Ok(__Field::__field4),
                                b"Luminance" => _serde::__private::Ok(__Field::__field5),
                                b"Mass" => _serde::__private::Ok(__Field::__field6),
                                b"TemperatureInterval" =>
                                    _serde::__private::Ok(__Field::__field7),
                                b"Time" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                            VARIANTS))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, const N : usize> {
                        marker: _serde::__private::PhantomData<QuantitiesArray<N>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de, const N : usize> _serde::de::Visitor<'de> for
                        __Visitor<'de, N> {
                        type Value = QuantitiesArray<N>;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "enum QuantitiesArray")
                        }
                        fn visit_enum<__A>(self, __data: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::EnumAccess<'de> {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<AmountOfSubstanceArray<N>>(__variant),
                                        QuantitiesArray::AmountOfSubstance),
                                (__Field::__field1, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<AngleArray<N>>(__variant),
                                        QuantitiesArray::Angle),
                                (__Field::__field2, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<DimensionlessArray<N>>(__variant),
                                        QuantitiesArray::Dimensionless),
                                (__Field::__field3, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<ElectricCurrentArray<N>>(__variant),
                                        QuantitiesArray::ElectricCurrent),
                                (__Field::__field4, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<LengthArray<N>>(__variant),
                                        QuantitiesArray::Length),
                                (__Field::__field5, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<LuminanceArray<N>>(__variant),
                                        QuantitiesArray::Luminance),
                                (__Field::__field6, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<MassArray<N>>(__variant),
                                        QuantitiesArray::Mass),
                                (__Field::__field7, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<TemperatureIntervalArray<N>>(__variant),
                                        QuantitiesArray::TemperatureInterval),
                                (__Field::__field8, __variant) =>
                                    _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<TimeArray<N>>(__variant),
                                        QuantitiesArray::Time),
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] =
                        &["AmountOfSubstance", "Angle", "Dimensionless",
                                    "ElectricCurrent", "Length", "Luminance", "Mass",
                                    "TemperatureInterval", "Time"];
                    _serde::Deserializer::deserialize_enum(__deserializer,
                        "QuantitiesArray", VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QuantitiesArray<N>>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    #[automatically_derived]
    impl<const N : usize> ::core::marker::Copy for QuantitiesArray<N> { }
    #[automatically_derived]
    impl<const N : usize> ::core::clone::Clone for QuantitiesArray<N> {
        #[inline]
        fn clone(&self) -> QuantitiesArray<N> {
            let _:
                    ::core::clone::AssertParamIsClone<AmountOfSubstanceArray<N>>;
            let _: ::core::clone::AssertParamIsClone<AngleArray<N>>;
            let _: ::core::clone::AssertParamIsClone<DimensionlessArray<N>>;
            let _: ::core::clone::AssertParamIsClone<ElectricCurrentArray<N>>;
            let _: ::core::clone::AssertParamIsClone<LengthArray<N>>;
            let _: ::core::clone::AssertParamIsClone<LuminanceArray<N>>;
            let _: ::core::clone::AssertParamIsClone<MassArray<N>>;
            let _:
                    ::core::clone::AssertParamIsClone<TemperatureIntervalArray<N>>;
            let _: ::core::clone::AssertParamIsClone<TimeArray<N>>;
            *self
        }
    }
    #[automatically_derived]
    impl<const N : usize> ::core::fmt::Debug for QuantitiesArray<N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                QuantitiesArray::AmountOfSubstance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "AmountOfSubstance", &__self_0),
                QuantitiesArray::Angle(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Angle", &__self_0),
                QuantitiesArray::Dimensionless(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Dimensionless", &__self_0),
                QuantitiesArray::ElectricCurrent(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "ElectricCurrent", &__self_0),
                QuantitiesArray::Length(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Length", &__self_0),
                QuantitiesArray::Luminance(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "Luminance", &__self_0),
                QuantitiesArray::Mass(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Mass",
                        &__self_0),
                QuantitiesArray::TemperatureInterval(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "TemperatureInterval", &__self_0),
                QuantitiesArray::Time(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Time",
                        &__self_0),
            }
        }
    }
    #[automatically_derived]
    impl<const N : usize> ::core::marker::StructuralPartialEq for
        QuantitiesArray<N> {
    }
    #[automatically_derived]
    impl<const N : usize> ::core::cmp::PartialEq for QuantitiesArray<N> {
        #[inline]
        fn eq(&self, other: &QuantitiesArray<N>) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr &&
                match (self, other) {
                    (QuantitiesArray::AmountOfSubstance(__self_0),
                        QuantitiesArray::AmountOfSubstance(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesArray::Angle(__self_0),
                        QuantitiesArray::Angle(__arg1_0)) => __self_0 == __arg1_0,
                    (QuantitiesArray::Dimensionless(__self_0),
                        QuantitiesArray::Dimensionless(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesArray::ElectricCurrent(__self_0),
                        QuantitiesArray::ElectricCurrent(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesArray::Length(__self_0),
                        QuantitiesArray::Length(__arg1_0)) => __self_0 == __arg1_0,
                    (QuantitiesArray::Luminance(__self_0),
                        QuantitiesArray::Luminance(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesArray::Mass(__self_0),
                        QuantitiesArray::Mass(__arg1_0)) => __self_0 == __arg1_0,
                    (QuantitiesArray::TemperatureInterval(__self_0),
                        QuantitiesArray::TemperatureInterval(__arg1_0)) =>
                        __self_0 == __arg1_0,
                    (QuantitiesArray::Time(__self_0),
                        QuantitiesArray::Time(__arg1_0)) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl<const N : usize> QuantitiesArray<N> {
        #[doc =
        " Get the `Units` enumeration associated with a given `QuantitiesArray` enumeration."]
        pub fn unit(&self) -> Units {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesArray::AmountOfSubstance(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesArray::Angle(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesArray::Dimensionless(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesArray::ElectricCurrent(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesArray::Length(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesArray::Luminance(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesArray::Mass(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesArray::TemperatureInterval(x) =>
                    crate::Units::from(x.unit),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesArray::Time(x) => crate::Units::from(x.unit),
            }
        }
        #[doc =
        " Try to convert to the unit specified by a given `Units` enumeration."]
        pub fn try_convert(&self, unit: Units)
            -> Result<QuantitiesArray<N>, RuntimeUnitError> {
            use crate::traits::FixedSliceQuantity;
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesArray::AmountOfSubstance(x) => {
                    Ok(QuantitiesArray::AmountOfSubstance(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesArray::Angle(x) => {
                    Ok(QuantitiesArray::Angle(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesArray::Dimensionless(x) => {
                    Ok(QuantitiesArray::Dimensionless(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesArray::ElectricCurrent(x) => {
                    Ok(QuantitiesArray::ElectricCurrent(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesArray::Length(x) => {
                    Ok(QuantitiesArray::Length(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesArray::Luminance(x) => {
                    Ok(QuantitiesArray::Luminance(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesArray::Mass(x) => {
                    Ok(QuantitiesArray::Mass(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesArray::TemperatureInterval(x) => {
                    Ok(QuantitiesArray::TemperatureInterval(x.try_convert(unit)?))
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesArray::Time(x) => {
                    Ok(QuantitiesArray::Time(x.try_convert(unit)?))
                }
            }
        }
        #[doc = " Create a new quantity from a given value and unit"]
        pub fn new(value: [f64; N], unit: Units) -> QuantitiesArray<N> {
            match unit
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) => {
                    QuantitiesArray::AmountOfSubstance(AmountOfSubstanceArray {
                            values: value,
                            unit: x,
                        })
                }
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) => {
                    QuantitiesArray::Angle(AngleArray {
                            values: value,
                            unit: x,
                        })
                }
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) => {
                    QuantitiesArray::Dimensionless(DimensionlessArray {
                            values: value,
                            unit: x,
                        })
                }
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) => {
                    QuantitiesArray::ElectricCurrent(ElectricCurrentArray {
                            values: value,
                            unit: x,
                        })
                }
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) => {
                    QuantitiesArray::Length(LengthArray {
                            values: value,
                            unit: x,
                        })
                }
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) => {
                    QuantitiesArray::Luminance(LuminanceArray {
                            values: value,
                            unit: x,
                        })
                }
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) => {
                    QuantitiesArray::Mass(MassArray { values: value, unit: x })
                }
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) => {
                    QuantitiesArray::TemperatureInterval(TemperatureIntervalArray {
                            values: value,
                            unit: x,
                        })
                }
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) => {
                    QuantitiesArray::Time(TimeArray { values: value, unit: x })
                }
            }
        }
        #[doc = " Get the value associated with quantity."]
        pub fn values(&self) -> [f64; N] {
            use crate::array_quantity::ArrayQuantity;
            ArrayQuantity::from(*self).values
        }
    }
    #[doc =
    " A means to create a default quantity with a given set of units."]
    impl<const N : usize> From<Units> for QuantitiesArray<N> {
        fn from(value: Units) -> Self {
            match value
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    Units::AmountOfSubstance(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    Units::Angle(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    Units::Dimensionless(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    Units::ElectricCurrent(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    Units::Length(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    Units::Luminance(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    Units::Mass(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    Units::TemperatureInterval(x) =>
                    QuantitiesArray::new([0.0; N],
                        x.into()),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    Units::Time(x) => QuantitiesArray::new([0.0; N], x.into()),
            }
        }
    }
    impl<const N : usize> From<QuantitiesArray<N>> for
        crate::array_quantity::ArrayQuantity<N> {
        fn from(value: QuantitiesArray<N>) -> Self {
            use crate::array_quantity::ArrayQuantity;
            match value
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesArray::AmountOfSubstance(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: amount_of_substance::AMOUNTOFSUBSTANCE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesArray::Angle(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: angle::ANGLE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesArray::Dimensionless(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: dimensionless::DIMENSIONLESS_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesArray::ElectricCurrent(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: electric_current::ELECTRICCURRENT_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesArray::Length(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: length::LENGTH_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesArray::Luminance(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: luminance::LUMINANCE_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesArray::Mass(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: mass::MASS_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesArray::TemperatureInterval(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: temperature_interval::TEMPERATUREINTERVAL_UNIT_BASE,
                        },
                    },
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesArray::Time(x) =>
                    ArrayQuantity {
                        values: x.values,
                        unit: UnitDefinition {
                            multiplier: x.unit.multiplier(),
                            base: time::TIME_UNIT_BASE,
                        },
                    },
            }
        }
    }
    impl<const N : usize> ToString for QuantitiesArray<N> {
        fn to_string(&self) -> String {
            match self
                {
                    #[cfg(any(feature = "AmountOfSubstance", feature = "All"))]
                    QuantitiesArray::AmountOfSubstance(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Angle", feature = "All"))]
                    QuantitiesArray::Angle(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Dimensionless", feature = "All"))]
                    QuantitiesArray::Dimensionless(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "ElectricCurrent", feature = "All"))]
                    QuantitiesArray::ElectricCurrent(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Length", feature = "All"))]
                    QuantitiesArray::Length(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Luminance", feature = "All"))]
                    QuantitiesArray::Luminance(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Mass", feature = "All"))]
                    QuantitiesArray::Mass(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "TemperatureInterval", feature =
                    "All"))]
                    QuantitiesArray::TemperatureInterval(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
                    #[cfg(any(feature = "Time", feature = "All"))]
                    QuantitiesArray::Time(x) =>
                    ::alloc::__export::must_use({
                            let res =
                                ::alloc::fmt::format(format_args!("{0:?} {1}", x.values,
                                        x.unit.abbreviation()));
                            res
                        }),
            }
        }
    }
}
pub use crate::unit_definitions::*;
pub mod vector_quantity {
    use crate::{errors::RuntimeUnitError, units_base::UnitDefinition};
    use core::ops::{AddAssign, Div, DivAssign, Mul, MulAssign, SubAssign};
    use std::ops::{Deref, DerefMut};
    #[doc = "Data structure to hold a unit and array of data"]
    pub struct VecQuantity {
        pub unit: UnitDefinition,
        pub values: Vec<f64>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for VecQuantity {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    let mut __serde_state =
                        _serde::Serializer::serialize_struct(__serializer,
                                "VecQuantity", false as usize + 1 + 1)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "unit", &self.unit)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "values", &self.values)?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for VecQuantity {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field { __field0, __field1, __ignore, }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "unit" => _serde::__private::Ok(__Field::__field0),
                                "values" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"unit" => _serde::__private::Ok(__Field::__field0),
                                b"values" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<VecQuantity>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = VecQuantity;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "struct VecQuantity")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<UnitDefinition>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                    &"struct VecQuantity with 2 elements")),
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<Vec<f64>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                    &"struct VecQuantity with 2 elements")),
                                };
                            _serde::__private::Ok(VecQuantity {
                                    unit: __field0,
                                    values: __field1,
                                })
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::MapAccess<'de> {
                            let mut __field0:
                                    _serde::__private::Option<UnitDefinition> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<f64>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                    _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("unit"));
                                            }
                                        __field0 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<UnitDefinition>(&mut __map)?);
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("values"));
                                            }
                                        __field1 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?);
                                    }
                                    _ => {
                                        let _ =
                                            _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("unit")?,
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("values")?,
                                };
                            _serde::__private::Ok(VecQuantity {
                                    unit: __field0,
                                    values: __field1,
                                })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["unit", "values"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                        "VecQuantity", FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<VecQuantity>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    #[automatically_derived]
    impl ::core::clone::Clone for VecQuantity {
        #[inline]
        fn clone(&self) -> VecQuantity {
            VecQuantity {
                unit: ::core::clone::Clone::clone(&self.unit),
                values: ::core::clone::Clone::clone(&self.values),
            }
        }
    }
    impl Deref for VecQuantity {
        type Target = Vec<f64>;
        fn deref(&self) -> &Vec<f64> { &self.values }
    }
    impl DerefMut for VecQuantity {
        fn deref_mut(&mut self) -> &mut Vec<f64> { &mut self.values }
    }
    impl crate::traits::ArbitraryQuantity for VecQuantity {
        fn unit(&self) -> UnitDefinition { self.unit }
        fn convert(&self, unit: UnitDefinition) -> Self {
            let mut result = self.clone();
            result.convert_mut(unit);
            return result;
        }
        fn convert_mut(&mut self, unit: UnitDefinition) {
            let factor = self.unit.convert_unchecked(unit);
            for val in self.values.as_mut_slice().iter_mut() {
                *val *= factor;
            }
        }
        fn try_convert(&self, unit: UnitDefinition)
            -> Result<Self, crate::errors::RuntimeUnitError> {
            if self.unit.base != unit.base {
                    Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                    let res =
                                        ::alloc::fmt::format(format_args!("Could not convert from base units of {0} to {1}",
                                                self.unit.unit_string(), unit.unit_string()));
                                    res
                                })))
                } else { Ok(self.convert(unit)) }
        }
        fn try_convert_mut(&mut self, unit: UnitDefinition)
            -> Result<(), crate::errors::RuntimeUnitError> {
            if self.unit.base != unit.base {
                    Err(RuntimeUnitError::IncompatibleUnitConversion(::alloc::__export::must_use({
                                    let res =
                                        ::alloc::fmt::format(format_args!("Could not convert from base units of {0} to {1}",
                                                self.unit.unit_string(), unit.unit_string()));
                                    res
                                })))
                } else { Ok(self.convert_mut(unit)) }
        }
        fn unit_mut(&mut self) -> &mut UnitDefinition { &mut self.unit }
    }
    impl Div<f64> for VecQuantity {
        type Output = VecQuantity;
        fn div(self, rhs: f64) -> Self::Output {
            let mut result = self.clone();
            for val in result.values.as_mut_slice() { *val /= rhs; }
            result
        }
    }
    impl Div<VecQuantity> for VecQuantity {
        type Output = VecQuantity;
        fn div(self, rhs: VecQuantity) -> Self::Output {
            let mut result = self.clone();
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            for (val, &rhs) in
                result.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val /= rhs;
            }
            result
        }
    }
    impl Mul<VecQuantity> for VecQuantity {
        type Output = VecQuantity;
        fn mul(self, rhs: VecQuantity) -> Self::Output {
            let mut result = self.clone();
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            for (val, &rhs) in
                result.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val *= rhs;
            }
            result
        }
    }
    impl Mul<f64> for VecQuantity {
        type Output = VecQuantity;
        fn mul(self, rhs: f64) -> Self::Output {
            let mut result = self.clone();
            for val in result.values.as_mut_slice() { *val *= rhs; }
            result
        }
    }
    impl DivAssign<f64> for VecQuantity {
        fn div_assign(&mut self, rhs: f64) {
            for val in self.values.as_mut_slice() { *val /= rhs; }
        }
    }
    impl MulAssign<f64> for VecQuantity {
        fn mul_assign(&mut self, rhs: f64) {
            for val in self.values.as_mut_slice() { *val *= rhs; }
        }
    }
    impl DivAssign<VecQuantity> for VecQuantity {
        fn div_assign(&mut self, rhs: VecQuantity) {
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            for (val, &rhs) in
                self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val /= rhs;
            }
        }
    }
    impl AddAssign<VecQuantity> for VecQuantity {
        fn add_assign(&mut self, rhs: VecQuantity) {
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            let factor = rhs.unit.convert_unchecked(self.unit);
            for (val, &rhs) in
                self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val += rhs * factor;
            }
        }
    }
    impl SubAssign<VecQuantity> for VecQuantity {
        fn sub_assign(&mut self, rhs: VecQuantity) {
            if rhs.values.len() != self.values.len() {
                    {
                        ::core::panicking::panic_fmt(format_args!("Slice dimensions do not match: {0} != {1}",
                                rhs.values.len(), self.values.len()));
                    };
                }
            let factor = rhs.unit.convert_unchecked(self.unit);
            for (val, &rhs) in
                self.values.as_mut_slice().iter_mut().zip(rhs.values.as_slice())
                {
                *val -= rhs * factor;
            }
        }
    }
}
